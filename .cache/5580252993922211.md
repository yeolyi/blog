---
title: 모던 자바스크립트 deep dive
---

## 출처

[yes24](http://www.yes24.com/Product/Goods/92742567) [교보](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791158392239)

## 1. 프로그래밍

### 3. 구문과 의미

```js
const number = 'string';
console.log(number * number);
```

문법적(syntax)으로 문제가 없지만 의미적(semantics)으로는 옳지 않다. 언어와 마찬가지로 코드는 문법에맞는 문장을 구성하고 의미를 가져야한다.

> 결국 프로그래밍은 요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로변환한 후, 그 흐름을제어하는 것이다.

## 2. 자바스크립트란?

### 3. 자바스크립트 성장의 역사

**Ajax**는 XMLHttpRequest라는 이름으로 등장, 서버와 브라우저가 비동기로 데이터를교환할 수 있다. 기존에는 화면 전환시 전체를 렌더링하기에 깜빡거렸다. Ajax 이후에는 필요한 부분만 렌더링하는 방식이 가능해졌다.

**jQuery**는 DOM을 쉽게 제어할 수 있게 했고 크로스 브라우징 이슈를 어느정도 해결했다.

구글의 **V8 자바스크립트 엔진**으로 서버의 몇몇 로직이 클라이언트로 이동하여 프론트엔드가 주목받았다 .

**Node.js**는 자바스크립트를 브라우저 이외의 환경에서도 동작하게하며, 서버 개발에 주로 사용되며 이에필요한 모듈, 파일 시스템, HTTP등 빌트인 API를 제공한다. 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작해 request 처리 성능이좋다. 이에 I/O가 빈번한 SPA에 적합하며 CPU 사용률이 높은 부분에는 권장하지 않는다.

이후 복잡해진 개발 과정에 대응하기 위해 패턴과 라이브러리가 출현했지만, 리액트와같은 프레임워크가 등장했다.

### 4. 자바스크립트와 ECMAScript

자바스크립트는 core인 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이즈 Web API(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame...)등을아우르는 개념이다.

클라이언트사이즈는 ECMAScript와는 별개로 W3C에서 별도의 사양으로 관리하고 있다.

### 5. 자바스크립트의 특징

웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. 인터프리터 언어. 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.

## 3. 자바스크립트 개발 환경과 실행 방법

### 3. Node.js

> npm(node package manager)은 자바스크립트 패키지 매니저이다. Node.js에서 사용할수 있는 모듈들을 패키지화해서 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다.

## 4. 변수

변수에 저장된 값을 읽어들이는 것을 **참조**(reference)라 한다.

변수 이름을 **식별자**(identifier)라고도 한다.

### 3. 변수 선언

**변수 선언**(declaration)이란 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수있게 준비하는 것이다.

ES6은 ES5의 superset이다.

**키워드**란 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다.

자바스크립트 엔진은 변수 선언을 선언 단계와 초기화 단계 2단계에 걸쳐 수행한다.

**실행 컨텍스트**는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 자바스크립트 엔진은실행 컨텍스트를 통해 식별자와 스코프를관리한다.

**초기화**(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다 .

### 4. 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트에서 변수, 함수, 클래스등의 식별자는 호이스팅되어 런타임 단계에서 선언문들이(할당문 x) 먼저 실행된다.

!@chapter4/hoisting.js@!

### 5. 값의 할당

> 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 런타임에 실행된다.

!@chapter4/hoisting2.js@!

### 6. 값의 재할당

변수에 값을 재할당하면 기존 공간을 지우고 그 메모리 공간에 새롭게 저장하는 것이아니라 새로운 메모리공간을 확보하고 그곳에 값을 저장한다.

**Unmanaged language / Managed language**는 저수준 메모리 제어 기능의 유무로 구분된다.

### 7. 식별자 네이밍 규칙

특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있으며, 숫자로시작할 수 없으며, 예약어는 사용할 수 없다.

!@chapter4/naming.js@!

## 5. 표현식과 문

### 1. 값

> 값(value)은 표현식(expression)이 평가(evaluation)되어 생성된 결과이다.

> 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을식별하기 위해 붙인이름이다.

### 2. 리터럴

> **리터럴**(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을말한다. JS 엔진은 런타임에 리터럴을 평가해 값을 생성한다.

!@chapter5/literal.js@!

### 3. 표현식

> **표현식**(expression)은 값으로 평가될 수 있는 문(statement)이다.

> 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.

리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메서드 호출 표현식...

문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.

### 4. 문

> **문**(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.

> **토큰**이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

!@chapter5/statement.js@!

### 5. 세미콜론과 세미콜론 자동 삽입 기능

문을 끝낼 때에는 세미콜론을 붙여야 한다.

코드 블록은 self closing의 성격을 가지기 때문에 세미콜론을 뒤에 붙이지 않아도 좋다.

ASI(Automatic semicolon insertion)으로 인해 사실 세미콜론을 붙이지 않아도 되긴한다.

!@chapter5/asiFail.js@!

### 6. 표현식인 문과 표현식이 아닌 문

!@chapter5/statementExpression.js@!

## 6. 데이터 타입

**원시 타입**(primitive type): number, string, boolean, undefined, null, Symbol

**객체 타입**(object/reference type): 객체, 함수, 배열

!@chapter6/bigInt.js@!

### 1. 숫자 타입

!@chapter6/number.js@!

### 2. 문자열 타입

> 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합

일반적으로 작음따옴표를 사용.

배열인 C와 객체인 Java와 다르게 JS에서 문자열은 원시 타입이며 immutable하다.

### 3. 템플릿 리터럴

ES6부터 추가된 새로운 문자열 표기법. 백틱(`)을 사용하며 multiline string, expression interpolation, tagged template등의 기능을 제공한다. [참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals)

!@chapter6/escapeSequence.js@!

\n은 LF(Line Feed), \r은 CR(Carriage Return). 과거 타자기에서 전자는 종이를 한줄올리고 후자는 커서를맨 앞줄로 이동시켰다. 요즘은 기능은 같지만 전자를 사용한다.

!@chapter6/templateLiteral.js@!

> \+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

### 5. undefined 타입

undefined 타입의 값은 undefined가 유일하다.

> 자바스크립트 엔진이 변수를 초기화하는데 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. ... 대신에 null을 사용

> 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호하다 . ... ECMAScript 사양을 따라 변수는 선언하고 함수는 정의한다고 표현하자.

### 6. null 타입

null타입의 값은 null이 유일하다. 변수 값의 의도적 부재(intentional absence)를 명시할 때 사용한다. 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.

### 9. 데이터 타입의 필요성

> 컴파일러 또는 인터프리터는 **심벌 테이블**이라고 부르는 자료 구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리한다.

> 자바스크립트에서의 변수는 선언이 아닌 할당에 의해 타입이 결정(type inference) 된다. 그리고 재할당에 의해 변수의 타입은 바뀔 수 있다(dynamic typing).

## 7. 연산자

> 피연산자가 '값'이라는 명사의 역할을 한다면 연산자는 '피연산자를 연산하여 새로운 값을 만들다'라는동사의 역할을 한다고 볼 수 있다.

### 1. 산술 연산자

**implicit coersion, type coercion**

!@chapter7/unaryPlus.js@!

!@chapter7/binaryPlus.js@!

### 2. 할당 연산자

!@chapter7/assignmentOperator.js@!

### 3. 비교 연산자

**동등 비교**(loose equality) 연산자는 암묵적 타입 변환을 통해 타입을 일치시킨후비교한다.

!@chapter7/looseEquality.js@!

**일치 비교**(strict equality) 연산자는 타입또한 비교한다.

!@chapter7/objectIs.js@!

### 6. 쉼표 연산자

> 왼쪽 피연산자부터 차례대로 평가하고 마지막 평가 결과를 반환한다.

!@chapter7/objectIs.js@!

### 7. typeof 연산자

!@chapter7/typeOf.js@!

### 11. 연산자의 부수 효과

> 부수 효과가 있는 연산자는 =, ++/--, delete 연산자다.

### 13. 연산자 결합 순서

> 연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 것인지

## 8. 제어문

> 고차함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.

### 1. 블록문

> 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.

### 2. 조건문

switch문에서 default문은 선택사항. if/else문은 논리적 참, 거짓으로 실행할 코드블록을 결정하고, switch문은 다양한 상황(case)에 따라 결정한다. break문이 없으면 case문의 실행 흐름이 다음으로 넘어간다.

!@chapter8/switchStatement.js@!

for문은 반복 횟수가 명확할 때 사용하고, while문은 불명확할 때 사용한다.

### 4. break문

!@chapter8/labelStatement.js@!

## 9. 타입 변환과 단축 평가

명시적 타입 변환(explicit coercion) / 타입 캐스팅(type casting)

암묵적 타입 변환(implicit coercion) / 타입 강제 변환(type coercion)

위 두 타입 변환이 기존 원시 값을 변경하는 것은 아니다. 원시 값은 변경 불가능한값 (immutable value)이므로 변경할 수 없다.

### 2. 암묵적 타입 변환

!@chapter9/implicitCoercion.js@!

### 3. 명시적 타입 변환

- 표준 빌트인 생성자 함수를 new 연산자 없이 호출
- 빌트인 메서드 사용
- 암묵적 타입 변환 이용

!@chapter9/explicitCoercion.js@!

### 4. 단축 평가

> 논리합 또는 논리곱 연산자는 전에나 2개의 피연산자 중 어느 한쪽으로 평가된다.

!@chapter9/shortCircuitEvaluation.js@!

위 방법은 0이나 ''가 Falsy값이기 때문에 이를 그대로 반환하지만, 이들은 객체일 수있기 때문에 아래의옵셔널 체이닝 방법이 낫다.

!@chapter9/optionalChaining.js@!

null 병합 연산자(nullish coalescing) 연산자도 바찬가지로 ||를 사용할 단축 평가로대체할 수 있지만 Falsy값인 0과 ''도 유효한 기본값이라면 문제를 일으킬 수 있다.

## 10. 객체 리터럴

### 1. 객체란?

원시 값을 제외한 나머지 값은 모두 객체다. 원시 값은 immutable value지만 객체는 mutable value이다.

> 함수로 객체를 생성하기도 하며 함수 자체가 객체이기도 한다. 자바스크립트에서 함수와 객체는 분리해서생각할 수 없는 개념이다.

### 2. 객체 리터럴에 의한 객체 생성

> 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는 데 주의하자. ... 따라서객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.

### 3. 프로퍼티

프로퍼티 키에는 모든 문자열 또는 심벌 값이 사용될 수 있고, 프로퍼티 값으로는 모든 값이 가능하다.

식별자 네이밍 규칙을 따르지 않는 키에는 반드시 따옴표를 사용해야 한다.

!@chapter10/property.js@!

### 9. ES6에서 추가된 객체 리터럴의 확장 기능

!@chapter10/es6Property.js@!

## 11. 원시 값과 객체의 비교

- 원시값은 immutable, 객체는 mutable
- 원시값이 할당된 변수에는 실제 값이 저장되고, 객체가 할당된 변수에는 참조값이저장된다.
- 다른 변수에 할당시 원시 값은 복사되고(pass by value), 객체는 참조 값이 복사되어 전달된다(pass by reference).

### 1. 원시 값

한번 생성된 원시 값은 read only로 변경할 수 없다.

원시 값을 할당한 변수에 다른 값을 재할당하면 새로운 메모리 공간을 확보하고 변수가 이곳을 가르키게 된다.

> 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

근데 immutable하다고 같은 메모리 주소에 머물러야한다는건 아니지 않나??? 재할당안하고 그자리에서 바꾸는건 왜 안됨? 어차피 복사라서 상태 변경을 걱정할 필요는 없지않나.

그림에서는 메모리 주소로 표현했는데 실제로는 레지스터고 암튼 설명용일 수 있으니일단 넘어가자.

암튼 변수가 원시 값을 가리키는 한 변수를 재할당하지 않는 이상 그 변수 값이 유지될 것임이 보장된다.

문자열도 원시값이므로 변경할 수 없다.

!@chapter11/immutableString.js@!

> 참고로 '값에 의한 전달'이라는 용어는 자바스크립트를 위한 용어가 아니므로 사실오해가 있을 수도 있다 . \*\*엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

### 2. 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

> 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블(연관 배열, map, dictionary, looup table)이라고 생각할 수 있다.

클래스 기반 언어는 프로퍼티/메서드가 정해져 있지만 자바스크립트는 동적으로 변할수 있으므로 비효율적이다. 이에 V8 엔진에서는 동적 탐색(dynamic lookup) 대신 히든클래스(hidden class)라는 방식을 사용해성능을 높인다. (147p 참고)

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값 (reference value)에접근할 수 있다. 참조값이 객체가 저장된 메모리 공간의 주소이다.

왜 한번에 객체로 안가게 했지??

[Understanding JavaScript Pass-By-Value](https://www.javascripttutorial.net/javascript-pass-by-value/) [Does javascript pass by reference?](https://stackoverflow.com/a/13104528) [Evaluation strategy](https://en.wikipedia.org/wiki/Evaluation_strategy)

나중에 한번 더 정리해보면 좋을 듯.

## 12. 함수

### 1. 함수란?

> 함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로정의한 것이다.

매개변수(parameter), 인수(argument), 반환값(return value)

### 3. 함수 리터럴

함수 리터럴에서 함수 이름은 생략 가능하며, 만약 있다면 함수 몸체 내에서만 참조할수 있는 식별자이다.

함수는 객체이며 일반 객체와 다르게 호출할 수 있다.

### 4. 함수 정의

**함수 선언문**

함수 선언문은 표현식이 아닌 문이다. 다만 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수리터럴 표현식으로 해석될 가능성이 있다.

!@chapter12/functionLiteral.js@!

> 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

> 자바스크립트의 함수는 일급 객체다.

!@chapter12/functionHoisting.js@!

> 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

!@chapter12/functionConstructorFunction.js@!

### 5. 함수 호출

매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다.

!@chapter12/argumentProperty.js@!

> 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 만약 그 이상의 매개변수가필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

> 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 객체의 방어적 복사(defensive copy)를 통해 원본 객체를 완전히 복제, 즉 깊은 복사(deep copy)를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.

### 7. 다양한 함수의 형태

즉시 실행 함수(IFE, Immediately Invoked Function Expression)

> 일반적으로 중첩 함수는 외부 함수를 돕는 헬퍼 함수(helper function) 역할을 한다 .

> 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(higher-order function, HOF) 라고 한다.

> 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는부수 효과를 최소화해서불변성 immutability 을 지향하는 프로그래밍 패러다임이다 . 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡 성을 해결하며, 변수 사용을억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 해서 가독성을 해치고, 변수의 값은 누군 가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.

## 13. 스코프

### 1. 스코프란?

> 스코프는 식별자가 유효한 범위, 혹은 식별자를 검색할 때 사용하는 규칙을 말한다.

191p. 하나의 값은 유일한 식별자에 연결되어야 한다? pass by reference는 예외인건가? 여기서 값은 객체타입은 제외한건가.

var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.

### 2. 스코프의 종류

> 지역이란 함수 몸체 내부를 말한다.

### 3. 스코프 체인

함수 몸체 내부에서 정의한 함수를 **중첩 함수(nested function)**, 중첩 함수를 포함하는 함수를 **외부함수(outer function)**라고 한다.

스코프가 계층적으로 연결된 것을 **스코프 체인(scope chain)**이라 한다.

자바스크립트 엔진은 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.

> 사실 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를 바 없다. 따라서 스코프를 ‘변수를 검색할 때 사용하는 규칙’이라고 표현하기보다는 ‘식별자를검색하는 규칙’이라고 표현하는 편이 좀 더적합하다.

### 4. 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.

블록 레벨 스코프(C, Java …) / 함수 레벨 스코프(JS var)

### 5. 렉시컬 스코프

!@chapter13/lexicalScope.js@!

- 동적 스코프(dnamic scope): 함수가 호출되는 시점에 동적으로 상위 스코프를 결정한다.
- 렉시컬 스코프(lexical scope/static scope): 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.

자바스크립트와 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

함수 정의가 실행되어 생성된 함수 객체는 결정된 상위 스코프를 기억한다. 렉시컬 스코프는 클로저와 깊은관계가 있다.

## 14. 전역 변수의 문제점

### 1. 변수의 생명 주기

변수는 생명 주기(life cycle)가 있다.

전역 변수의 생명 주기는 응용 프로그램의 생명 주기와 같다. 지역 변수의 생명 주기는 함수의 생명 주기와같다.

!@chapter13/varLifeCycle.js@!

전역변수는 호이스팅으로 인해 런타임 이전 단계에 선언문이 실행되지만, 함수 내부의변수는 함수가 호출된직후와 함수 몸체의 코드가 실행되기 이전 자바스크립트 엔진에의해 선언문이 실행된다. 호이스팅은 스코프를 단위로 동작한다.

변수는 자신이 등록된 스코프가 소멸(메모리 해제)될 때까지 유효하다. ... **누군가스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.**

### 2. 전역 변수의 문제점

전역 변수는 스코프 체인의 종점의 존재하여 미미하지만 검색 속도가 가장 느리다.

자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다는 것인데, 다른 파일에 같은 이름으로 명명된 전역 변수가 있다면 예상치 못한 결과가 발생할 수 있다.

### 3. 전역 변수의 사용을 억제하는 방법

즉시 실행 함수, 네임스페이스 객체, 모듈 패턴

모듈 패턴은 클로저를 기반으로 동작하며, 전역 네임스페이스의 오염을 막는 동시에정보 은닉을 구현하기위해 사용된다.

!@chapter13/modulePattern.js@!

ES6 모듈을 파일 자체의 독자적인 모듈 스코프를 제공한다.

## 15. let, const 키워드와 블록 레벨 스코프

### 1. var 키워드로 선언한 변수의 문제점

var는 변수 중복 선언 허용, 함수 레벨 스코프, 변수 호이스팅이 발생한다는 단점을지닌다.

### 2. let 키워드

let 키워드로 선언한 변수는 선언 단계가 런타임 이전에 실행되지만, 초기화 단계는변수 선언문에 도달했을때 실행된다.

스코프의 시작 지점부터 초기화 단계 시작 지점까지의 구간을 일시적 사각지대 (Temporal Dead Zone; TDZ) 라고 부른다.

!@chapter15/letHoisting.js@!

let도 변수 호이스팅이 발생하기에 전역 변수에 접근하지는 않는다. 자바스크립트는모든 선언을 호이스팅한다.

!@chapter15/globalObject.js@!

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

### 3. const 키워드

반드시 선언과 동시에 초기화해야 한다.

보통 대문자와 언더스코어를 사용해 표현한다.

const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.

> Angular, React, Vue.js와 같은 SPA 프레임워크에서는 상태가 변경되었음을 명확히하기 위해 변경된 객체를 재할당하는 경우도 있다.

## 16. 프로퍼티 어트리뷰트

### 1. 내부 슬롯과 내부 메서드

internal slot/method

자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 psudo property/method. 이름이 이중 대괄호로 감싸져있다.

엔진 내부 로직이므로 원칙적으로 접근이 불가하지만, 일부에 한해 접근 수단을 제공하기는 한다.

!@chapter16/internalSlot.js@!

### 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 **프로퍼티어트리뷰트**를 기본값으로 자동 정의한다.

!@chapter16/propertyAttribute.js@!

### 3. 데이터 프로퍼티와 접근자 프로퍼티

프로퍼티는 두가지로 구분할 수 있다.

- data property: 키와 값으로 구성된 일반적인 프로퍼티
- accessor property: 자체 값이 없고 접근자 함수(accessor function)으로 구성된 프로퍼티

!@chapter16/dataProperty.js@!

[[Value]]: 프로퍼티 값 [[Writable]]: 값 변경 가능 여부 [[Enumerable]]: 열거 가능여부 [[Configurable]]: false이면 프로퍼티 삭제 및 어트리뷰트 값 변경 불가, 단 [[Writable]]이 true면 value 의 변경과 [[Writable]]을 false로 변경하는 것이 가능.

아래 세개의 기본값은 true이다.

접근자 프로퍼티는 [[Get]], [[Set]], [[Enumerable]], [[Configurable]]을 가지며 getter/setter는 둘 중하나만 가질 수도 있다.

!@chapter16/accessorProperty.js@!

### 4. 프로퍼티 정의

!@chapter16/defineProperty.js@!

### 5. 객체 변경 방지

프로퍼티 추가, 삭제, 읽기, 쓰기, 어트리뷰트 재정의 중 Object.preventExtensions는추가 외 허용, .seal 은 읽기 쓰기 외 비허용, .freeze는 읽기만 허용한다.

이들은 얕은 변경 방지(shallow only)로 직속 프로퍼티만 변경이 방지된다.

## 17. 생성자 함수에 의한 객체 생성

### 1. Object 생성자 함수

> 생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다.

> 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라고 한다.

!@chapter17/constructor.js@!

### 2. 생성자 함수

생성자 함수를 사용하면 객체 리터럴을 사용한 방법과 달리 프로퍼티 구조가 동일한객체 여러 개를 간편하게 생성할 수 있다.

!@chapter17/constructorGood.js@!

new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.

!@chapter17/constructorWithoutNew.js@!

인스턴스 생성, this에 이를 바인딩 -> 생성자 함수 내의 코드로 인스턴스 초기화 -> this 암묵적 반환

함수는 객체이지만 일반 객체와 다르게 호출할 수 있다.

함수가 일반 함수로 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고, 생성자함수로 호출되면 [[Construct]]가 호출된다.

- constructor: 함수 선언문/표현식, 클래스
- non-constructor: ES6 메서드 축약 표현, 화살표 함수

!@chapter17/es6Method.js@!

생성자 함수는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다. 그럼에도 실수의 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.

!@chapter17/newTarget.js@!

대부분의 빌트인 생성자 함수는 new 연산자 유무에 상관없이 적절한 값을 반환하지만, String, Number, Boolean은 new가 있으면 객체, 없으면 값을 반환한다.

## 18. 함수와 일급 객체

### 1. 일급 객체

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

[Why are functions not considered first class citizens in c?](https://stackoverflow.com/questions/48092176/why-are-functions-not-considered-first-class-citizens-in-c?answertab=trending#tab-top)

### 2. 함수 객체의 프로퍼티

!@chapter18/functionProperty.js@!

**proto** 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다.

prototype 프로퍼티는 constructor만 소유하는 프로퍼티이다. 생성자 함수로 함수가호출될 때 생성되는 인스턴스의 프로토타입 객체를 가리킨다.

## 19. 프로토타입

### 1. 객체지향 프로그래밍

> 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 한다.

> 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

### 2. 상속과 프로토타입

!@chapter19/methodShare.js@!

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다.

### 3. 프로토타입 객체

모든 객체는 하나의 프로토타입을 갖고, 모든 프로토타입은 생성자 함수와 연결되어있다.

!@chapter19/prototypeLink.js@!

**proto** 접근자 프로퍼티는 객체가 직접 소유하지 않고 Object.prototype의 프로퍼티를 상속을 통해 사용된다.

!@chapter19/cyclicProto.js@!

**proto** 대신 getPrototypeOf와 setPrototypeOf가 권장된다. 왜??

### 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

프로토타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를생성한 생성자 함수로 생각해도 크게 무리는 없다.

이 부분은 추후 다시 읽어보기.

> 추상 연산(abstract operation)은 ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다.

### 5. 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되며, 이때 프로토타입도 더불어 생성된다. 이 프로토타입의 프로토타입은 언제나 Object.prototype이다 .

모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.

### 6. 객체 생성 방식과 프로토타입의 결정

객체는 어떤 방식으로 생성되든지 OrdinaryObjectCreate 추상 연산에 의해 생성된다는공통점이 있다. 이 추상 연산에 결정되는 인수에 따라 생성되는 객체의 프로토타입이결정된다.

!@chapter19/constructorPrototypeQ.js@!

### 7. 프로토타입 체인

> 자바스크립트는 해당 객체에 찾고자하는 프로퍼티가 없다면 [[Prototype]] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 하며, 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.

모든 객체는 Object.prototype을 상속받으며 이는 프로토타입 체인의 종점이다.

프로토타입 체인은 상속과 프로퍼티 검색을 위한, 스코프 체인은 식별자 검색을 위한매커니즘이다.

### 8. 오버라이딩과 프로퍼티 섀도잉

> 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉이라 한다.

> 오버라이딩이란 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.

하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다.

### 9. 프로토타입의 교체

객체 간의 상속 관계를 동적으로 변경할 수 있다.

프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.

프로토타입은 직접 교체하지 않는 것이 좋다.

상속 관계를 인위적으로 설정하려면 번거로운 프로토타입 교체보다 직접 상속이나 클래스를 사용하는 편이좋다.

### 10. instanceof 연산자

좌변에 객체, 우변에 생성자 함수

생성자 함수의 prototype 프로퍼티가 객체의 프로토타입 체인에 존재하는지 확인한다.

instanceof 연산자는 constructor 프로퍼티가 아닌 생성자 함수의 prototype에 바인딩된 객체가 체인에 존재하는지 확인한다.

!@chapter19/instanceof.js@!

### 11. 직접 상속

new 연산자가 필요 없고, 프로토타입을 지정하며 객체를 생성할 수 있으며, 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.

프로토타입 체인의 종점에 위치한 객체를 생성할 수 있으므로, Object.prototype의 빌트인 메서드를 직접호출하는 것은 권장하지 않는다. call 등의 메서드로 간접 호출을권함.

!@chapter19/directInheritance.js@!

ES6에서는 객체 리터럴 내부에서 **proto** 접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다.

```js
obj = {
  name: 'YeolYi',
  __proto__: myProto,
};
```

### 12. 정적 프로퍼티/메서드

> 생성자 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다.

prototype을 #으로 표기하는 경우도 있으니 알아두자. Object#isPrototypeOf.

### 13. 프로퍼티 존재 확인

!@chapter19/propertyExistence.js@!

### 14. 프로퍼티 열거

!@chapter19/propertyEnumerate.js@!

## 20. strict mode

린트 도구는 strict mode가 제한하는 오류는 물론 코딩 컨벤션을 설정 파일 형태로 저으이하고 강제할 수있기 때문에 더욱 강력한 효과를 얻을 수 있다.

전역과 함수단위로 strict mode를 적용하는 것은 피하고, 즉시 실행함수로 스코프를구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.

암묵적 전역, 변수/함수/매개변수의 삭제, 매개변수의 중복, with문의 사용에 대해 에러가 발생한다.

[with 명령에 대하여](https://unikys.tistory.com/304)

일반함수에서 this에 undefined가 바인딩되며, 매개변수에 전달된 인수를 재할당해도 arguments 객체에 반영되지 않는다.

!@chapter20/argumentBinding.js@!

## 21. 빌트인 객체

### 1. 자바스크립트 객체의 분류

ECMAScript 사양에 정의된 표준 빌트인 객체(standard built-in objects, natice objects, global objects), 자바스크립트 실행 환경에 따라 추가로 제공하는 호스트객체, 사용자 정의 객체가 있다.

### 2. 표준 빌트인 객체

Math, Reflect, JSON을 제외하고 모두 생성자 함수 객체이다.

### 3. 원시값과 래퍼 객체

> 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다.

래퍼 객체의 처리가 종료되면 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지컬렉션의 대상이 된다 .

!@chapter21/wrapperObject.js@!

### 4. 전역 객체

> 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.

표준 빌트인 객체, 호스트 객체, 전역 변수/함수를 프로퍼티로 가진다.

let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.

Infinity, NaN, undefined는 빌트인 전역 프로퍼티다.

!@chapter21/builtinGlobalFunction.js@!

> URI(Uniform Resource Identifier)는 인터넷에 있는 자원을 나타내는 유일한 주소로 , 하위개념으로 URL, URN이 있다.

인코딩이한 URI의 문자들을 이스케이프 처리(아스키 문자 셋으로 변환)하는 것이다.

!@chapter21/uri.js@!

암묵적 전역 현상에서는 변수가 아닌 프로퍼티가 생성되고, 따라서 변수 호이스팅이발생하지 않고 delete 연산자로 삭제할 수 있다.

## 22. this

### 1. this 키워드

> this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 (self-referencing variable)이다.

this는 일반함수에서 전역 객체, 메서드에서 메서드를 호출한 객체, 생성자 함수 내부에서는 생성될 인스턴스를 가리킨다.

### 2. 함수 호출 방식과 this 바인딩

렉시컬 스코프는 평가 시점, this 바인딩은 호출 시점에 결정된다. 동일한 함수도 다양하게 호출하여 다른 this가 바인딩될 수 있다.

어떠한 함수(중첩 함수, 콜백 함수..)라도 일반 함수로 호출되면 this 객체에 전역 객체가 바인딩된다.

이는 중첩 함수가 헬퍼함수로서 동작하기 힘들게하므로 this 바인딩을 특정 변수에 할당하여 헬퍼 함수에서사용하거나, apply/call/binding 메서드를 사용하거나, 화살표함수를 사용할 수 있다.

메서드 내의 this도 호출한 함수에 따라 달라진다.

!@chapter22/methodThis.js@!

apply/call/binding 메서드는 Function.prototype의 메서드다.

!@chapter22/applyCallBinding.js@!

## 23. 실행 컨텍스트

### 1. 소스코드의 타입

각 타입은 실행 컨텍스트를 생성한다. 타입에 따라 실행 컨텍스트의 생성 과정과 관리내용이 다르다.

전역 코드: 최상위 스코프인 전역 스코프 생성. var, 전역에 선언된 함수 선언문함수코드: 지역 스코프 생성, 스코프 체인에 연결. 지역변수, 매개변수, argument 객체모듈 코드: 모듈별로 독립적인 모듈 스코프

### 2. 소스코드의 평가와 실행

소스코드 평가 과정에서 컨텍스트를 생성하고 선언문들을 실행하여 식별자를 실행 컨텍스트가 관리하는 스코프에 등록한다.

이후 실행, 런타임이 시작되어 필요한 값을 스코프에서 얻어오고 실행 결과를 스코프에 등록하는 과정.

### 3. 실행 컨텍스트의 역할

전역 코드 평가 -> 전역 코드 평가 -> 함수 코드 평가 -> 함수 코드 실행

코드가 실행되려면 스코프, 식별자, 코드 실행 순서의 관리가 필요하다.

1. 선언에 의해 생성된 식별자를 스코프를 구분해 등록하고 상태 변화를 관리해야한다 .
2. 스코프는 중첩 관계에 의한 스코프 체인을 형성해야한다.
3. 현재 실행중인 코드의 실행 순서를 변경할 수 있어야 한다?

> 실행 컨텍스트는 소스코드를 실행하는데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

이거는 JS가 인터프리터 언어이기 때문인가? 컴파일하는 언어는 이 작업을 컴파일 중에 하는건가?

렉시컬 환경과 실행 컨텍스트 스택으로 구성?된다.

### 4. 실행 컨텍스트 스택

혹은 콜 스택. 코드 실행 순서를 관리한다.

전역 코드가 평가되고, 함수 코드가 평가되면 실행 컨텍스트가 생기는데 이들을 스택형태로 관리한다. C에서의 스택/힙에서 스택과 유사한듯.

최상단의 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라 한다.

### 5. 렉시컬 환경

Lexical environment. 식별자와 그에 바인딩 된 값(환경 레코드, environment record), 상위 스코프에 대한참조(외부 렉시컬 환경에 대한 참조, outer lexical environment reference)를 기록하는 자료구조. 렉시컬스코프의 실체. LexicalEnvironment와 VariableEnvironment로 구성되지만 대부분 비슷하다.

환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다. 외부 렉시컬 어쩌구를 통해 스코프체인을 구현한다.

### 6. 실행 컨텍스트의 생성과 식별자 검색 과정

**전역 객체 생성**

- 전역 코드 평가 이전에 생성
- 전역 객체도 Object.prototype을 상속받는다.

**전역 코드 평가**

- 전역 실행 컨텍스트 생성, 스택에 push
- 전역 렉시컬 환경 생성, 위의 컨텍스트에 바인딩
- 전역 환경 레코드 생성. var 및 나머지는 객체 환경 레코드(Object Environment Record), let/const는 선언적 환경 레코드(Declarative Environment Record)에서 관리.
- 객체 환경 레코드 생성. 객체 환경 레코드는 BindingObject라는 객체와 연결, 이는전역 객체 생성에서 생성된 전역 객체. var와 전역 변수, 함수 선언문은 BindingObject를 통해 연결된 전역 객체의 프로퍼티와메서드가 된다.
- 선언적 환경 레코드 생성. 이곳의 변수들은 일시적 사각지대(Temporal Dead Zone, TDZ)에 빠진다.
- this 바인딩. 전역 환경 레코드의 [[GlobalThisValue]]에 this(보통 전역객체)가 바인딩된다.
- 외부 렉시컬 환경에 대한 참조 결정: 전역이므로 전역 렉시컬 환경의 OuterLexicalEnvironmentReference 에 null이 할당.

let은 블록 레벨 스코프인데, 블록에 들어가면 새로운 컨텍스트가 생기는건가? -> 챕터 7 참조

**전역 코드 실행** pass

**함수 코드 평가**

- 힘수 실행 컨텍스트 생성: 스택에 push
- 함수 렉시컬 환경 생성
  - 함수 환경 레코드 생성: 매개변수, arguments 객체, 지역 변수, 중첩 함수 등록및관리
  - this 바인딩: 함수 호출 방식에 따라 this 결정.
  - 외부 렉시컬 환경에 대한 참조 결정: 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 [[Environment]]에 할당한다. 이는 클로저와 연관된다.

**함수 코드 실행** 이후 실행이 완료된 함수의 컨텍스트를 pop. 다만 컨텍스트가 소멸되었더라도 그에 바인딩된 렉시컬 환경을 누군가 참조한다면 이는 소멸하지 않는다.

### 7. 실행 컨텍스트와 블록 레벨 스코프

코드 블록에 들어가면 새로운 선언적 환경 레코드를 가진 렉시컬 환경을 만들어 기존것을 대체. 대신 새로운 환경 내 외부 렉시컬 환경에 대한 참조는 기존 것을 가리킨다 .

변수 선언문에 let을 사용한 for문은 코드 블록이 실행될 때마다 새로운 렉시컬 환경을 생성한다?? 이에 대해서는 클로저에서 자세히...

## 24. 클로저

> A closure is the combination of a function and the lexical environment within which that function was declared.

### 1. 렉시컬 스코프

> 렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값, 즉 상위 스코프에대한 참조는 함수 사용 시점이 아닌 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬스코프다.

### 2. 함수 객체의 내부 슬롯 [[Environment]]

함수가 호출되었을 때 생성될 '외부 렉시컬 환경에 대한 참조'에 저장될 참조값과 같다. 함수는 여기에 저장되는 상위 스코프를 자신이 존재하는 한 기억한다.

!@chapter24/environment.js@!

### 3. 클로저와 렉시컬 환경

> 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저(closure)라고부른다.

자바스크립트의 모든 함수가 상위 스코프를 기억하므로 이론적으로는 모든 함수가 클로저이지만, 상위 스코프의 어떠한 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않기 때문에 클로저라고 부르기 어렵다 . 일부만 참조하는 경우에도 다른 식별자는 기억하지 않는다.

또한 상위 함수보다 수명이 짧아도 클로저라 부르기 어렵다.

debugger 구문 입력하고 브라우저에서 실행하면 스코프 정보를 볼 수 있다.

> 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수(free variable)라고 부른다.

### 4. 클로저의 활용

상태를 은닉하고 특성 함수에게만 변경을 허용하기 위해 사용한다.

!@chapter24/informationHiding.js@!

한 함수에서 여러 스코프에 접근한다면 [[Environment]]의 참조는?

함수를 호출할 때마다 새로운 렉시컬 환경이 생김을 기억하자.

### 5. 캡슐화와 정보 은닉

자바스크립트는 접근 제한자를 제공하지 않는다. [최신 버전에는 있기는 한듯?](https://stackoverflow.com/questions/38243329/classes-access-modifiers-in-javascript) -> private 필드에 대해서는 25.7.4에서.

[이런](https://medium.com/@weberino/you-can-create-truly-private-properties-in-js-without-es6-7d770f55fbc3) 방법도 있다.

### 6. 자주 발생하는 실수

!chapter24/@commonMistake.js@!

## 25. 클래스

### 1. 클래스는 프로토타입의 문법적 설탕인가?

클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

- 클래스를 new 연산자 없이 호출하면 에러가 발생한다.
- 클래스는 extends와 super 키워드를 제공한다.
- 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
- 클래스 내의 모든 코드에는 strict mode가 암묵적으로 적용된다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 [[Enumerable]]이 false 이다.

클래스는 새로운 객체 생성 매커니즘이다.

### 2. 클래스 정의

클래스는 함수며 일급 객체이다.

### 3. 클래스 호이스팅

클래스 선언문으로 정의한 클래스는 런타임 이전에 평가되지만 클래스 정의 이전에 참조할 수 없다.

!@chapter25/classHoisting.js@!

### 5. 메서드

constructor는 메서드로 해석되지 않고 클래스가 평가되어 생성된 함수 객체 코드의일부가 된다. 이에 클래스가 평가된 함수 객체를 봐도 constructor 메서드가 따로 있지않다.

constructor는 0개 혹은 1개 존재해야한다. constructor 내에서는 인스턴스의 생성과프로퍼티 추가를 통한인스턴스 초기화를 실행한다.

메서드에 static 키워드를 붙이면 정적 메서드가 된다.

프로토타입 메서드에서 this는 인스턴스, 정적 메서드의 this는 클래스를 가리킨다.

정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지않고 메서드로 구조화할 때 유용하다.

- function 키워드를 생략한 축약 표현
- 콤마 필요 없음
- 암묵적 strict mode
- 열거 불가
- non-constructor

### 6. 클래스의 인스턴스 생성 과정

constructor 에서의 this는 내부 코드가 실행될 시점에 이미 클래스의 prototype 프로퍼티가 가리키는 객체가 프로토타입으로 설정되어있다.

### 7. 프로퍼티

!@chapter25/getOwnPropertyName.js@!

인스턴스 프로퍼티를 자바처럼 정의할 수 있는 Class field declarations가 최신 브라우저에 구현되어 있다 . 메소드도 이를 통해 정의할 수 있지만 프로토타입 메서드가 아닌 인스턴스 메서드가 되므로 권장하지 않는다.

[선언, 정의, 초기화](https://salkuma.wordpress.com/2014/02/05/선언-정의-초기화-기본생성자-그리고-시그너처/)

!@chapter25/accessModifier.js@!

static을 사용한 정적 필드도 최신 브라우저에 구현되어 있다.

### 8. 상속에 의한 클래스 확장

프로토타입 기반은 다른 객체의 자산을 상속받는 개념이지만 상속에 의한 클래스 확장은 새로운 클래스를확장하여 정의하는 것이다.

인스턴스끼리뿐만 아니라 수퍼클래스와 서브클래스는 둘 간 프로토타입 체인도 생성한다.

동적 상속이 가능하다.

서브클래스에 constructor를 생략하면 다음과 같은 constructor가 암묵적으로 정의된다.

```js
constructor(...args) { super(...args); }
```

super를 호출하면 수퍼클래스의 constructor를 호출한다.

- 서브클래스에서 constructor를 생략하지 않았다면 그 constructor에서는 super를 반드시 호출해야한다.
- super 호출 전에는 this를 참조할 수 없다. this를 super에서 만들기 때문이다.
- super는 서브클래스의 constructor 내부에서만 호출할 수 있다.

super를 참조해 수퍼클래스의 메서드를 호출할 수 있다. super는 자신을 참조하는 메서드가 바인딩된 객체의 프로토타입을 가리킨다.

!@chapter25/superMethod.js@!

super를 위해 메서드는 내부 슬롯 [[HomeObject]]를 가지며 의사 코드는 다음과 같다. 이 슬롯은 ES6 메서드 축약 표현으로 정의된 함수만 지닌다. 이 슬롯을 가져야 super 를 참조할 수 있다.

[[HomeObject]]는 메서드가 바인딩 된 객체를 가리킨다.

```js
super = Object.getPrototypeOf([[HomeObject]])
```

[[ConstructorKind]]의 base/derived 구분을 통해 new 연산자로 호출되었을 때 동작을구분한다. 서브클래스는 수퍼클래스에게 인스턴스 생성을 위임한다. 이때 수퍼클래스의 constructor의 this의 프로토타입은 서브클래스의 prototype 프로퍼티이다.

!@chapter25/mySpecies.js@!

## 26. ES6 함수의 추가 기능

### 1. 함수의 구분

객체에 바인딩된 함수(콜백 함수도 마찬가지)가 생성자 함수로 호출할 수 있다는 것은해당 함수가 prototype 프로퍼티를 가지며 프로토타입 객체도 생성한다는 것이므로 성능상의 문제또한 있다.

ES6 이전의 함수는 명확한 구분이 없었는데, ES6에서부터 함수를 사용 목적에 따라 분류한다.

- Normal: constructor/prototype/arguments
- Method: super/arguments
- Arrow: -

세 가지 이외에도 제너레이터 함수와 async 함수가 있으며 46장에서 살펴본다.

### 2. 메서드

> ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

[[HomeObject]]를 가지기에 super 키워드를 사용할 수 있다.

### 3. 화살표 함수

화살표 함수는 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.

객체 리터럴을 반환하는 경우 리터럴을 소괄호로 감싸주어야한다. 아니면 객체 리터럴의 중괄호가 함수 몸체를 감싸는 중괄호로 잘못 해석된다.

화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않으며 스코프 체인 상에서가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 것들을참조한다.

> 화살표 함수는 자체의 this가 없기에 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.

ES6이전에는 this를 스코프 체인을 따라 탐색할 이유가 없었지만, 화살표 함수 이후탐색이 필요해졌다.

!@chapter26/lexicalThis.js@!

이처럼 메서드(ES6이 아닌 일반적인 의미)를 화살표 함수로 정의하는 것은 피해야 한다.

스코프에 대해서는 다시 공부해봐야할 듯^^; class도 결국엔 함수라는 것을 체화시켜야 할 듯. 486페이지다시 읽어보기. [실행 컨텍스트와 자바스크립트의 동작 원리](https://poiemaweb.com/js-execution-context)

### 4. Rest 파라미터

화살표 함수는 자신의 argument 객체를 가지지 않고, 접근한다해도 자신과 상관없는상위 함수에 전달된 인수 목록을 알게 되므로 쓸모가 없다. 화살표 함수로 가변 인자함수를 구현하기 위해서는 반드시 Rest 파라미터를 사용해야 한다.

> Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

함수의 length 프로퍼티에 영향을 주지 않는다.

유사 배열 객체인 arguments를 사용하는 번거로움을 피할 수 있다.

## 27. 배열

### 1. 배열이란?

!@chapter27/arrayBasic.js@!

배열은 일반 객체와 달리 값의 순서가 존재한다.

### 2. 자바스크립트 배열은 배열이 아니다.

> 자료구조에서 말하는 배열, 즉 밀집 배열(dense array)은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조이다.

> 자바스크립트의 배열은 배열의 구조가 연속적으로 이어져있지 않은 희소 배열 (sparse array)이다.?

자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다. 해시 테이블로 구현되어 인덱스 접근은 느리지만 요소의 삽입과 삭제는 빠르다.

!@chapter27/arrayPerformance.js@!

### 3. length 프로퍼티와 희소 배열

length 프로퍼티에 그 값보다 작은 값을 할당하면 배열의 길이가 줄어든다.

!@chapter27/sparseArray.js@!

그보다 큰 값을 할당하면 변화가 없다. 자바스크립트는 배열의 요소가 일부가 비어있는 희소 배열을 허용한다.

최적화 측면에서 희소 배열은 사용하지 않는 것이 좋다.

### 4. 배열 생성

!@chapter27/arrayConstruct.js@!

### 6. 배열 요소의 추가와 갱신

현재 배열의 length 값보다 큰 인덱스로 요소(element)를 추가하면 희소 배열이 된다.

0 이상의 정수를 사용하지 않으면 프로퍼티가 생성되고 lenght 값에 영향을 주지 않는다.

### 7. 배열 요소의 삭제

delete로 프로퍼티를 삭제할 수 있지만 희소 배열이 되므로 추천하지 않는다.

### 8. 배열 메서드

mutator method(원본 변경)와 accessor method(새로운 객체 반환)로 구분된다. 부수효과 방지를 위해 후자가 권장된다.

!@chapter27/arrayMethods.js@!

slice, 스프레드 문법, Object.assign 메서드는 모두 얕은 복사를 수행한다. 깊은 복사를 위해서는 [참고](https://lodash.com/docs/4.17.15#cloneDeep)

### 9. 배열 고차 함수

고차 함수(Highter-Order Function, HOF)

고차 함수는 외부 상태의 변경이나 가변(mutable) 데이터를 피하고 불변성 (immutability)을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

> 함수형 프로그래밍은 순수 함수(pure function)와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

!@chapter27/hof.js@!

> 최신 사양의 기능을 지원하지 않는 브라우저를 위해 누락된 최신 사양의 기능을 구현하여 추가하는 것을폴리필(polyfill)이라 한다.

## 28. Number

MAX_SAFE_INTEGER: 자바스크립트는 Number에서 부동소수점을 사용하기 때문. [참고](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)

## 31. RegExp

### 1. 정규 표현식이란?

> 정규표현식은(regular expression)은 일정한 패턴을 가진 문자열의 집합을 표현하기위해 사용하는 형식언어(formal language)다.

### 2. 정규 표현식의 생성

!@chapter31/regexConstruct.js@!

Regex 생성자 함수로 동적인 Regex 객체를 만들 수 있다.

### 3. Regex 메서드

!@chapter31/regexMethod.js@!

### 4. 플래그

i: ignore case g: global m: multiline

### 5. 패턴

여기 이후는 저 자세히 설명되어있는 EloquentJavascript에서 다시 읽어보기.

```txt
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```

[이메일 regex...](https://emailregex.com)

## 32. String

### 1. String 생성자 함수

new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 String 인스턴스가 아닌문자열을 반환한다.

### 2. length 프로퍼티

String은 length 프로퍼티를 갖기에 유사 배열 객체다.

### 3. String 메서드

String 래퍼 객체도 읽기 전용 객체로 제공된다.

!@chapter32/stringMethod.js@!

## 33. 7번째 데이터 타입 Symbol

### 2. 심벌 값의 생성

Symbol 함수는 new 연산자와 함께 호출하지 않는다. 심벌 값은 객체가 아닌 변경 불가능한 원시 값이다.

!@chapter33/symbolMethod.js@!

### 3. 심벌과 상수

!@chapter33/symbolConstant.js@!

### 7. Well-known Symbol

> 자바스크립트가 기본 제공하는 빌트인 심벌 값을 ECMAScript 사양에서는 Well-known Symbol이라 부른다.

Symbol.iterator 등등

이처럼 심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해도입되었다.

## 34. 이터러블

### 1. 이터레이션 프로토콜

> ES6에서 도입된 iteration protocol은 순회 가능한(iterable) 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

- 이터러블 프로토콜: 이터레이터를 반환. for...of, 스프레드 문법, 배열 디스트럭처링 할당.
- 이터레이터 프로토콜: next 메서드 소유, iterator result object를 반환.

스프레드 프로퍼티 제안은 일반 객체에 스프레드 문법의 사용을 허용한다.

!@chapter34/iterable.js@!

### 3. for...of문

!@chapter34/forOf.js@!

### 4. 이터러블과 유사 배열 객체

유사 배열 객체는 for...of로 순회할 수 없다. Array.from으로 배열로 변환할 수 있다 .

!@chapter34/brokenIterable.js@!

### 6. 사용자 정의 이터러블

이터러블이면서 이터레이터인 객체를 생성하는 함수

!@chapter34/iterableNIterator.js@!

무한 이터러블을 생성하는 함수를 통해 무한 수열을 구현할 수 있다.

> 지연 평가는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 필요한 시점이 되면 그때야 데이터를 생성하는 기법이다.

무한 이터러블을 통해 지연 평가를 사용한 데이터 생성이 가능하다.

## 35. 스프레드 문법

> ES6에서 도입된 스프레드 문법은 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로만든다.

스프레드 문법의 결과는 값이 아니고, 따라서 ... 은 연산자가 아니다. 쉼표로 구분한값의 목록을 사용하는문백에서만 사용할 수 있다.

Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.

!@chapter35/restSpread.js@!

!@chapter35/rest.js@!

## 36. 디스트럭처링 할당

> 디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

!@chapter36/destructuring.js@!

## 37. Set과 Map

### 1. Set

!@chapter37/set.js@!

### 2. Map

> Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다.

!@chapter37/map.js@!

Set과 Map 모두 요소의 순서에 의미를 갖지 않지만 다른 이터러블의 순회와 호환성을유지하기 위해 객체 순회 순서가 요소 추가 순서에 따른다.

## 38. 브라우저의 렌더링 과정

> 파싱(구문 분석, syntax analysis)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해(어휘 분석, lexical analysis)하고, 토큰에 문법적의미와 구조를 반영하여 트리 구조의 자료구조인 parse tree/syntax tree를 생성하는 일련의 과정을 말한다 . 일반적으로 파싱이완료된 이후에는 parse tree를 기반으로 중간언어(intermediate code)인 바이트 코드 (byte code)를 생성하고 실행한다.

> 렌더링(renderind)은 HTML, CSS, JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.

1. 렌더링에 필요한 리소스 요청, 서버로부터 응답
2. HTML -> DOM / CSS -> CSSOM. 둘을 결합하여 렌더 트리 생성
3. 서버로부터 온 JS를 파싱해 AST(Abstract Syntax Tree) 생성, 바이트코드로 변환해실행. JS를 통해 DOM/CSSOM을 변경할 수 있다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 화면에 페인팅

### 1. 요청과 응답

URI, URL, URN, Scheme(Protocol), Host(Domain), Port, Path, Query(Query String), Fragment...

브라우저의 렌더링 엔진은 HTML을 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 파싱을 일시중지하고 해당 리소스 파일을 서버로 요청한다.

### 2. HTTP 1.1과 HTTP 2.0

HTTP/1.1은 커넥션당 하나의 요청과 응답만 처리한다. 리소스들에 대한 요청들이 개별적으로 전송되고 응답또한 개별적으로 전송된다. 리소스의 개수에 비례해 응답 시간이 증가한다.

HTTP/2는 다중 요청/응답이 가능하다.

[Introduction to HTTP/2](https://web.dev/performance-http2/)

### 3. HTML 파싱과 DOM 생성

DOM(Document Object Model)

1. 서버로부터 응답된 HTML 문서는 meta 태그의 charset 어트리뷰트에 따라 문자열로변화된다. 이 정보는 content-type: text/html; charset=utf-8과 같이 응답 헤더 (response header)에 담겨 응답된다.
2. 문자열로 변환된 HTML 문서는 토큰들로 분해된다.
3. 각 토큰을 객체로 변환하여 노드(node)를 생성한다. 이 노드는 DOM을 구성하는 기본 요소가 된다.
4. 노드들을 트리 자료구조로 구성한 DOM을 생성한다.

### 4. CSS 파싱과 CSSOM 생성

HTML과 동일한 파싱 과정으로 CSSOM(CSS Object Model)을 생성한다. CSSOM은 CSS의 상속을 반영하여 생성된다.

### 5. 렌더 트리 생성

DOM과 CSSOM은 렌더 트리(render tree)로 결합된다. 화면에 렌더링되지 않는 노드와 CSS에 의해 숨겨지는노드들은 포함되지 않는다. 렌더 트리는 HTML 요소의 레이아웃계산에 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅(painting) 처리에 입력된다 .

Render tree -> Layout -> Paint. 리렌더링이 빈번하지 않도록 주의해야한다.

### 6. 자바스크립트 파싱과 실행

DOM API를 통해 이미 생성된 얘ㅡ을 동적으로 조작할 수 있다.

렌더링 엔진은 HTML을 파싱하다 JS 파일을 만나면 DOM 생성을 일시 중단하고 자바스크립트 엔진에 제어권을넘긴다. 엔진은 코드를 해석하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성하고, 인터프리터가실행 가능한 중간 코드(intermeditate code)인 바이트 코드를 생성해 실행한다.

- 토크나이징: 코드를 어휘 분석(lexical analysis)하여 문법적 의미를 가지는 최소단위인 토큰(token)들로분해한다.
- 파싱: 토큰들의 집합을 구문 분석(syntactic analysis)하여 AST를 생성한다. AST는토큰에 문법적 의미와구조를 반영한 트리 구조의 자료구조다. AST를 통해 TypeScript, Babel, Prettier같은 transpiler를 구현할 수도 있다.
- 바이트코드 생성과 실행: V8은 터보팬(TurboFan)이라는 컴파일러에 의해 최적화된머신 코드로 컴파일되어성능을 최적화한다. 코드의 사용 빈도가 적어지면 다시 디옵티마이징(deoptimizing)하기도 한다.

### 7. 리플로우와 리페인트

> 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우 (reflow), 리페인트(repaint)라 한다.

리플로우는 레이아웃 변경이 발생한 경우에 한해 실행되고, 리페인트는 렌더 트리를기반으로 다시 페인트를하는 것을 말한다.

### 8. 자바스크립트 파싱에 의한 HTML 파싱 중단

body 요소 가장 아래에 JS를 위치시키는 것은 좋은 아이디어다.

- DOM 미완성일 때 DOM을 조작하면 에러가 발생할 수 있다.
- JS 로딩/파싱/실행으로 인한 렌더링 지장이 없다.

### 9. script 태그의 async/defer 어트리뷰트

앞선 blocking 문제 때문에 HTML5부터 async와 defer 어트리뷰트가 추가되었다.

aync는 HTML 파싱과 JS 로드가 동시에 일어나고, JS 파싱과 실행이 로드 완료 직후 HTML 파싱을 중단시키고진행된다. 여러 async 끼리의 순서가 보장되지 않는다.

defer는 JS 파싱과 실행이 DOM 생성 직후에 진행된다.

## 39. DOM

> DOM(Document Object Model)은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉프로퍼티와 메서드를 제공하는 트리 자료구조다.

### 1. 노드

> HTML 요소는 HTML 문서를 구성하는 개별적인 요소를 의미한다. 시작 태그, 어트리뷰트 이름, 어트리뷰트값, 콘텐츠, 종료 태그로 구성된다.

HTML 요소는 파싱되어 요소 노드 객체로 변환된다. HTML 요소간에는 계층적인 부자 관계가 있기에 트리 자료구조로 구성된다.

노드 객체들로 구성된 트리 자료구조를 DOM이라 한다. 총 12종류가 있고 중요한 4종류는 아래와 같다.

- 문서 노드: 최상위 루트 노드. window.document. entry point 역할
- 요소 노드: HTML 요소. 부자 관계를 가짐.
- 어트리뷰트 노드: 부모 노드 없이 요소 노드와 연결되어 요소의 어트리뷰트 가리킴.
- 텍스트 노드: 텍스트, 문서의 정보를 표현. leaf node.

모든 노드 객체는 Object, EventTarget(이벤트를 발생시키는 객체), Node(트리 자료구조의 노드 객체) 인터페이스를 상속받는다.

프런트엔드 개발자에게 HTML은 단순히 태그와 어트리뷰트를 선언적으로 배치하여 뷰를구성하는 것 이상의의미를 갖는다. 즉, HTML을 DOM과 연관 지어 바라보아야 한다.

### 2. 요소 노드 취득

!@chapter39/getElementByID.html@!

**HTMLCollection**

- 객체의 상태 변화를 실시간으로 반영하는 live object이다.

**NodeList**

- 대부분 변화 반영 안하고 정적
- NodeList.prototype.forEach를 상속받아 사용할 수 있다.
- childNodes 프로퍼티가 반환하는 NodeList 객체는 live object이다.

!@chapter39/htmlCollectionTroll.html@!

노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection 이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장한다.

### 3. 노드 탐색

Node.prototype: parentNode, previousSibling, firstChild, childNodes Element.prototype: previousElementSibling, nextElementSibling

html 요소 사이의 white space는 텍스트 노드를 생성한다.

!@chapter39/nodeTraversing.html@!

### 4. 노드 정보 취득

!@chapter39/nodeType.html@!

### 5. 요소 노드의 텍스트 조작

!@chapter39/changeNode.html@!

innerText는 CSS에 순종적(visibility등에 영향)이고 느리므로 사용하지 않는 것이 좋다.

### 6. DOM 조작

!@chapter39/domManipulation.html@!

### 7. 어트리뷰트

HTML 요소가 파싱될 때 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결된다. 어트리뷰트당 하나의 노드가 생성된다.

!@chapter39/attribute.html@!

HTML 어트리뷰트는 1. 요소 노드의 attributes 프로퍼티 2. 각 어트리뷰트에 대응되는요소 노드의 프로퍼티 (이하 DOM 프로퍼티) 로 중복 관리되는 것 같지만 다르다.

요소 노드의 초기 상태(새로고침 등 상황에서 사용)는 어트리뷰트 노드가, 최신 상태는 DOM 프로퍼티가 관리한다.

사용자 입력과 관계있는 DOM 프로퍼티만 최신 상태 값을 관리하고, 그 이외에는 어트리뷰트와 DOM 프로퍼티가 동일한 값으로 연동된다.

!@chapter39/dataAttribute.html@!

### 8. 스타일

!@chapter39/style.html@!

### 9. DOM 표준

구글, 애플, 마이크로소프트, 모질라로 구성된 WHATWG가 HTML과 DOM 단일 표준을 내놓는다.

## 40. 이벤트

### 1. 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.

> 이벤트가 발생했을 때 호출될 함수를 event handler, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.

프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍(event-driven programming)이라 한다.

### 2. 이벤트 타입

책에서 보기!

### 3. 이벤트 핸들러 등록

!@chapter40/register.html@!

### 4. 이벤트 핸들러 제거

removeEventHandler에 add때와 같은 인수를 전달한다. 따라서 무명 함수를 전달했으면제거할 수 없다.

### 5. 이벤트 객체

이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.

이벤트 객체는 모두 Object, Event를 상속받는다.

!@chapter40/eventObject.html@!

이벤트 객체의 프로퍼티 관련은 나중에 사전처럼 읽어보기.

!@chapter40/moveBox.html@!

### 6. 이벤트 전파

이벤트 전파(event propagation)

생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃(event target)을 중심으로 DOM 트리를 통해 전파된다.

- 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
- 타깃 단계: 이벤트가 이벤트 타깃에 도달
- 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

!@chapter40/eventPropagation.html@!

### 7. 이벤트 위임

> 이벤트 위임(event delegation)은 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를등록하는 대신 하나의상위 DOM 요소에 이벤트 핸들러를 등록하는 방법을 말한다.

!@chapter40/eventPropagation.html@!

### 8. DOM 요소의 기본 동작 조작

이벤트 객체의 preventDefault 메서드는 요소 별 기본 동작을 중단시킨다.

stopPropagation 메서드는 이벤트 전파를 중지시킨다.

### 9. 이벤트 핸들러 내부의 this

이벤트 핸들로 프로퍼티 방식과 addEventListener 내부에서 this는 currentTarget과같다.

쓰지 말자,,,

### 10. 이벤트 핸들러에 인수 전달

pass

### 11. 커스텀 이벤트

pass

## 41. 타이머

### 1. 호출 스케줄링

> 함수를 명시적으로 호출하지 않고 일정 시간 이후에 함수 호출을 예약하려면 타이머함수를 사용한다. 이를 호출 스케줄링(scheduling a call)이라 한다.

타이머 함수는 호스트 객체다.

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖기에 싱글 스레드로 동작한다 . 이에 타이머 함수들은 비동기 처리 방식으로 동작한다.

### 2. 타이머 함수

setTimeout의 delay 매개변수는 그 시간 후 즉시 호출을 보장하지 않는다. 태스크 큐에 등록하는 시간일 뿐 .

!@chapter41/setTimeout.js@!

!@chapter41/setInterval.js@!

### 3. 디바운스와 스로틀

> 디바운스와 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서과도한 이벤트 핸들러의호출을 방지하는 프로그래밍 기법이다.

!@chapter41/debounceThrottle.html@!

디바운스는 resize 이벤트 처리, 입력 필드 자동완성 UI 구현, 버튼 중복 클릭 방지처리 등에 유용하게 사용된다. 위 예제는 완전하기 않으므로 Underscore나 Lodash의 debounce 함수를 사용한다.

스로틀은 scroll 이벤트 처리나 무한 스크롤 UI 구현에 사용된다. 마찬가리고 실무에서는 다른걸 사용한다.

## 42. 비동기 프로그래밍

### 1. 동기 처리와 비동기 처리

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 가지며 싱글 스레드 방식으로동작한다. 이에 처리에시간이 걸리는 태스크를 실행하면 블로킹(작업 중단)이 발생한다 .

> 현재 실행 중인 태스크가 종료할 떄까지 다음에 실행될 태스크가 대기하는 방식을동기(synchronous) 처리라고 한다.

> 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 (asynchronous) 처리라고 한다.

비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용하지만, 콜백 헬을 발생시켜 가독성을나쁘게 하고 비동기 처리 중 발생한 에러의 예외 처리가 곤란하다.

### 2. 이벤트 루프와 태스크 큐

> JS의 동시성(concurrency)을 지원하는 것이 이벤트 루프다.

비동기 처리에서 소스코드의 평가와 실행을 제외한 처리는 환경인 브라우저나 Node.js 에서 담당한다. 브라우저에서는 이를 위해 태스크 큐와 이벤트 루프를 제공한다.

- 태스크 큐: 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.
- 이벤트 루프: 콜 스택에 실행중인 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인. 함수가 있고 자리가 비었다면 FIFO로 태스크 큐에 대기중인 함수를 콜 스택으로 이동.

setTimeout 등에서 타이머의 설정과 타이머가 만료되면 콜백 함수를 태스크 큐에 퓨시하는 것은 브라우저의역할이다.

자바스크립트 엔진은 싱글 스레드지만 브라우저는 멀티 스레드이다.

## 43. Ajax

### 1. Ajax란?

> Ajax(Asynchronous Javascript and XML)란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. [참고](https://www.w3schools.com/xml/ajax_intro.asp)

WebAPI인 XMLHttpRequest 객체를 기반으로 동작한다.

전통적인 방식은 화면 전환마다 HTML를 다시 렌더링하는 방식이여서 깜빡이고 느렸지만, Ajax를 통해 비동기 방식으로 필요한 데이터만 전송받아 한정적인 렌더링이 가능해졌다.

### 2. JSON

!@chapter43/json.js@!

> 객체의 문자열화를 직렬화(serializing)라 한다. JSON 포맷의 문자열을 객체화하는것을 역직렬화 (deserializing)라 한다.

### 3. XMLHttpRequest

HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위) 을 알리는 방법이다. 5가지 요청 메서드를 사용하여 [CRUD](https://ko.wikipedia.org/wiki/CRUD)를 구현한다.

!@chapter43/request.html@!

## 44. REST API

> Rest는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.

### 1. REST API의 구성

- 자원(resource, URI로 표현)
- 행위(verb, HTTP 요청 메서드로 표현)
- 표현(representations, 자원에 대한 행위의 구체적 내용, 페이로드로 표현)

자체 표현 구조(self-descriptiveness)로 구성된다.

### 2. REST API 설계 원칙

URI는 리소스를 표현하는데 집중하고, 행위에 대한 정의는 HTTP 요청 메서드를 통해한다.

- GET: index/retrieve. 모든/특정 리소스 취득. 페이로드 없음
- POST: create. 리소스 생성. 페이로드 있음
- PUT: replace. 리소스의 전체 교체. 페이로드 있음. [멱등성](https://ko.wikipedia.org/wiki/%EB%A9%B1%EB%93%B1%EB%B2%95%EC%B9%99)
- PATCH: modify. 리소스의 일부 수정. 페이로드 있음
- Delete: delete. 모든/특정 리소스 삭제. 페이로드 없음

### 3. JSON Server를 이용한 REST API 실습

json-server-exam 폴더 참고.

db.json 파일은 리소스를 제공하는 데이터베이스 역할을 한다.

!@chapter44/json-server-exam/public/get_index.html@!

!@chapter44/json-server-exam/public/get_retrieve.html@!

!@chapter44/json-server-exam/public/post.html@!

!@chapter44/json-server-exam/public/put.html@!

!@chapter44/json-server-exam/public/patch.html@!

!@chapter44/json-server-exam/public/delete.html@!

## 45. 프로미스

### 1. 비동기 처리를 위한 콜백 패턴의 단점

!@chapter45/callback.html@!

비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로동작하지 않는다.

!@chapter45/callback.html@!

비동기 함수의 처리 결과에 대한 후속 처리는 콜백 함수를 전달하여 수행한다.

> 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상을 콜백 헬이라 한다.

에러는 호출자 방향으로 전파되지만 setTimeout 함수의 콜백 함수를 호출한 것은 setTimeout이 아니므로 catch 블록에서 캐치되지 않는다.

### 2. 프로미스의 생성

표준 빌트인 객체다.

생성자는 resolve와 reject를 인수로 전달받는 콜백 함수를 인수로 받는다.

프로미스의 상태 정보 [[PromiseStatus]]는 pending, fulfilled, rejected로 나뉘며뒤두개를 묶어 settled 상태라 한다. settled 상태에서는 다른 상태로 변화할 수 없다.

> 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.

### 3. 프로미스의 후속 처리 메서드

프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 모든 후속 처리 메서드는 프로미스를 반환하며 비동기로동작한다.

!@chapter45/thenCatchFinally.js@!

### 4. 프로미스의 에러 처리

then 메서드의 두번째 콜백 함수는 첫번째 콜백 함수에서의 에러를 채키하지 못하니 catch 메서드를 then 다음에 사용해서 해결하자.

### 5. 프로미스 체이닝

!@chapter45/promiseChaining.html@!

### 6. 프로미스의 정적 메서드

- Promise.resolve/reject는 이미 존재하는 값을 래핑하여 프로미스를 생성한다.
- Promise.all은 여러 비동기 처리를 병렬 처리할 때 사용한다. 전달받은 프로미스 배열의 요소들의 상태가모두 fulfilled가 되면 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다. 배열 순서는 유지?된다. 하나라도 reject되면 즉시 종료된다.
- Promise.race는 가장 먼저 fulfilled된 프로미스의 처리 결과를 resolve하는 새로운프로미스를 반환한다.
- Promise.allSettled는 프로미스가 모두 settled되면 결과를 빼열로 반환한다. fulfilled는 status, value 프로퍼티를, rejected는 status, reason 프로퍼티를 갖는다.

!@chapter45/promiseAll.html@!

### 7. 마이크로태스크 큐

!@chapter45/microtaskQueue.js@!

프로미스의 후속 처리 메서드의 콜백 함수는 마이크로태스크 큐에 저장된다. 마이크로태스크 큐는 태스크큐보다 우선순위가 높다.

### 8. fetch

fetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한콜백 패턴의 단점에서 자유롭다.

Response 객체를 래핑한 프로미스를 반환한다.

!@chapter45/fetch.js@!

## 46. 제너레이터와 async/await

### 1. 제너레이처란?

> ES6에서 도입된 제너레이터는 코드 블록의실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한함수다.

- 함수의 제어권을 함수 호출자에게 양도(yield)할 수 있다.
- 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다.
- 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.

### 2. 제너레이터 함수의 정의

function 키워드와 함수 이름 사이에 \*를 넣는다.

### 3. 제너레이터 객체

!@chapter46/generatorObj.js@!

### 4. 제너레이터의 일시 중지와 재게

제너레이터 객체의 next 메서드를 호출하면 yield 표현식까지 실행되고 일시 중지된다 .

제너레이터 함수가 끝까지 실행되면 반환된 객체의 value 프로퍼티에 함수의 반환값이할당된다.

!@chapter46/yield.js@!

### 5. 제너레이터의 활용

이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간단히 이터러블을 구현할 수 있다.

비동기 처리를 동기 처리처럼 구현할 수 있지만 aync/await를 사용하자.

!@chapter46/co.js@!

코드에 대해서는 책 설명 다시 읽어보기.

### 6. async/await

> ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 async/await가 도입되었다.

!@chapter46/asyncAwait.js@!

## 47. 에러 처리

### 1. 에러 처리의 필요성

발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다.

### 2. try...catch...finally 문

finally 코드 블록은 에러 발생과 상관없이 반드시 한 번 실행된다.

### 3. Error 객체

Error 생성자 함수에 에러 메시지를 전달할 수 있고, 생성된 객체는 message와 stack 프로퍼티를 가진다.

SyntaxError, ReferenceError, TypeError, RangeError, URIError, EvalError 가 있다.

### 4. throw 문

에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.

### 5. 에러의 전파

throw된 에러를 캐치하지 않으면 호출자 방향으로 전파된다. 비동기 함수인 setTimeout이나 프로미스 후속처리 메서드의 콜백 함수는 호출자가 없음을 주의한다.

## 48. 모듈

### 1. 모듈의 일반적 의미

> 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.

모듈은 공개가 필요한 자산에 한정하여 export를 통해 선택적 공개가 가능하다. 모듈사용자는 공개된 자산중 일부 또는 전체를 import를 통해 자신의 스코프 내로 불러들여 재사용할 수 있다.

### 2. 자바스크립트와 모듈

자바스크립트는 본래 하나의 전역을 공유해 모듈 구현이 없었으나, CommonJS와 AMD(Asynchronous Module Definition)가 제안되었다.

브라우저 환경에서 모듈을 사용하기 위해서는 이들을 구현한 모듈 로더 라이브러리를사용해야했다.

Node.js는 사실상 표준(de factor standard)인 CommonJS를 채택했고 독자적인 진화를거쳤다.

### 3. ES6 모듈

ES6에서 클라이언트 사이드 JS에서도 동작하는 모듈 기능을 추가했다. ES6 Module, ESM.

script 태그에 type="module"을 추가하면 로드된 JS 파일은 모듈로서 동작한다. ESM의확장자는 mjs로 명시하는 것이 좋다.

ES6는 독자적인 모듈 스코프를 갖는다. export 키워드와 import 키워드를 사용할 수있다.

require는 NodeJS에서 사용되고 있는 CommonJS 키워드이고, import는 ES6에서 도입된키워드이다.

## 49. Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축

### 1. Babel

> Babel은 ES6+/ES.NEXT로 구현된 최신 사양의 소수코드를 구형 브라우저에서도 동작하는 소스코드로 변환( 트랜스파일링)할 수 있다.

> @babel/preset-env는 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋이라고 부른다 .

### 2. Webpack

> Webpack은 의존 관계에 있는 JS, CSS, 이미지 등의 리소스들을 하나(또는 여러 개) 의 파일로 번들링하는모듈 번들러다.
