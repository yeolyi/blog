
> React is a JavaScript library for rendering user interfaces (UI).

### Your First Component

You can even jumpstart your project with the thousands of components shared by the React open source community like [Chakra UI](https://chakra-ui.com/) and [Material UI](https://material-ui.com/).

> a React component is a JavaScript function that you can sprinkle with markup.

React components are regular JavaScript functions, but their names must start with a capital letter or they wonâ€™t work!

ì†Œë¬¸ìë¡œ ì‹œì‘í•˜ë©´ HTML íƒœê·¸ë¡œ ê°„ì£¼ë˜ëŠ” ë“¯?

<img /> is written like HTML, but it is actually JavaScript under the hood!

returnê³¼ ë‹¤ë¥¸ ì¤„ì— ìˆìœ¼ë©´ ê´„í˜¸ë¥¼ ë°˜ë“œì‹œ ë¶™ì—¬ì•¼ í•œë‹¤.

[What are the rules for JavaScript's automatic semicolon insertion (ASI)?](https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)

... React-based frameworks take this a step further. Instead of using an empty HTML file and letting React â€œtake overâ€ managing the page with JavaScript, they also generate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.

```
export default function Gallery() {
    // ğŸ”´ Never define a component inside another component!
    function Profile() {

    }
    // The snippet above is very slow and causes bugs. Instead, define every component at the top level:
}
```

### Importing and Exporting Components

If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.

Either './Gallery.js' or './Gallery' will work with React, though the former is closer to how native ES Modules work.

A file can have no more than one default export, but it can have as many named exports as you like. ... People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values.

### Writing Markup with JSX

But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is why in React, **rendering logic and markup live together** in the same placeâ€”components.

JSX and React are two separate things. Theyâ€™re often used together, but you [can use them independently](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform) of each other. JSX is a syntax extension, while React is a JavaScript library.

React Fragment - JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You canâ€™t return two objects from a function without wrapping them into an array. This explains why you also canâ€™t return two JSX tags without wrapping them into another tag or a fragment.

JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects.

### Javascript in JSX with Curly Braces

The [Intl](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl) namespace object contains several constructors as well as functionality common to the internationalization constructors and other language sensitive functions.

Inline style properties are written in camelCase.

### Passing Props to a Component

ReactDOM conforms to [the HTML standard](https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element).

React components use props to communicate with each other.

> Props are the information that you pass to a JSX tag.

... in fact, props are the only argument to your component! React component functions accept a single argument, a props object:

```jsx
function Avatar(props) {
  let person = props.person;
  let size = props.size;
  // ...
}
```

Usually you donâ€™t need the whole props object itself, so you **destructure** it into individual props.

ê¸°ë³¸ê°’ì€ nullì´ë‚˜ 0ì„ ì „ë‹¬í•˜ë©´ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ”ë‹¤.

```jsx
// ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ì „ë‹¬í•˜ëŠ”ê±´ ì—†ë‚˜?
// ë‹¨ìˆœ ê¶ê¸ˆí•œê±´ë°, ê¼­ spreadë¥¼ ì¨ì•¼ë˜ë‚˜ì‹¶ì–´ì„œ
// propsë¥¼ ë³µë¶™í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ props ê°ì²´ ê·¸ëŒ€ë¡œ ì „ë‹¬ì€ ì•ˆë˜ë‚˜
// ì°¸ì¡°ë¡œ ì „ë‹¬í•œë‹¤ìŒì— ë°”ë€Œë©´ ì¢€ ê·¸ë˜ì„œ ê·¸ëŸ°ê°€
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
```

Use spread syntax with restraint. If youâ€™re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX.

When you nest content inside a JSX tag, the parent component will receive that content in a prop called children

Props are immutable. When a component needs to change its props, it will have to â€œaskâ€ its parent component to pass it different props - a new object. **Donâ€™t try to â€œchange propsâ€.**

-> ê·¸ë˜ì„œ ìœ„ì— ì½”ë“œì—ì„œë„ spreadë¡œ ì „ë‹¬í•œê±´ê°€?? ê·¼ë° êµ³ì´ ê°•ì œë¥¼ í•´ì•¼ë˜ë‚˜

Props are read-only snapshots in time: every render receives a new version of props.

### Conditional Rendering

In practice, returning null from a component isnâ€™t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent componentâ€™s JSX.

... But JSX elements arenâ€™t â€œinstancesâ€ because they donâ€™t hold any internal state and arenâ€™t real DOM nodes. Theyâ€™re lightweight descriptions, like blueprints. ë”°ë¼ì„œ if...elseì—ì„œ ê°ê° ë°˜í™˜í•˜ëŠ” ê°ì²´ëŠ” ìµœì¢…ì ìœ¼ë¡œ ì™„ì „íˆ ë™ì¼í•˜ë‹¤.

<del>Component</del>ì—ì„œ delì„ ì—†ì•´ë‹¤ ë„£ì–´ë„ Componentì˜ stateê°€ ë³´ì¡´ë˜ë‚˜?

React considers false as a â€œholeâ€ in the JSX tree, just like null or undefined, and doesnâ€™t render anything in its place.

Donâ€™t put numbers on the left side of &&. For example, a common mistake is to write code like messageCount && <p>New messages</p>.

### Rendering Lists

JSX elements directly inside a map() call always need keys. A well-chosen key helps React infer what exactly has happened, and make the correct updates to the DOM tree.

```jsx
import { Fragment } from 'react';

// ê° ë¦¬ìŠ¤íŠ¸ì˜ ì•„ì´í…œì´ ì—¬ëŸ¬ DOM ë…¸ë“œë“¤ì„ ë Œë”í•´ì•¼í•  ë–„.
// <></>ì—ëŠ” í‚¤ ê°’ì„ ë„£ì„ ìˆ˜ ì—†ë‹¤.
const listItems = people.map((person) => (
  <Fragment key={person.id}>
    <h1>{person.name}</h1>
    <p>{person.bio}</p>
  </Fragment>
));
```

If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, crypto.randomUUID() or a package like uuid when creating items.

Index as a key often leads to subtle and confusing bugs. Not only is this slow, but it will also lose any user input inside the list items.

Note that your components wonâ€™t receive key as a prop. Itâ€™s only used as a hint by React itself.

### Keeping Components Pure

React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs.

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

In general, you should not expect your components to be rendered in any particular order.

In React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.

Itâ€™s completely fine to change variables and objects that youâ€™ve just created while rendering. ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œ ìƒì„±í•œê±¸ ë°”ê¾¸ëŠ” ê²ƒì€ ê´œì°®ë‹¤. Local mutationì´ë¼ í•¨.

Side effectëŠ” ë³´í†µ ë Œë”ë§ ì¤‘ì´ ì•„ë‹ˆë¼ on the side(ë¹„ë°€ìŠ¤ëŸ½ê²Œ?) ë°œìƒí•œë‹¤.

ë¦¬ì•¡íŠ¸ì—ì„œ side effectëŠ” ë³´í†µ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë‚´ë¶€ì—ì„œ ë°œìƒí•œë‹¤. ì´ë²¤íŠ¸ëŠ” í•¸ë“¤ëŸ¬ê°€ ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œ ì •ì˜ë˜ì—ˆë‹¤í•´ë„ ë Œë”ë§ì¤‘ì— ë°œìƒí•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ìˆœìˆ˜í•  í•„ìš”ê°€ì—†ë‹¤.

ì í•©í•œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ì°¾ì§€ ëª»í–ˆìœ¼ë©´ useEffectë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ë§ˆì§€ë§‰ ìˆ˜ë‹¨ì´ë˜ì–´ì•¼ í•œë‹¤. **ê°€ëŠ¥í•œí•œ ë Œë”ë§ë§Œìœ¼ë¡œ ë¡œì§ì„ í‘œí˜„í•˜ë¼.**

ì´ ì±•í„°ëŠ” ë‹¤ì‹œ ì½ì–´ë³´ë©´ ì¢‹ì„ ë“¯.

**ì™œ ë¦¬ì•¡íŠ¸ëŠ” purityë¥¼ ì‹ ê²½ì“¸ê¹Œ?**

- ë‹¤ì–‘í•œ í™˜ê²½ì—ì„œ ë™ì¼í•˜ê²Œ ë™ì‘í•œë‹¤(ì„œë²„ ë“±ë“±).
- ì…ë ¥ì´ ê°™ìœ¼ë©´ ë Œë”ë§ì„ ê±´ë„ˆë›°ì–´ ì„±ëŠ¥ì„ ìµœì í™”í•  ìˆ˜ ìˆë‹¤.
- ë Œë”ë§ ì¤‘ ë°ì´í„°ê°€ ë°”ë€Œë©´ ê¸°ì¡´ ë Œë”ë§ì„ ì¦‰ì‹œ ì¤‘ë‹¨í•´ë„ ìƒê´€ ì—†ë‹¤.

You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, â€œsetâ€ state instead of mutating preexisting objects.

Strive to express your componentâ€™s logic in the JSX you return. When you need to â€œchange thingsâ€, youâ€™ll usually want to do it in an event handler. As a last resort, you can useEffect.

sortëŠ” ì›ë³¸ ë°°ì—´ì„ mutateì‹œí‚¨ë‹¤.
