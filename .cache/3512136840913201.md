
## Preface

ë§ì€ ê°œë°œìë“¤ì´ íŒŒì´ì¬ì„ ì´ì „ì— ì“°ë˜ ì–¸ì–´ì²˜ëŸ¼ ì‚¬ìš©í•´ë²„ë¦°ë‹¤.

ì•Œì§€ ëª»í•˜ëŠ” ê¸°ëŠ¥ì— ëŒ€í•´ì„œëŠ” ì•„ì‰¬ì›Œí•  ìˆ˜ ì—†ë‹¤. íŒŒì´ì¬ì„ ê°•ë ¥í•˜ê²Œ ì‚¬ìš©í•˜ì.

> Its emphasis is on the language features that are either unique to Python or not found in many other popular languages.

> Premature abstraction is as bad as premature optimization.

[doctest](https://docs.python.org/3/library/doctest.html)

[GitHub](https://github.com/fluentpython/example-code-2e)

[fluentpython.com](https://www.fluentpython.com)

## 1. Data Structures

### 1. The Python Data Model

íŒŒì´ì¬ì˜ ê°•ì  ì¤‘ í•˜ë‚˜ëŠ” ì¼ê´€ì„±ì´ë‹¤.

> You can think of the data model as a description of Python as a framework.

íŒŒì´ì¬ ì¸í„°í”„ë¦¬í„°ëŠ” ê¸°ë³¸ì ì¸ ê°ì²´ ì—°ì‚°ì„ ìœ„í•´ íŠ¹ë³„ ë©”ì„œë“œ(special method)ë¥¼ í˜¸ì¶œí•œë‹¤. obj[key]ëŠ” \_\_getitem\_\_ íŠ¹ë³„ ë©”ì„œë“œì— ì˜í•´ ì§€ì›ëœë‹¤.

```py
import collections
from random import choice

Card = collections.namedtuple('Card', ['rank', 'suit'])


class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spafed diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit)
                       for rank in self.ranks for suit in self.suits]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]


beer_card = Card('7', 'diamonds')
print(beer_card)
# Card(rank='7', suit='diamonds')
# namedTupleì´ë¼ì„œ ì˜ˆì˜ê²Œ í”„ë¦°íŠ¸ëœë‹¤.

deck = FrenchDeck()
print(len(deck))  # 52
print(deck[-1])  # Card(rank='A', suit='hearts')

choice(deck)

# ì´ì™¸ì—ë„ slicing, sorting, containing ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
# Although FrenchDeck implicitly inherits from the object class, most of its functionality is not inherited, but comes from leveraging the data model and composition.
```

íŒŒì´ì¬ ë°ì´í„° ëª¨ë¸ì„ leverageí•˜ê¸° ìœ„í•œ íŠ¹ë³„ ë©”ì„œë“œëŠ” í´ë˜ìŠ¤ì˜ ì‚¬ìš©ìê°€ ì„ì˜ì˜ ë©”ì„œë“œ ì´ë¦„ì„ ì™¸ìš¸ í•„ìš”ê°€ ì—†ê²Œ í•˜ê³  í’ë¶€í•œ íŒŒì´ì¬ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œë¶€í„° ì´ë“ì„ ì·¨í•˜ê¸° ì‰½ê²Œ í•œë‹¤.

íŠ¹ë³„ ë©”ì„œë“œëŠ” ë‚´ê°€ ì•„ë‹Œ íŒŒì´ì¬ ì¸í„°í”„ë¦¬í„°ì— ì˜í•´ í˜¸ì¶œë˜ì–´ì•¼í•œë‹¤. ìœ ì¼í•˜ê²Œ ìì£¼ ì§ì ‘ ë¶ˆëŸ¬ì•¼í•˜ëŠ” íŠ¹ë³„ ë©”ì„œë“œëŠ” \_\_init\_\_ì´ë‹¤. ë¹ŒíŠ¸ì¸ í•¨ìˆ˜ë“¤ì´ ë¶€ë¥´ëŠ”ê²Œ ë‹¤ë¥¸ ì‘ì—…ë„ í•´ì£¼ê³  ë¹ŒíŠ¸ì¸ íƒ€ì…ì—ì„œëŠ” ë¹ ë¥´ë‹ˆê¹Œ ì¢‹ë‹¤.

```py
import math


class Vector:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Vector({self.x!r}, {self.y!r})'

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        # The builtins True and False are the only two instances of the class bool.
        # The class bool is a subclass of the class int, and cannot be subclassed.
        return bool(abs(self))

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y*scalar)


v1 = Vector(3, 4)
v2 = Vector(2, 1)

print(v1 + v2)
print(abs(v1))
print(v1 * 3)
print(abs(v1*3))
```

[what does r do in str and repr](https://stackoverflow.com/questions/38418070/what-does-r-do-in-str-and-repr)

\_\_repr\_\_ì€ match the source code to re-create the represented object, \_\_str\_\_ëŠ” ì—”ë“œ ìœ ì €ê°€ ë³´ê¸° ì í•©í•˜ê²Œ. ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ í•œë‹¤ë©´ \_\_str\_\_

ë¶ˆë¦¬ì–¸ì´ ì‚¬ìš©ë  ë§¥ë½ì—ì„œ ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í—ˆìš©ëœë‹¤. \_\_bool\_\_ì„ í˜¸ì¶œí•´ë³´ê³ , ì—†ìœ¼ë©´ lenì„ í˜¸ì¶œí•´ 0ì¸ì§€ ì•„ë‹Œì§€ í™•ì¸í•œë‹¤. ì´ê²ƒë„ ì—†ìœ¼ë©´ true.

ABC: abstract base classes

- Iterable - unpacking, iteration
- Sized - len
- Container - in operator

ì¤‘ìš”í•œ Collectionì˜ ë¶„í™”ì—ëŠ” Sequence, Mapping, Setì´ ìˆë‹¤.

> len is not called as a method because it gets special treatment as part of the Python Data Model, just like abs.But thanks to the special method \_\_len\_\_, you can also make len work with your own custom objects.

### 2. An Array of Sequences

í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” Cë¡œ êµ¬í˜„ëœ í’ë¶€í•œ ì‹œí€€ìŠ¤ íƒ€ì…ì„ ì œê³µí•œë‹¤.

list, tuple, dequeê°™ì€ container sequenceëŠ” ë‹¤ë¥¸ íƒ€ì…ì˜ ìš”ì†Œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³  str, byte, arrayê°™ì€ flat sequenceëŠ” í•œ íƒ€ì…ë§Œ ê°€ì§ˆ ìˆ˜ ìˆë‹¤. ì „ìëŠ” ì°¸ì¡°, í›„ìëŠ” ê°’ì„ ê°€ì§„ë‹¤. ì „ìëŠ” ìˆ«ìë¥¼ ë„£ì–´ë„ ì°¸ì¡°ë¡œ ê°€ì§€ëŠ” ë“¯?(Figure 2-1)

ì´ë ‡ê²Œ ë§ê³  mutabilityë¡œ ë‚˜ëˆŒ ìˆ˜ë„ ìˆë‹¤. tuple, str, byteëŠ” ë³€ê²½ ë¶ˆê°€ëŠ¥í•˜ë‹¤. mutable sequenceë“¤ì€ immutable sequenceì˜ ê²ƒë“¤ì„ ìƒì†ë°›ëŠ”ë‹¤.

ëª¨ë“  íŒŒì´ì¬ ê°ì²´ëŠ” ë©”íƒ€ë°ì´í„°ê°€ ë“  í—¤ë”ë¥¼ ê°€ì§„ë‹¤.

ìƒì„±ëœ listë¡œ ë­˜ í• ê²Œ ì•„ë‹ˆë¼ë©´ list comprehensionì€ ì‚¬ìš©í•˜ë©´ ì•ˆëœë‹¤.

```py
symbols = 'ê°€ë‚˜ë‹¤ë¼'
print([ord(symbol) for symbol in symbols])

# forì— ëŒ€ì…ëœ ë³€ìˆ˜ë¥¼ ë‹´ì„ ë³„ë„ì˜ ì§€ì—­ ìŠ¤ì½”í”„ê°€ ìˆë‹¤
x = 'ABC'
codes = [ord(x) for x in x]
print(x)  # ABC
print(codes)  # [65, 66, 67]
# Walrus operatorëŠ” ì˜ˆì™¸. ì–˜ëŠ” enclosing functionì´ ìŠ¤ì½”í”„ì´ë‹¤.
codes = [last := ord(c) for c in x]
print(last)  # 67

# Cartesian product
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
print(tshirts)
```

ListcompëŠ” mapê³¼ filterê°€ í•˜ëŠ”ê±° ë‹¤ í•  ìˆ˜ ìˆë‹¤. ë” ì˜ˆì¨.

ë‹¤ë¥¸ ì‹œí€€ìŠ¤ ë‹¤ë£¨ë ¤ë©´ generator expressionì„ ì‚¬ìš©í•œë‹¤.

```py
import array

symbols = 'abcde'
# ëŒ€ê´„í˜¸ ëŒ€ì‹  ì†Œê´„í˜¸
print(tuple(ord(symbol) for symbol in symbols))

# IëŠ” storage type
print(array.array('I', (ord(symbol) for symbol in symbols)))

# ë©”ëª¨ë¦¬ë¥¼ ì•„ë‚„ ìˆ˜ ìˆë‹¤.
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
for tshirt in (f'{c} {s}' for c in colors for s in sizes):
    print(tshirt)
```

íŠœí”Œì€ ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ë¦¬ìŠ¤íŠ¸ ì™¸ì—ë„ records with no field namesë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```py
lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)
traveler_ids = [('USA', '31195855'), ('BRA', 'CE342567'), ('ESP', 'XDA205856')]
for passport in sorted(traveler_ids):
    print('%s/%s' % passport)

# unpacking
# _ë„ ìœ íš¨í•œ ë³€ìˆ˜ ì´ë¦„. ë‹¤ë§Œ switchì—ì„œëŠ” ì™€ì¼ë“œì¹´ë“œë¡œ ì‚¬ìš©.
# íŒŒì´ì¬ ì½˜ì†”ì—ì„œëŠ” ì´ì „ ëª…ë ¹ì˜ ë°˜í™˜ê°’ì´ Noneì´ ì•„ë‹Œí•œ _ì— ëŒ€ì…ëœë‹¤.
for country, _ in traveler_ids:
    print(country)
```

Mutableí•œ ê°ì²´ë¥¼ ë‹´ì€ íŠœí”Œì€ ë²„ê·¸ì˜ ì›ì¸ì´ ë  ìˆ˜ ìˆë‹¤.

íŠœí”Œì€ ë¦¬ìŠ¤íŠ¸ë³´ë‹¤ ì„±ëŠ¥ì´ ì¢‹ë‹¤.

> Unpacking is important because it avoids unnecessary and error-prone use of indexes to extract elements from sequences.

```py
t = (20, 8)
_, remainder = divmod(*t)
print(remainder)  # 4

a, b, *rest = range(5)
print(rest)  # [2, 3, 4]

a, *body, c, d = range(5)
print(body)  # [1, 2]

print([*range(4), 4, *(5, 6, 7)])

metro_areas = [
    ('Tokyo', 'JP', 36.933, (35.689722, 139.691667)),
    ('Delhi NCR', 'IN', 21.935, (28.613889, 77.208889)),
    ('Mexico City', 'MX', 20.142, (19.433333, -99.133333)),
    ('New York-Newark', 'US', 20.104, (40.808611, -74.020386)),
    ('SÃ£o Paulo', 'BR', 19.649, (-23.547778, -46.635833)),
]

print(f'{"":15} | {"latitude":>9} | {"longitude":>9}')
for name, _, _, (lat, lon) in metro_areas:
    if lon <= 0:
        print(f'{name:15} | {lat:9.4f} | {lon:9.4f}')
```

single-item íŠœí”Œì€ trailing commaì™€ í•¨ê»˜ ì¨ì•¼í•œë‹¤. (a, )

```py
# One key improvement of match over switch is destructuring
def handle_command(self, message):
  match message:
    case ['BEEPER', frequency, times]:
      self.beep(times, frequency)
    case ['NECK', angle]:
      self.rotate_neck(angle)
    case ['LED', ident, intensity]:
      self.leds[ident].set_brightness(ident, intensity)
    case ['LED', ident, red, green, blue]:
      self.leds[ident].set_color(ident, red, green, blue)
    case _:
      raise InvalidCommand(message)
# Sequence patternì€ íŠœí”Œì´ë“  ë¦¬ìŠ¤íŠ¸ë“  ìƒê´€ì´ ì—†ë‹¤. collection.abs.Sequenceì˜ ì„œë¸Œí´ë˜ìŠ¤ë©´ ë˜ì§€ë§Œ str, bytes, bytearrayëŠ” ì˜ˆì™¸.
# patterns don't destructure iterables that are not sequences. like iterator
# ì—¬ê¸°ì„œ ì‚¬ìš©ëœ _ì—ëŠ” ê°’ì´ ë°”ì¸ë”©ë˜ì§€ ì•ŠëŠ”ë‹¤.
```

ì‹œí€€ìŠ¤ íŒ¨í„´ì—ì„œ \*ëŠ” ì‹œí€€ìŠ¤ë‹¹ í•œë²ˆë§Œ ë“±ì¥í•  ìˆ˜ ìˆë‹¤.

> Pattern matching is an example of declarative programming: the code describes â€œwhatâ€ you want to match, instead of â€œhowâ€ to match it.

slice/rangeì—ì„œ ëª…ì‹œí•œ? ë§ˆì§€ë§‰ ì›ì†Œë¥¼ í¬í•¨í•˜ì§€ ì•ŠëŠ” ê²ƒì€ ê¸¸ì´ë¥¼ ì•Œê¸° ì‰½ê³  ê³„ì‚°í•˜ê¸°ë„ ì‰½ê³ (stop - start) ì‹œí€€ìŠ¤ë¥¼ ë‘ ê°œë¡œ ë‚˜ëˆ„ê¸°(list[:x], list[x:]ë„ ì‰½ë‹¤.

```py
s = 'bicycle'
print(s[::3])  # bye
print(s[::-1])  # elcycib
print(s[::-2])  # eccb

# a:b:c notationì€ slice(a, b, c) ê°ì²´ë¥¼ ë§Œë“ ë‹¤.
invoice = """
0.....6.................................40........52...55........
1909  Pimoroni PiBrella                     $17.50    3    $52.50
1489  6mm Tactile Switch x20                 $4.95    2     $9.90
1510  Panavise Jr. - PV-201                 $28.00    1    $28.00
1601  PiTFT Mini Kit 320x240                $34.95    1    $34.95
"""
SKU = slice(0, 6)
DESCRIPTION = slice(6, 40)
UNIT_PRICE = slice(40, 52)
QUANTITY = slice(52, 55)
ITEM_TOTAL = slice(55, None)
# ì‹œì‘ì´ \nì„. 2ë¶€í„° ì‹œì‘
line_items = invoice.split('\n')[2:]
for item in line_items:
    print(item[UNIT_PRICE], item[DESCRIPTION])

l = list(range(10))
l[2:5] = [20, 30]
print(l)
del l[5:7]
print(l)
# l[2:5] = 10 -> can only assign an iterable
```

Augmented assignment operator. +=ì˜ ê²½ìš° \_\_iadd\_\_ë¥¼ í†µí•´ ì‘ë™í•˜ê³  êµ¬í˜„ë˜ì–´ìˆì§€ ì•Šìœ¼ë©´ \_\_add\_\_ë¥¼ ì‚¬ìš©í•œë‹¤. ë”°ë¼ì„œ í›„ìì˜ ê²½ìš° a = a + bì²˜ëŸ¼ ì‘ë™í•˜ê³  a + bë¥¼ í‰ê°€í•  ë•Œ ìƒˆë¡œìš´ ê°ì²´ë¥¼ ë§Œë“¤ê²Œ ëœë‹¤. ê°ì²´ì˜ identityê°€ ë°”ë€” ìˆ˜ë„ ì•ˆë°”ë€” ìˆ˜ë„ ìˆë‹¤.

ë”°ë¼ì„œ mutable ê°ì²´ëŠ” iaddê°€ êµ¬í˜„ë˜ì–´ inplaceë¡œ ì‘ë™í•œë‹¤ ìƒê°í•´ë„ ì¢‹ë‹¤.

```py
l = [[]] * 3
l[0].append(1)
print(l)  # [[1], [1], [1]]

l = [1, 2, 3]
print(id(l))
l *= 2
print(id(l))

t = (1, 2, 3)
print(id(t))
t *= 2
print(id(t))

# This exmaple is quite a corner case.
# t = (1, 2, [30, 40])
# t[2] += [50, 60]
# print(t)

# ë­ì§€ ì–˜ëŠ”
# dis.dis('s[1] += b')
```

- íŠœí”Œì— mutable ë„£ëŠ” ê²ƒ ì§€ì–‘
- Augmented assignementëŠ” ì›ìì  ì‘ì—…ì´ ì•„ë‹ˆë‹¤.
- Python bytecodeë¥¼ ë³´ëŠ”ê±´ ê·¸ë¦¬ ì–´ë µì§€ ì•Šë‹¤.

> Receiver is the target of a method call, the object bound to self in the method body.

list.sortëŠ” inplace.

[Fluent interface](https://en.wikipedia.org/wiki/Fluent_interface#Swift)

ì´ì§„ ê²€ìƒ‰ ëª¨ë“ˆì¸ bisectê°€ ìˆë‹¤.

ë¦¬ìŠ¤íŠ¸ë„ ì¢‹ì§€ë§Œ ë‹¤ë¥¸ê±¸ ì‚¬ìš©í•˜ëŠ”ê²Œ ì¢‹ì€ ê²½ìš°ë„ ìˆë‹¤. array, dequeue ë“±,,,

```py
from array import array
from random import random

# ë¹ ë¥´ë‹¤
# array of double-precision floats
floats = array('d', (random() for i in range(10**7)))
print(floats[-1])
fp = open('floats.bin', 'wb')
floats.tofile(fp)
fp.close()
floats2 = array('d')
fp = open('floats.bin', 'rb')
floats2.fromfile(fp, 10**7)
fp.close()
print(floats2[-1])
print(floats2 == floats)
```

> A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets.

> NumPy implements multi-dimensional, homogeneous arrays and matrix types that hold not only numbers but also user-defined records, and provides efficient element-wise operations.

> SciPy is a library, written on top of NumPy, offering many scientific computing algorithms from linear algebra, numerical calculus, and statistics.

> NumPy and SciPy are formidable libraries, and are the foundation of other awesome tools such as the Pandasâ€”which implements efficient array types that can hold nonnumeric data and provides import/export functions for many different formatsâ€™

```py
import numpy as np
a = np.arange(12)
print(a)  # [ 0  1  2  3  4  5  6  7  8  9 10 11]
print(a.shape)
a.shape = 3, 4
print(a)
print(a[:, 1])
print(a.transpose())
```

> The class collections.deque is a thread-safe double-ended queue designed for fast inserting and removing from both ends

```py
from collections import deque

dq = deque(range(10), maxlen=10)
print(dq)  # deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
dq.rotate(3)
print(dq)  # deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
dq.appendleft(-1)
print(dq)  # deque([-1, 7, 8, 9, 0, 1, 2, 3, 4, 5], maxlen=10)
```

ë±ì€ ì–‘ ëì—ì„œëŠ” ë¹ ë¥¸ ëŒ€ì‹ ì— ì¤‘ê°„ì—ì„œ í•˜ëŠ”ê±´ ëŠë¦¼ì— ìœ ì˜. appendì™€ popleftëŠ” ì›ìì ì´ë¼ì„œ ë©€í‹°ì“°ë ˆë“œì—ì„œ ë½ ì—†ì´ ì‚¬ìš©í•´ë„ ì¢‹ë‹¤.

ì´ì™¸ì—ë„ queue, multiprocessing, asyncio, heapqê°€ ìˆë‹¤.

### 3. Dictionaries and Sets

> Python is basically dicts wrapped in loads of syntactic sugar.

íŒŒì´ì¬ê³¼ ë”•ì…”ë„ˆë¦¬ëŠ” ë–¼ë†“ì„ ìˆ˜ ì—†ë‹¤. ì¤‘ìš”í•œ ì—­í• ì„ ë§¡ê¸°ì— ë§¤ìš° ìµœì í™”ë˜ì–´ìˆë‹¤.

```py
dial_codes = [
    (880, 'Bangladesh'),
    (55,  'Brazil'),
    (86,  'China'),
    (91,  'India'),
    (62,  'Indonesia'),
    (81,  'Japan'),
    (234, 'Nigeria'),
    (92,  'Pakistan'),
    (7,   'Russia'),
    (1,   'United States'),
]
country_dial = {country: code for code, country in dial_codes}

print(country_dial)
print({code: country.upper()
      for country, code in sorted(country_dial.items()) if code < 70})


def dump(**kwargs):
    return kwargs


# ì—¬ê¸°ì„œëŠ” ì¤‘ë³µì´ ì•ˆë˜ê³ 
print(dump(**{'x': 1}, y=2, **{'z': 3}))
# ì—¬ê¸°ì„œëŠ” ëœë‹¤
print({'x': 0, **{'x': 1}})

d1 = {'a': 1, 'b': 3}
d2 = {'a': 2, 'b': 4, 'c': 6}
print(d1 | d2)
```

```py
from collections import OrderedDict


def get_creators(record: dict) -> list:
    match record:
        case {'type': 'book', 'api': 2, 'authors': [*names]}:
            return names
        case {'type': 'book', 'api': 1, 'author': name}:
            return [name]
        case {'type': 'book'}:
            raise ValueError(f"Invalid 'book' record: {record!r}")
        case {'type': 'movie', 'director': name}:
            return [name]
        case _:
            raise ValueError(f'Invalid record: {record!r}')


# Sequence patternê³¼ ë‹¤ë¥´ê²Œ ë¶€ë¶„ì ì¸ ë§¤ì¹˜ë„ ì¢‹ë‹¤.
b1 = dict(api=1, author='Douglas Hofstadter',
          type='book', title='Godel, Escher, Bach')
print(get_creators(b1))

# ìˆœì„œìˆì–´ë„ ìƒê´€ì—†ë‹¤.
b2 = OrderedDict(api=2, type='book', title='Python in a Nutshell',
                 authors='Martelli Ravenscroft Holden'.split())
print(get_creators(b2))
get_creators({'type': 'book', 'pages': 770})
```

> An object is hashable if it has a hash code which never changes during its lifetime (it needs a \_\_hash\_\_() method), and can be compared to other objects (it needs an \_\_eq\_\_() method). Hashable objects which compare equal must have the same hash code.

Container íƒ€ì…ì€ immutableí•˜ê³  contained objectê°€ hashableí•  ë•Œ hashableí•˜ë‹¤.

ë³´ì•ˆìƒì˜ ì´ìœ ë¡œ íŒŒì´ì¬ ë²„ì „ë³„ë¡œ, ì»´í“¨í„° ì•„í‚¤í…ì²˜ì— ë”°ë¼ í•´ì‹œ ê°’ì€ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤. í•´ì‹œ ê°’ì€ í•œ íŒŒì´ì¬ í”„ë¡œì„¸ìŠ¤ë‚´ì—ì„œë§Œ ê°™ì„ ê²ƒì´ ë³´ì¥ëœë‹¤.

```py
# setdefault example
if key not in my_dict:
  my_dict[key] = []
my_dict[key].append(new_value)

my_dict.setdefault(key, []).append(new_value)
```

defaultdictì€ \_\_missing\_\_ì„ í†µí•´ ì‘ë™í•œë‹¤.

k in my_dict.keys()ë³´ë‹¤ k in my_dictê°€ ë” ë¹ ë¥´ë‹¤.

3.6ë¶€í„° ê¸°ë³¸ dictë„ ìˆœì„œë¥¼ ë³´ì¡´í•´ì„œ OrderedDictëŠ” ë³´í†µ í•˜ìœ„í˜¸í™˜ì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤. ì–´ëŠì •ë„ ì°¨ì´ëŠ” ìˆëŠ”ë°, dictëŠ” mapping ì—°ì‚°ì— íŠ¹í™”ë˜ì—ˆê³  OrderedDictëŠ” reorderì— íŠ¹í™”ë˜ì–´ìˆë‹¤. LRU ìºì‹œì—ì„œ ìµœê·¼ ì ‘ê·¼ì„ ê´€ë¦¬í•˜ëŠ”ë° ìš©ì´í•˜ë‹¤.

```py
# A ChainMap instance holds a list of mappings that can be searched as one.
import builtins
pylookup = ChainMap(locals(), globals(), vars(builtins)
```

```py
import collections

ct = collections.Counter('abracadabra')
print(ct)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
ct.update = 'aaaaazzz'
print(ct)
print(ct.most_common(3))  # [('a', 5), ('b', 2), ('r', 2)]
```

> The shelve module in the standard library provides persistent storage for a mapping of string keys to Python objects serialized in the pickle binary format.

dictë³´ë‹¤ UserDictë¥¼ ì„œë¸Œí´ë˜ì‹±í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

```py
# Immutableí•´ì•¼í•˜ëŠ” ê²ƒì„ API ì™¸ë¶€ë¡œ ê³µê°œí•  ë•Œ í™œìš©í•  ìˆ˜ ìˆë‹¤.
from types import MappingProxyType
d = {1: 'A'}
d_proxy = MappingProxyType(d)
print(d_proxy)  # {1: 'A'}
# TypeError: 'mappingproxy' object does not support item assignment
# d_proxy[2] = 'x'
```

dictì˜ .keys(), .values(), .items()ëŠ” íŠ¹ì • í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ”ë°, ì´ **dictionary view**ë“¤ì€ read-only projections of the internal data structures used in the dict implementationìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤. ì´ view objectëŠ” dynamic proxyì´ë‹¤.

```py
d = dict(a=10, b=20, c=30)
values = d.values()
d['d'] = 40
print(values)  # dict_values([10, 20, 30, 40])
```

> To save memory, avoid creating instance attributes outside of the \_\_init\_\_ method...??

**Set**

```py
# ì¤‘ë³µ ìš”ì†Œ ì œê±°í•´ì•¼ë˜ëŠ”ë° ìˆœì„œë„ ë³´ì¥í•´ì•¼í•  ë•Œ
dict.fromkeys(l).keys()
list(dict.fromkeys(l).keys())
```

ë¹ˆ ì§‘í•©ì€ {}ë¡œëŠ” ì•ˆë˜ê³  set()ì„ ì‚¬ìš©í•´ì•¼í•œë‹¤.

```py
from unicodedata import name

result = {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')}
{'Â§', '=', 'Â¢', '#', 'Â¤', '<', 'Â¥', 'Âµ', 'Ã—', '$', 'Â¶', 'Â£', 'Â©',
 'Â°', '+', 'Ã·', 'Â±', '>', 'Â¬', 'Â®', '%'}
print(result)  # salted hashë•Œë¬¸ì— ìˆœì„œëŠ” ë§¤ë²ˆ ë°”ë€ë‹¤.
```

```py
a = {1, 2, 3}
print(a.union([4], [5], [1, 2, 3]))
print({*[1, 2, 3], *{4, 5, 6}})

b = {2, 3, 4}
print(a ^ b)

c = {1, 2}
print(1 in a)  # True
print(c <= a)  # True
print(c < {1, 2})  # False

c.add(4)
c.clear()
c.discard(1) # ì—†ì–´ë„ ë¨
c.pop()
c.remove(1) # ì—†ìœ¼ë©´ KeyError
```

dict_keysì™€ dict_itemsëŠ” frozensetê³¼ ì•„ì£¼ ìœ ì‚¬í•˜ë‹¤.

### 4. Unicode Text Versus Bytes

> Python 3 introduced a sharp distinction between strings of human text and sequences of raw bytes. Implicit conversion of byte sequences to Unicode text is a thing of the past.

stringì´ë€ characterì˜ ì‹œí€€ìŠ¤ê³  characterëŠ” ì¼ë°˜ì ìœ¼ë¡œ Unicode characterì´ë‹¤.

characterì˜ identityëŠ” code pointì´ë©° 0ì—ì„œ 1114111ê¹Œì§€ì˜ ìˆ˜ì´ë‹¤.

íŠ¹ì • characterë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•œ ë°”ì´íŠ¸ëŠ” ì¸ì½”ë”©ì— ë”°ë¼ ë‹¬ë¼ì§„ë‹¤. ì¸ì½”ë”©ì´ë€ code pointì—ì„œ ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ë¡œì˜ ë³€í™˜ì„ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

```py
s = "cafÃ©"
print(len(s))  # 4
b = s.encode("utf8")
print(b)  # b'caf\xc3\xa9'
print(len(b))  # 5
print(b.decode("utf8"))

for codec in ["latin_1", "utf_8", "utf_16"]:
    print(codec, "El NiÃ±o".encode(codec))
```

bytes, bytearrayì˜ ìš”ì†ŒëŠ” 0-255ì˜ ìˆ˜ì´ë‹¤.

```py
s = "cafÃ©"
cafe = bytes(s, encoding="utf_8")
print(cafe)  # b'caf\xc3\xa9'
print(cafe[0])  # 99
print(cafe[:1])  # b'c'. binary sequenceì˜ sliceëŠ” ì–¸ì œë‚˜ ê°™ì€ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.
print(bytearray(cafe))  # bytearray(b'caf\xc3\xa9')
# 32-126ì€ ìˆ«ìë¡œ, \t, \n, \r, \\, ''ìˆìœ¼ë©´ ì•ˆì— ë­ê°€ ë¶™ê³  ë‚˜ë¨¸ì§€ 16ì§„ìˆ˜ê°’ì€ \xë¡œ í‘œì‹œ

print(bytes.fromhex("31 4B CE A9").decode("utf8"))
```

```py
# ë ˆê±°ì‹œ ì¸ì½”ë”© ë°©ë²•ì€ ì—ëŸ¬ ë¦¬í¬íŠ¸ ì—†ì´ ë””ì½”ë”©í•  ìˆ˜ë„ ìˆë‹¤.
octets = b"Montr\xe9al"
print(octets.decode("cp1252"))
print(octets.decode("iso8859_7"))
print(octets.decode("koi8_r"))
print(octets.decode("utf_8"))
```

utf ì¸ì½”ë”©ì€ ëª¨ë“  ìœ ë‹ˆì½”ë“œ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë„ë¡ ë””ìì¸ë˜ì—ˆë‹¤. utf-8ì€ 97%ì˜ ì›¹ì‚¬ì´íŠ¸ê°€ ì‚¬ìš©í•œë‹¤.

```py
u16 = "El NiÃ±o".encode("utf_16")
print(u16)
# b'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'
# b'`xff`xfe
# The bytes are b'\xff\xfe'. That is a BOMâ€”byte-order markâ€”denoting the â€œlittle-endianâ€ byte ordering of the Intel CPU where the encoding was performed.
# í˜¼ë€ì„ ë§‰ê¸° ìœ„í•´ UTF-16ì€ prepends the text with ZERO WIDTH NO_BREAK SPACE(U+FEFF)
# BOMì€ UTF-16 codecì— ì˜í•´ í•„í„°ë§ëœë‹¤.
```

> **Unicode sandwich**. byteëŠ” input, outputì–»ì–´ì˜¬ ë•Œ ë°”ë¡œ ì²˜ë¦¬í•˜ê³  ë¹„ì¦ˆë‹ˆìŠ¤ ì½”ë“œì—ì„œëŠ” textë§Œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì¸ë“¯.

In the Unicode standard, sequences like 'Ã©' and 'e\u0301' are called **canonical equivalents**, and applications are supposed to treat them as the same. But Python sees two different sequences of code points, and considers them not equal.

ì´ë•Œ normalize í•¨ìˆ˜ë¥¼ í™œìš©í•œë‹¤.

```py
from unicodedata import normalize

s1 = "cafÃ©"
s2 = "cafe\N{COMBINING ACUTE ACCENT}"
print(s1, s2)
print(len(s1), len(s2))
print(s1 == s2)

print(normalize("NFC", s1) == normalize("NFC", s2))
```

Case Foldingì´ë€ ëª¨ë“  í…ìŠ¤íŠ¸ë¥¼ ì†Œë¬¸ìë¡œ ë°”ê¾¸ëŠ” ê²ƒì´ë‹¤.

ìœ ë‹ˆì½”ë“œ í‘œì¤€ì€ code pointì—ì„œ character ì´ë¦„, ê° characterì˜ ë©”íƒ€ ë°ì´í„°ë“±ì„ í¬í•¨í•˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì œê³µí•œë‹¤.

```py
from unicodedata import name

for char in "ğŸ¥³ğŸ§ğŸ’ŠâŒ¥":
    print(name(char))
    
# FACE WITH PARTY HORN AND PARTY HAT
# HEADPHONE
# PILL
# OPTION KEY
```

```py
import unicodedata
import re

re_digit = re.compile(r"\d")

sample = "1\xbc\xb2\u0969\u136b\u216b\u2466\u2480\u3285"

for char in sample:
    print(
        f"U+{ord(char):04x}",
        char.center(6),
        "re_dig" if re_digit.match(char) else "-",
        "isdig" if char.isdigit() else "-",
        "isnum" if char.isnumeric() else "-",
        f"{unicodedata.numeric(char):5.2f}",
        unicodedata.name(char),
        sep="\t",
    )
```

íŒŒì´ì¬ì˜ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¤‘ì—ëŠ” strê³¼ bytesë¥¼ ëª¨ë‘ ì¸ìë¡œ ë°›ëŠ” ê²ƒë“¤ì´ ìˆìœ¼ë©° ì…ë ¥ë°›ì€ íƒ€ì…ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì‘ë™í•œë‹¤.

### 5. Data Class Builders

> â€˜Python offers a few ways to build a simple class that is just a collection of fields, with little or no extra functionality. That pattern is known as a **data class**

## 2. Functions as Objects

## 3. Classes and Protocols

## 4. Control Flow

## 5. Metaprogramming

```py
def factorial(x):
    if x == 1: # This is the base case
        return 1

    else: # This is the recursive case
        return(x * factorial(x-1))

print(factorial(4))
```
