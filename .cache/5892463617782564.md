
## Foundations

### About Next.js

Next.js is a flexible React framework that gives you building blocks to create fast web applications.

React is a JavaScript library for building interactive user interfaces. By library, we mean React provides helpful functions to build UI, but leaves it up to the developer where to use those functions in their application. ë¦¬ì•¡íŠ¸ì˜ ì„±ê³µì€ ë‹¤ë¥¸ ë¶€ë¶„ì˜ êµ¬ì„±ì— ëŒ€í•´ ìƒëŒ€ì ìœ¼ë¡œ unopinionatedí–ˆê¸° ë•Œë¬¸ì´ë‹¤.

Next.js is a React framework that gives you building blocks to create web applications. By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.

UIë¥¼ ë¦¬ì•¡íŠ¸ë¡œ ë§Œë“¤ê³  routing, data fetchingê³¼ ê°™ì€ ë‹¤ë¥¸ ë¬¸ì œë“¤ì„ í•´ê²°í•´ì¤€ë‹¤.

### From JavaScript to React

HTMLë¡œë¶€í„° DOMì„ êµ¬ì„±í•œë‹¤. The DOM is an object representation of the HTML elements. It acts as a bridge between your code and the user interface, and has a tree-like structure with parent and child relationships.

```html
<html>
  <body>
    <div id="app"></div>

    <script type="text/javascript">
      // Select the div element with 'app' id
      const app = document.getElementById('app');

      // Create a new H1 element
      const header = document.createElement('h1');

      // Create a new text node for the H1 element
      const headerContent = document.createTextNode('Develop. Preview. Ship. ğŸš€');

      // Append the text to the H1 element
      header.appendChild(headerContent);

      // Place the H1 element inside the div
      app.appendChild(header);
    </script>
  </body>
</html>
```

HTML represents the initial page content, whereas the DOM represents the updated page content which was changed by the JavaScript code you wrote.

í•˜ì§€ë§Œ ì´ëŒ€ë¡œëŠ” ë²ˆê±°ë¡­ë‹¤. ì»´í“¨í„°ì—ê²Œ howë¥¼ imperativeí•˜ê²Œ ì•Œë ¤ì¤˜ì•¼í•¨. Whatë§Œ ì•Œë ¤ì£¼ë©´ ì»´í“¨í„°ê°€ ì•Œì•„ì„œ í•´ì£¼ë©´ ì•ˆë˜ë‚˜?? A popular declarative library that helps developers build user interfaces is React.

```html
<!-- index.html -->
<html>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- ë¸Œë¼ìš°ì €ëŠ” JSXë¥¼ ì´í•´í•˜ì§€ ëª»í•´ì„œ ë°”ë²¨ê³¼ ê°™ì€ ììŠ¤ ì»´íŒŒì¼ëŸ¬ê°€ í•„ìš”í•˜ë‹¤ -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- You will need to inform Babel what code to transform by changing the script type to type=text/jsx. -->
    <script type="text/jsx">
      const app = document.getElementById('app');
      ReactDOM.render(<h1>Develop. Preview. Ship. ğŸš€</h1>, app);
    </script>
  </body>
</html>
```

- react is the core React library.
- react-dom provides DOM-specific methods that enable you to use React with the DOM.

[Javascript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

### From React to Next.js

unpkg.comì´ ì•„ë‹Œ nodeë¥¼ ì‚¬ìš©í•œë‹¤.

```
npm install react react-dom next
```

ì—†ì•´ ìˆ˜ ìˆë‹¤ - The Babel script because Next.js has a compiler that transforms JSX into valid JavaScript browsers can understand.

html íŒŒì¼ë„ jsx íŒŒì¼ë¡œ ë°”ê¿”ë„ ë¨. index.jsx íŒŒì¼ì€ pages í´ë”ë¡œ ì´ë™.

```jsx
import { useState } from 'react';

function Header({ title }) {
  return <h1>{title ? title : 'Default title'}</h1>;
}

export default function HomePage() {
  const names = ['Ada Lovelace', 'Grace Hopper', 'Margaret Hamilton'];

  const [likes, setLikes] = useState(0);

  function handleClick() {
    setLikes(likes + 1);
  }

  return (
    <div>
      <Header title="Develop. Preview. Ship. ğŸš€" />
      <ul>
        {names.map((name) => (
          <li key={name}>{name}</li>
        ))}
      </ul>

      <button onClick={handleClick}>Like ({likes})</button>
    </div>
  );
}
```

```json
{
  "scripts": {
    // npxëŠ” ìë™ìœ¼ë¡œ ë¶™ì—¬ì£¼ë‚˜ë³´ì§€?
    "dev": "next dev",
    "test": "echo \"Error: no test specified\" && exit 1"
  }
}
```

### How Next.js Works

In the next sections, weâ€™ll look at what happens to your application code during these different stages:

- The environment where your code runs: Development vs. Production
- When your code runs: Build Time vs. Runtime
- Where rendering happens: Client vs. Server

ê°œë°œ í™˜ê²½ì—ì„œëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸, ESLintì™€ ê°™ì€ ê¸°ëŠ¥ì´ ì¤‘ì ì´ê³  ë°°í¬ í™˜ê²½ì—ì„œëŠ” ì„±ëŠ¥ê³¼ ì ‘ê·¼ì„±ì´ ì¤‘ì . ë°°í¬íŒì„ ë§Œë“œë ¤ë©´ compiled, bundled, minified, code splitì´ í•„ìš”í•˜ë‹¤.

Next.jsì—ëŠ” ëŸ¬ìŠ¤íŠ¸ë¡œ ì“´ ì»´íŒŒì¼ëŸ¬ì™€ SWC í”Œë«í¼ì´ ìˆë‹¤.

In Next.js, **compilation** happens during the development stage as you edit your code, and as part of the build step to prepare your application for production.

**Minification** is the process of removing unnecessary code formatting and comments without changing the codeâ€™s functionality. The goal is to improve the applicationâ€™s performance by decreasing file sizes.

**Bundling** is the process of resolving the web of dependencies and merging (or â€˜packagingâ€™) the files (or modules) into optimized bundles for the browser, with the goal of reducing the number of requests for files when a user visits a web page.

**Code-splitting** is the process of splitting the applicationâ€™s bundle into smaller chunks required by each entry point.

When you build your application, Next.js will transform your code into production-optimized files ready to be deployed to servers and consumed by users. These files include:

- HTML files for statically generated pages
- JavaScript code for rendering pages on the **server**
- JavaScript code for making pages interactive on the **client**
- CSS files

ë¦¬ì•¡íŠ¸ ì½”ë“œë¥¼ HTMLë¡œ ë°”ê¾¸ëŠ” ê³¼ì •ì„ ë Œë”ë§ì´ë¼ í•˜ê³ , ì´ëŠ” ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ì–´ëŠìª½ì—ì„œë“  ì¼ì–´ë‚˜ê²Œ í•  ìˆ˜ ìˆë‹¤. ë¹Œë“œì‹œì , ëŸ°íƒ€ì„ ë‘˜ ë‹¤ ê°€ëŠ¥í•˜ë‹¤. Next.jsì—ì„œëŠ” Server-side Rendering, Static Site Generation, Client-Side Rendering ëª¨ë‘ ê°€ëŠ¥í•˜ë‹¤.

Server-Side Rendering and Static Site Generation are also referred to as **Pre-Rendering** because the fetching of external data and transformation of React components into HTML happens before the result is sent to the client.

useEffect ì¨ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ë©´ CSRë¡œ opt toí•  ìˆ˜ ìˆë‹¤.

ë„¥ìŠ¤íŠ¸ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  í˜ì´ì§€ë¥¼ pre-renderí•œë‹¤.

SSRì—ì„œëŠ” ê° ìš”ì²­ë§ˆë‹¤ HTMLì´ ì„œë²„ì—ì„œ ìƒì„±ëœë‹¤. í´ë¼ì´ì–¸íŠ¸ì—ì„œëŠ” HTMLì„ ì¨ì„œ ë¹ ë¥´ê²Œ non-interactive pageë¥¼ ë³´ì´ê³  ì´í›„ ë¦¬ì•¡íŠ¸ê°€ JSONê³¼ JSë¥¼ ì‚¬ìš©í•´ ì»´í¬ë„ŒíŠ¸ê°€ interactiveí•˜ê²Œ ë§Œë“ ë‹¤. ì´ë¥¼ **hyration**ì´ë¼ í•œë‹¤. ë„¥ìŠ¤íŠ¸ì—ì„œëŠ” getServerSidePropsë¥¼ í†µí•´ SSRë¡œ opt toí•  ìˆ˜ ìˆë‹¤.

Server components allow developers to keep some logic on the server and only send the result of that logic to the client.

SSGëŠ” HTMLì´ ì„œë²„ì—ì„œ ë§Œë“¤ì–´ì§€ì§€ë§Œ ëŸ°íƒ€ì„ì— ì„œë²„ê°€ ì—†ë‹¤. HTMLì´ CDNì— ì €ì¥ë¨. getStaticPropsë¡œ opt toí•  ìˆ˜ ìˆë‹¤.

We use the term **origin** to distinguish this server from the other places application code can be distributed to, such as **CDN servers** and **Edge servers**.

In Next.js, since pre-rendering can be done ahead of time, CDNs are well suited to store the static result of the work - making content delivery faster.

...But unlike CDNs, which store static content, some Edge servers can run small snippets of code. ìºì‹±ê³¼ code executionì´ ê°€ëŠ¥í•˜ë‹¤. By moving some work that was traditionally done client-side or server-side to the Edge, you can make your application more performant because it reduces the amount of code sent to the client, and part of the user's request does not have to go all the way back to the origin server - thus reducing latency.

[Falling Into The Pit of Success](https://blog.codinghorror.com/falling-into-the-pit-of-success/)

## Create Your First App

### Create a Next.js App

- page-based routing system (with support for dynamic routes)
- Pre-rendering(both SSG, SSR)
- Automatic code splitting
- Client-side routing with optimized prefetching
- CSS/Sass/CSS-in-JS support
- Fast Refresh
- API routes to build API endpoints with Serverless Functions??

create-next-app

### Navigate Between Pages

In Next.js, a page is a React Component exported from a file in the pages directory. Path to the file becomes the URL path.

a íƒœê·¸ ëŒ€ì‹ ì— Link ì»´í¬ë„ŒíŠ¸ë¥¼ ì‚¬ìš©í•œë‹¤. <Link> allows you to do client-side navigation and accepts props that give you better control over the navigation behavior.

Client-side navigation means that the page transition happens using JavaScript, which is faster than the default navigation done by the browser. Browser does not load the full page.

aë¡œ í•˜ë©´ ë¸Œë¼ìš°ì € ìƒë‹¨ì— ë¡œë”©ë°” ì›€ì§ì´ëŠ”ë° LinkëŠ” ê·¸ëŸ°ê±° ì—†ìŒ!

Only loading the code for the page you request also means that pages become isolated. If a certain page throws an error, the rest of the application would still work.

Furthermore, in a production build of Next.js, whenever Link components appear in the browserâ€™s viewport, Next.js automatically prefetches the code for the linked page in the background.

If you need to link to an external page outside the Next.js app, just use an <a> tag without Link.

### Assets, Metadata, and CSS

Next.js can serve static assets, like images, under the top-level public directory. ì–˜ë„¤ëŠ” root of the applicationì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥??

```html
<img
  src="/images/profile.jpg"
  alt="Your Name"
/>
// ì´ ê²½ìš° ìŠ¤í¬ë¦° í¬ê¸°ë³„ ëŒ€ì‘, ì´ë¯¸ì§€ ìµœì í™”?, viewportì— ì§„ì…ì‹œì—ë§Œ ë¡œë”©í•˜ê¸° ë“±ë“±ì„ ì•Œì•„ì„œ
í•´ì•¼ëœë‹¤.
```

Image ì»´í¬ë„ŒíŠ¸ë¥¼ ì œê³µí•œë‹¤. Next.js also has support for Image Optimization by default. This allows for resizing, optimizing, and serving images in modern formats like WebP when the browser supports it. ì•”íŠ¼ ì¢‹ë‹¤. CMSë“±ì—ì„œ í˜¸ìŠ¤íŒ…ë˜ì–´ë„ ìµœì í™” ê°€ëŠ¥í•˜ë‹¤. on-demainë¡œ ìµœì í™”í•´ì„œ ë¹Œë“œ ì‹œê°„ì´ ëŠ˜ì§€ ì•ŠëŠ”ë‹¤.

<Head> is a React Component that is built into Next.js. It allows you to modify the <head> of a page.

Third-party JavaScript refers to any scripts that are added from a third-party source. next/script is an extension of the HTML <\script> element and optimizes when additional scripts are fetched and executed.

```jsx
<Script
  src="https://connect.facebook.net/en_US/sdk.js"
  strategy="lazyOnload"
  onLoad={() => console.log(`script loaded correctly, window.FB has been populated`)}
/>
```

A global stylesheet (globals.css), and a CSS module (Home.module.css). CSS modules allow you to locally scope CSS at the component-level by automatically creating unique class names. ê°™ì€ í´ë˜ìŠ¤ ì´ë¦„ì„ ì¶©ëŒ ì—†ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

To use CSS Modules, the CSS file name must end with .module.css.

```jsx
import styles from './layout.module.css';

export default function Layout({ children }) {
  return <div className={styles.container}>{children}</div>;
}
```

Furthermore, Next.jsâ€™s code splitting feature works on CSS Modules as well. It ensures the minimal amount of CSS is loaded for each page.

The default export of \_app.js is a top-level React component that wraps all the pages in your application.

In Next.js, you can add global CSS files by importing them from pages/\_app.js. You cannot import global CSS anywhere else.

[Utility-first CSS](https://tailwindcss.com/docs/utility-first)

Out of the box, with no configuration, Next.js compiles CSS using PostCSS.

To customize PostCSS config, you can create a top-level file called postcss.config.js. This is useful if you're using libraries like Tailwind CSS.

> PostCSS: A tool for transforming CSS with JavaScript

### Pre-rendering and Data Fetching

one of the most important concepts in Next.js: **Pre-rendering**.

When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called **hydration**.)

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/pre-rendering.png) -->

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/no-pre-rendering.png) -->

Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.

Importantly, Next.js lets you choose which pre-rendering form to use for each page.

ë°ì´í„°ê°€ ìì£¼ ë°”ë€Œê±°ë‚˜ í˜ì´ì§€ ë‚´ìš©ì´ ìš”ì²­ë§ˆë‹¤ ë°”ë€Œë©´ SSR. ì•„ë‹˜ ê± client-side JSë¥¼ ì¨ì„œ ë°ì´í„°ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ë„ ìˆë‹¤.

ì¼ë‹¨ì€ Static Generationì„ ë°°ì›Œë³´ì.

Static Generation can be done with and without data.

Maybe you need to access the file system, fetch external API, or query your database at build time.

```jsx
export default function Home(props) { ... }

export async function getStaticProps() {
  // Get external data from the file system, API, DB, etc.
  const data = ...

  // The value of the `props` key will be
  //  passed to the `Home` component
  return {
    props: ...
  }
}
```

```jsx
export async function getStaticProps() {
  const allPostsData = getSortedPostsData();
  return {
    props: {
      allPostsData,
    },
  };
}
```

getStaticProps only runs on the **server-side**.

In production, getStaticProps runs at build time. However, this behavior can be enhanced using the fallback key returned by getStaticPaths??

getStaticProps can only be exported from a page.

To use Server-side Rendering, you need to export getServerSideProps instead of getStaticProps from your page.

```jsx
// Because getServerSideProps is called at request time, its parameter (context) contains request specific parameters.
export async function getServerSideProps(context) {
  return {
    props: {
      // props for your component
    },
  };
}
```

<!-- ![Alt text](https://nextjs.org/static/images/learn/data-fetching/client-side-rendering.png) -->

This approach(CSR) works well for user dashboard pages, for example. Because a dashboard is a private, user-specific page, SEO is not relevant, and the page doesnâ€™t need to be pre-rendered. The data is frequently updated, which requires request-time data fetching. [useSWR](https://swr.vercel.app/ko)

### Dynamic Routes

In this lesson, weâ€™ll talk about the case where each page path depends on external data. Next.js allows you to statically generate pages with paths that depend on external data. This enables **dynamic URLs** in Next.js.

Pages that begin with [ and end with ] are dynamic routes in Next.js.

```jsx
// pages/posts/[id].js
import Layout from '../../components/layout';

export default function Post() {
  return <Layout>...</Layout>;
}

export async function getStaticPaths() {
  // Return a list of possible value for id
  // Returns an array that looks like this:
  // [
  //   {
  //     params: {
  //       id: 'ssg-ssr'
  //     }
  //   },
  //   {
  //     params: {
  //       id: 'pre-rendering'
  //     }
  //   }
  // ]
}

export async function getStaticProps({ params }) {
  const postData = getPostData(params.id);
  return {
    props: {
      postData,
    },
  };
}
```

To render markdown content, weâ€™ll use the remark library.

```
npm install remark remark-html
```

```jsx
const processedContent = await remark().use(html).process(matterResult.content);
const contentHtml = processedContent.toString();
```

```jsx
// title tag ì¶”ê°€ëŠ” ìš”ë ‡ê²Œ
<Head>
  <title>{postData.title}</title>
</Head>
```

To format the date, weâ€™ll use the date-fns library.

```jsx
import { parseISO, format } from 'date-fns';

export default function Date({ dateString }) {
  const date = parseISO(dateString);
  // timeì´ë¼ëŠ” íƒœê·¸ë„ ìˆêµ¬ë‚˜,,
  return <time dateTime={dateString}>{format(date, 'LLLL d, yyyy')}</time>;
}
```

If fallback is false, then any paths not returned by getStaticPaths will result in a 404 page.

If fallback is true, then the behavior of getStaticProps changes:

- The paths returned from getStaticPaths will be rendered to HTML at build time.
- The paths that have not been generated at build time will not result in a 404 page. Instead, Next.js will serve a â€œfallbackâ€ version of the page on the first request to such a path.
- In the background, Next.js will statically generate the requested path. Subsequent requests to the same path will serve the generated page, just like other pages pre-rendered at build time??

If fallback is blocking, then new paths will be server-side rendered with getStaticProps, and cached for future requests so it only happens once per path???

Dynamic routes can be extended to catch all paths by adding three dots (...) inside the brackets. pages/posts/\[...id].js matches /posts/a, but also /posts/a/b, /posts/a/b/c and so on.

```jsx
return [
  {
    params: {
      // Statically Generates /posts/a/b/c
      id: ['a', 'b', 'c'],
    },
  },
  //...
];
```

To create a custom 404 page, create pages/404.js.

### API Routes

Next.js has support for API Routes, which let you easily create an API endpoint as a Node.js serverless function.

creating a function inside the pages/api directory that has the following format:

```jsx
// req = HTTP incoming message, res = HTTP server response
export default function handler(req, res) {
  // ...
}
```

They can be deployed as Serverless Functions (also known as Lambdas).

- req is an instance of http.IncomingMessage, plus some pre-built middlewares.
- res is an instance of http.ServerResponse, plus some helper functions.

**Do Not Fetch an API Route from getStaticProps or getStaticPaths**. A good use case for API Routes is handling form input. For example, you can create a form on your page and have it send a POST request to your API Route. You can then write code to directly save it to your database. The API Route code will not be part of your client bundle, so you can safely write server-side code.

Preview Mode??

### Deploying Your Next.js App

- Develop: Weâ€™ve written code in Next.js and used the Next.js development server running to take advantage of its hot reloading feature.
- Preview: Weâ€™ve pushed changes to a branch on GitHub, and Vercel created a preview deployment thatâ€™s available via a URL. We can share this preview URL with others for feedback. In addition to doing code reviews, you can do deployment previews.
- Ship: Weâ€™ve merged the pull request to main to ship to production.

ë‹¤ë¥¸ í˜¸ìŠ¤íŒ… ì—…ì²´ì—ë‹¤ ì˜¬ë¦¬ë ¤ë©´ npm run buildë¥¼ í•˜ê³  npm run startí•˜ë©´ Node.js serverê°€ ì‹¤í–‰ëœë‹¤.

## Search Engine Optimization

ê²€ìƒ‰ ì—”ì§„ì€ Crawling, Indexing, Rendering, Rankingì˜ ì‘ì—…ì„ í•œë‹¤.

<!-- [Title](https://nextjs.org/_next/image?url=/static/images/learn/seo/googlebot.png&w=3840&q=75&dpl=dpl_39cnxyHb7GauKiJcrRXoucnG8nyk) -->

Web crawlers identify themselves using custom user-agents.

The HTTP 301 Moved Permanently redirect status response code indicates that the resource requested has been definitively moved to the destination URL. ë„¥ìŠ¤íŠ¸ëŠ” 308ì´ ìƒˆ ë²„ì „ì´ê³  ë‚˜ì•„ì„œ ê·¸ê±¸ ì“´ë‹¤.

```jsx
//  pages/about.js
export async function getStaticProps(context) {
  return {
    redirect: {
      destination: '/',
      permanent: true, // triggers 308
    },
  };
}

//next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true, // triggers 308
      },
    ];
  },
};
```

```txt
//robots.txt

# Block all crawlers for /accounts
User-agent: *
Disallow: /accounts

# Allow all crawlers
User-agent: *
Allow: /
```

Do not name the public directory anything else. The name cannot be changed and is the only directory used to serve static assets.

A sitemap is a file where you provide information about the pages, videos, and other files on your site, and the relationships between them. Search engines like Google read this file to more intelligently crawl your site.

It's more likely your site will be dynamic. In this case, we can leverage getServerSideProps to generate an XML sitemap on-demand.

```jsx
//pages/sitemap.xml.js
const EXTERNAL_DATA_URL = 'https://jsonplaceholder.typicode.com/posts';

function generateSiteMap(posts) {
  return `<?xml version="1.0" encoding="UTF-8"?>
   <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
     <!--We manually set the two URLs we know already-->
     <url>
       <loc>https://jsonplaceholder.typicode.com</loc>
     </url>
     <url>
       <loc>https://jsonplaceholder.typicode.com/guide</loc>
     </url>
     ${posts
       .map(({ id }) => {
         return `
       <url>
           <loc>${`${EXTERNAL_DATA_URL}/${id}`}</loc>
       </url>
     `;
       })
       .join('')}
   </urlset>
 `;
}

function SiteMap() {
  // getServerSideProps will do the heavy lifting
}

// res???
export async function getServerSideProps({ res }) {
  // We make an API call to gather the URLs for our site
  const request = await fetch(EXTERNAL_DATA_URL);
  const posts = await request.json();

  // We generate the XML sitemap with the posts data
  const sitemap = generateSiteMap(posts);

  res.setHeader('Content-Type', 'text/xml');
  // we send the XML to the browser
  res.write(sitemap);
  res.end();

  return {
    props: {},
  };
}

export default SiteMap;
```

Meta robots tags orrobots.txt files are directives and will always be obeyed. Canonical tags are recommendations that Google can decide to obey or not.

```jsx
// When users search for your site, Google Search results sometimes display a search box specific to your site,
// along with other direct links to your site.
// This tag tells Google not to show the sitelinks search box.
<meta
  name="google"
  content="nositelinkssearchbox"
/>
```

To avoid duplicate tags in your head you can use the key property, which will make sure the tag is only rendered once?? ê·¸ëƒ¥ ë„£ì–´ë„ ì¤‘ë³µ ì•ˆë¼ì•¼ë˜ëŠ”ê±° ì•„ë‹Œê°€ ì•„ childì—ì„œ ëª…ì‹œí•˜ëŠ” ê²½ìš°?

A canonical URL is the URL of the page that search engines think is most representative from a set of duplicate pages on your site.

They let Google know which URLs are the original source of truth and which are duplicated.

```html
<link
  rel="canonical"
  href="https://example.com/products/phone"
/>
```

**Incremental Static Regeneration** enables developers and content editors to use static generation on a per-page basis, without needing to rebuild the entire site. With ISR, you can retain the benefits of static while scaling to millions of pages.

CSR is perfect for data heavy dashboards, account pages or any page that you do not require to be in any search engine index.

**The most important thing for SEO is that page data and metadata is available on page load without JavaScript.**

[A Complate Guide To Incremental Static Regeneration(ISR) with Nex.js](https://www.smashingmagazine.com/2021/04/incremental-static-regeneration-nextjs/)

While Next.js offers AMP support, consider weighing the costs and benefits of having an AMP implementation in your website if it already has great Core Web Vitals scores. AMPëŠ” í›„ìˆœìœ„ì¸ë“¯~!

URL Structure - Semantic / Patterns that are logical and consistent / Keyword focuesd / Not parameter-based

```jsx
// pages/blog/[slug].js

// Set fallback to blocking. Now any new post added post build will SSR
// to ensure SEO. It will then be static for all subsequent requests
return { paths, fallback: 'blocking' };
```

The title tag is one of the most important SEO elements for two main reasons:

- ìœ ì €ê°€ ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ë³´ê³  ëˆ„ë¥´ëŠ” ê²ƒ
- êµ¬ê¸€ì´ í˜ì´ì§€ ì´í•´í•  ë•Œ ì£¼ìš”í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ê²ƒ. í‚¤ì›Œë“œ ì“°ë©´ ì¢‹ë‹¤.

The description meta tag is another important SEO element, but less so than the title. According to Google, this element is not taken into account for ranking purposes, but it can affect your click-through-rate on search results.

The Open Graph protocol, originally developed by Facebook, standardizes how metadata is used on any given web page. Other social media companies (like Pinterest, Twitter, LinkedIn, etc), may also use open graph for displaying rich cards when sharing a URL.

Structured data facilitates the understanding of your pages to search engines. Over the years, there have been several vocabularies in place, but currently the main one is schema.org.

According to the website, schema.org is a "collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond."

```jsx
import Head from 'next/head';

function ProductPage() {
  function addProductJsonLd() {
    return {
      __html: `{
      "@context": "https://schema.org/",
      "@type": "Product",
      "name": "Executive Anvil",
      "image": [
        "https://example.com/photos/1x1/photo.jpg",
        "https://example.com/photos/4x3/photo.jpg",
        "https://example.com/photos/16x9/photo.jpg"
       ],
      "description": "Sleeker than ACME's Classic Anvil, the Executive Anvil is perfect for the business traveler looking for something to drop from a height.",
      "sku": "0446310786",
      "mpn": "925872",
      "brand": {
        "@type": "Brand",
        "name": "ACME"
      },
      "review": {
        "@type": "Review",
        "reviewRating": {
          "@type": "Rating",
          "ratingValue": "4",
          "bestRating": "5"
        },
        "author": {
          "@type": "Person",
          "name": "Fred Benson"
        }
      },
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.4",
        "reviewCount": "89"
      },
      "offers": {
        "@type": "Offer",
        "url": "https://example.com/anvil",
        "priceCurrency": "USD",
        "price": "119.99",
        "priceValidUntil": "2020-11-20",
        "itemCondition": "https://schema.org/UsedCondition",
        "availability": "https://schema.org/InStock"
      }
    }
  `,
    };
  }
  return (
    <div>
      <Head>
        <title>My Product</title>
        <meta
          name="description"
          content="Super product with free shipping."
          key="desc"
        />
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={addProductJsonLd()}
          key="product-jsonld"
        />
      </Head>
      <h1>My Product</h1>
      <p>Super product for sale.</p>
    </div>
  );
}

export default ProductPage;
```

At a high level, **on page SEO** refers to the headings and links that make up the overall structure of the page. Headings indicate importance in the document and links connect the web together.

ê° í˜ì´ì§€ë§ˆë‹¤ H1íƒœê·¸ê°€ ìˆì–´ì•¼í•˜ê³  title íƒœê·¸ì™€ ìœ ì‚¬í•œ ë‚´ìš©ì„ ë‹´ì•„ì•¼í•œë‹¤.

However, if the child of Link is a custom component that wraps an a tag, you must add passHref to Link. styled-componentì™€ ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ë•Œ í•„ìˆ˜ì ì´ë‹¤. ESLintê°€ ì´ëŸ° ì‹¤ìˆ˜ëŠ” ë§‰ì•„ì¤€ë‹¤!!

```jsx
import Link from 'next/link';
import styled from 'styled-components';

// This creates a custom component that wraps an <a> tag
const RedLink = styled.a`
  color: red;
`;

function NavLink({ href, name }) {
  // Must add passHref to Link
  return (
    <Link
      href={href}
      passHref
    >
      <RedLink>{name}</RedLink>
    </Link>
  );
}

export default NavLink;
```

**Web Vitals** is an initiative created by Google to provide unified guidance and metrics to measure end-user page experience on the web.

**Core Web Vitals** is a subset of Web Vitals, and currently consists of three metrics that measure loading, interactivity, and visual stability. These metrics are **Largest Contentful Paint (LCP)**, **First Input Delay (FID)**, and **Cumulative Layout Shift (CLS)**. ê°ê°ì˜ ë©”íŠ¸ë¦­ì€ Good, Needs Improvements, Poorë¡œ ë‚˜ë‰œë‹¤.

**LCP** measures the time it takes to get the largest element on the page visible within the viewport.

The **FID**(First Input Delay) metric is the perception of an end userâ€™s experience while interacting with a web page. ì–˜ëŠ” Google Lighthouseê°™ì€ labì—ì„œ ì¸¡ì • ë¶ˆê°€ëŠ¥. [TBT](https://web.dev/tbt/)ëŠ” ëœë‹¤ëŠ”ë° ë‹¤ìŒì— ì½ì–´ë³´ì.

The **Cumulative Layout Shift (CLS)** metric is a measure of your siteâ€™s overall layout stabilit

Google provided [a set of specific metics and ranges](https://developers.google.com/search/blog/2021/04/more-details-page-experience) to analyze and optimize your performance.

Lighthouse - It is important to run reports in an incognito window, as third-party plugins will affect your report. Ad blocker ë“±ë“±ë„ ì˜í–¥ì„ ë¯¸ì¹  ìˆ˜ ìˆë‹¤.

ì˜ˆì œ ëŒë¦¬ë‹ˆê¹Œ certificate ì–´ì©Œêµ¬ ì—ëŸ¬ ëœ¨ëŠ”ë°?? ë‹¤ì‹œ í•´ë³´ë‹ˆê¹Œ ì´ë¯¸ ì ìˆ˜ê°€ ë†’ì•„ì„œ ìŒ,,

next/imageë¥¼ ì‚¬ìš©í•˜ì~ On-demand optimization, Lazy Loaded Images, Avoids CLS ë“±ë“±.

ext.js supports ES2020 dynamic `import()` for JavaScript. With it, you can import JavaScript modules dynamically and work with them. They also work with server-side rendering (SSR).

```js
const Fuse = (await import('fuse.js')).default;
const _ = (await import('lodash')).default;
```

React components can also be imported using dynamic imports, but in this case we use it in conjunction with next/dynamic to make sure it works just like any other React Component.

```js
import dynamic from 'next/dynamic';
const CodeSampleModal = dynamic(() => import('../components/CodeSampleModal'), {
  ssr: false,
});
```

Next.js has built-in Automatic Webfont Optimization. By default, Next.js will automatically inline font CSS at build time, eliminating an extra round trip to fetch font declarations. This results in improvements to First Contentful Paint (FCP) and Largest Contentful Paint (LCP).

Next.js provides a built-in Script component that optimizes loading for any third-party script, while giving developers the option to decide when to fetch and execute it.

```jsx
// next/head ì•ˆì— ìˆì„ í•„ìš” ì—†ë‹¤.
<Script
  strategy="afterInteractive"
  src="https://www.googletagmanager.com/gtag/js?id=123"
/>
```

To not negatively affect Largest Contentful Paint (LCP), most third-party scripts should be deferred to load after all the contents of a page has finished loading, either immediately after the page becomes interactive (strategy="afterInteractive") or lazily during browser idle time (strategy="lazyOnload").

> Once you have optimized your site, it's important to monitor while in production so you can continue to iterate.

[Next.js Speed Insights](https://nextjs.org/analytics)

[Chrome User Experience Report](https://developers.google.com/web/tools/chrome-user-experience-report)

ë“±ë“±...

## Excel

- tsconfig.json file. You may customize this file.
- next-env.d.ts file, which ensures Next.js types are picked up by the TypeScript compiler. You should not touch this file.

GetStaticProps, GetStaticPaths, GetServerSideProps íƒ€ì…ì´ ìˆë‹¤.
