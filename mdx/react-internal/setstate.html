<html>
  <body>
    <div id="root"></div>
    <script src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useState, useEffect } = React;

      function Child() {
        const [count, setCount] = useState(1);
        useEffect(() => {
          setCount((count) => count + 1);
        }, []);
        return (
          <button onClick={() => setCount((count) => count + 1)}>
            {count}
          </button>
        );
      }

      function App() {
        return (
          <div>
            Parent
            <Child />
            <Child />
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));

      // FiberRootNode is a special node that acts as the React root,
      // it holds the necessary meta info about the whole app.
      // Its current points to the actual Fiber Tree,
      // every time a new Fiber Tree is constructed, it re-points its current to the new HostRoot.
      const fiberRootNode = root._internalRoot;
      console.log(fiberRootNode);

      const hostRoot = fiberRootNode.current;
      console.log(hostRoot);

      // 다른 노드에서는 stateNode가 대응되는 HTMLElement인데 여기서는 FIberRootNode라서 헷갈린다.
      console.log(hostRoot.stateNode === fiberRootNode);

      // 부모 노드를 return으로 지칭하는게 특이하다.

      // 이게 hostRoot 하위로 안들어가네? 처음에는 fiberRootNode에만 있음.
      console.log(fiberRootNode.containerInfo);

      root.render(<App />);

      const dfsNode = (node, depth = 0) => {
        // tag: FiberNode has many sub type differentiated by tag. For example, FunctionComponent, HostRoot, ContextConsumer,MemoComponent,SuspenseComponent .etc
        // stateNode: it points to other backing data, for HostComponent, stateNode points to the actual backing DOM node.
        // child, sibling and return : these together form a tree-like structure.
        // elementType which is the component function or intrinsic HTML tag we provide.
        // flags: to indicate the updates to apply in Commit phase. subtreeFlags is for its subtree.
        // lanes: to indicate the priority of pending updates. childLanes if for its subtree.
        // memoizedState: points to its important data, for FunctionComponent it means the hooks.
        const { tag, stateNode, elementType, flags, lanes } = node;
        console.log(
          ' '.repeat(depth * 2) +
            `├─ ${tag} ${typeof elementType === 'function' ? elementType.name : elementType} ${stateNode?.tagName} ${flags} ${lanes}`,
        );

        if (node.child) {
          dfsNode(node.child, depth + 1);
        }
        if (node.sibling) {
          dfsNode(node.sibling, depth);
        }
      };

      setTimeout(() => {
        dfsNode(hostRoot);
      }, 1000);
    </script>
  </body>
</html>
