import Lane from './Lane.js';

export const title = 'React Internals Deep Dive';
export const date = '2025-04-22';

<Lane />

---

ReactSharedInternals.H는 초기에는 null이지만 React 렌더링 과정에서 설정됩니다.
주로 두 곳에서 설정됩니다:

1. **ReactFiberWorkLoop.js**의 `pushDispatcher` 함수:

```js
function pushDispatcher(container: any) {
  const prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  // ...
}
```

이 함수는 렌더링 시작 시 호출됩니다.

2. **ReactFiberHooks.js**에서는 컴포넌트의 렌더링 단계에 따라 다른 디스패처로
   설정됩니다:

```js
// 컴포넌트가 처음 마운트될 때
ReactSharedInternals.H = HooksDispatcherOnMount;
// 컴포넌트가 업데이트될 때
ReactSharedInternals.H = HooksDispatcherOnUpdate;
// 컴포넌트가 재렌더링될 때
ReactSharedInternals.H = HooksDispatcherOnRerender;
```

이런 디스패처 전환은 `renderWithHooks` 함수 내에서 이루어지며, 이것이 같은 훅
호출이 컴포넌트 상태에 따라 다른 동작을 하게 만듭니다.

---

# React 프로젝트 주요 패키지 설명

## 1. packages/react

- 리액트의 핵심 패키지
- 컴포넌트 정의, 훅 API, createElement 등 핵심 기능 포함
- 플랫폼에 의존적이지 않은 코드만 포함

## 2. packages/react-reconciler

- 리액트의 재조정(Reconciliation) 알고리즘 구현
- 가상 DOM 비교와 업데이트 결정
- Fiber 아키텍처 구현
- 훅의 실제 내부 구현이 여기 있음

## 3. packages/react-dom

- 웹 환경에서 리액트를 렌더링하는 패키지
- createRoot, render 메서드 등 제공
- DOM 조작을 담당

## 4. packages/react-server

- 서버 사이드 렌더링 기능 구현
- React 18의 새로운 SSR 아키텍처인 React Server Components 기능 포함

## 5. packages/scheduler

- 작업 스케줄링을 위한 패키지
- 동시성 모드(Concurrent Mode)에서 작업 우선순위 지정
- 렌더링 작업을 청크로 나누고 브라우저 idle 타임에 실행

## 6. packages/shared

- 여러 패키지에서 공유하는 유틸리티 코드
- 내부적으로 사용되는 상수, 타입, 헬퍼 함수 등

## 7. packages/react-cache

- 데이터 캐싱 메커니즘 구현
- Suspense와 함께 사용하여 비동기 데이터 로딩 지원

## 8. packages/react-is

- 리액트 엘리먼트 타입 확인을 위한 유틸리티
- 다른 라이브러리에서 리액트 요소 식별에 사용

## 9. packages/react-client

- React 18부터 추가된 클라이언트 컴포넌트 관련 기능

## 10. packages/react-devtools

- 개발자 도구 구현
- 컴포넌트 트리 검사, 프로파일링 기능

---

```js
export const ContextOnlyDispatcher: Dispatcher = {
  useEffect: throwInvalidHookError,
};

const HooksDispatcherOnMount: Dispatcher = {
  useEffect: mountEffect,
};

const HooksDispatcherOnUpdate: Dispatcher = {
  useEffect: updateEffect,
};

const HooksDispatcherOnRerender: Dispatcher = {
  useEffect: updateEffect,
};
```

---

1. After state changes, paths to target Fiber Node are marked with lanes and
   childLanes, to indicate if they or their subtree need to be re-rendered.
2. React re-render the whole Fiber Tree, with optimization of bailout to avoid
   re-rendering unnecessarily.
3. Once a component re-renders, it generates new React elements, its children
   all get new props even though they are equal, so React re-renders the whole
   Fiber Tree by default. Here is why you might need useMemo().
   - deepEqual로 바꾸고 리렌더링되는지 확인해보자.
4. By "re-render", React creates a new Fiber Tree out of current one, also marks
   the Fiber Node with flags of Placement ChildDeletion and Update if needed.
5. Once the new Fiber Tree is done, React processes Fiber Nodes with above flags
   and apply the changes to Host DOM in Commit phase.
6. Then the new Fiber Tree is pointed to as the current Fiber Tree. The nodes on
   previous Fiber Tree could be reused for next render.

## 1. Re-render in Trigger phase

### 1.1 lanes and childLanes

- lanes => for the pending work of itself
- childLanes => for the pending work of its subtree

lanes가 컴포넌트까지만 체크되고 그 아래에는 없네?

Priority of event determines the priority of the update.

리액트의 lane은 비트 플래그 시스템으로 구현되어 있으며, 주요 값은 다음과
같습니다:

- **NoLanes (0)**: 작업이 없음
- **SyncLane (1)**: 가장 높은 우선순위, 동기적으로 처리해야 하는 작업
- **InputContinuousLane**: 사용자 입력 처리를 위한 lane
- **DefaultLane**: 일반적인 상태 업데이트에 사용
- **TransitionLanes**: 트랜지션 API 사용 시 적용되는 낮은 우선순위
- **RetryLanes**: 에러 발생 후 재시도 작업
- **IdleLane**: 가장 낮은 우선순위, 브라우저 유휴 시간에 처리
- **OffscreenLane**: 화면 밖의 컴포넌트 처리

## 2. Re-render in Render phase

### 2.1 Basic rendering logic is the same as initial mount

```js
do {
  try {
    workLoopSync();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);

function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;
  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  // This line is important, we'll cover it in 2.5 memoizedProps vs pendingProps
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

React traverse the Fiber Tree and updates the fiber if necessary.

### 2.2 React reuses redundant Fiber Nodes before creating new ones

재활용 되게 열심히한다. every Fiber Node that is not on the current tree could
be reused.

### 2.3 The Update branch in beginWork()

updateFunctionComponent, updateHostComponent, updateHostText를 사용한다.

### 2.4 Bailout logic inside attemptEarlyBailoutIfNoScheduledUpdate()

따로 게시물도 있어서 간단하게만...

### 2.5 memoizedProps vs pendingProps

We can think of memoizedProps as current props while pendingProps as next
version.

`<Component />` has lanes of 1 meaning React has to re-render and reconcile its
children.

### 2.6 updateFunctionComponent() re-renders function components and reconciles

컴포넌트를 통으로 렌더링하는듯?

reconcileSingleElement, reconcileChildrenArray, reconcileSingleTextNode를
사용한다.

### 2.7 reconcileSingleElement()

And in useFiber, React creates or reuse the previous version. As mentioned
before, the pendingProps(which contains children) will be set. 뒤에서도 나오니
기억하기.

### 2.8 Once a component is re-rendered, their subtree is re-rendered by default

스케쥴되어있지 않아도(lane이 0이어도?) 프롭이 다르면 렌더링된다.

### 2.9 updateHostComponent()

https://ko.react.dev/reference/react/createElement 그냥 한 번 복습하면 유용할 것
같음

### 2.10 reconcileChildrenArray() creates and deletes fibers as needed

We see that fibers that should be deleted are put temporarily in an array of its
parent. This is needed because they don’t exist in the new fiber tree any longer
after deletion, but they are to be processed in Commit phase, so we need to put
them somewhere.

그림에서 빨간색 화살표로 표현되어있다. placement와 update와는 달리
'child'Deletion이라는 플래그이다.

### 2.11 placeChild() and deleteChild() marks fiber with flags

### 2.12 updateHostText()

Again it doesn’t nothing, because the updates are marked in complete phase -
completeWork(). This is also explained in initial mount.

### 2.13 completeWork() marks the update of HostComponent and creates DOM nodes if necessary

One thing I’d like to point out is that prepareUpdate() is run for both button
and its parent div, yet it generates null for div but [] for button. It is some
tricky edge case handling that we won’t dive into here. 뭔소리???

One thing I’d like to point out is that prepareUpdate() is run for both button
and its parent div, yet it generates null for div but [] for button. It is some
tricky edge case handling that we won’t dive into here. 여기서 다루지는 않는다고
합니다...

## 3. Re-render in Commit Phase

### 3.1 commitMutationEffectsOnFiber() kicks off the commit of Insertion/Deletion/Update

FunctionComponent / HostComponent / HostText 이렇게 세 개로 계속 나뉜다.

자식노드까지 가며 삭제하고 삽입하고 수정한다.

### 3.2 Deletion are processed first, before processing children and self

### 3.3 Insertions are processed next

### 3.4 Updates are handled the last

## 4. Summary

제공해주신 자료와 이전 대화 내용을 바탕으로, `useState`, `setState`와 관련된 React 내부의 주요 함수들이 어떤 포함 관계(호출 관계)를 가지는지 설명해 드리겠습니다. 소스에는 함수의 호출 흐름과 역할이 설명되어 있지만, **시각적인 다이어그램 형태는 아니므로 텍스트 설명으로 관계를 표현하겠습니다.**

핵심적으로 `useState`는 컴포넌트의 생애 주기와 업데이트 과정에 따라 다른 내부 함수들을 호출합니다. 또한 `setState` (실제로는 `dispatchSetState`) 호출은 업데이트를 스케줄링하는 복잡한 과정을 거치며 여러 함수를 사용합니다.

주요 함수들의 관계는 다음과 같습니다:

1.  **초기 렌더링 (Mount)**:
    *   컴포넌트가 처음 렌더링될 때 `useState()`가 호출됩니다.
    *   `useState()` 내부에서는 `mountState()` 함수가 호출됩니다.
    *   `mountState()`는 새로운 훅 객체를 생성하고, 상태 값(`memoizedState`, `baseState`)과 업데이트 큐(`queue`)를 초기화합니다.
    *   `mountState()`는 상태 값을 반환하는 배열과 함께 상태 업데이트 함수(`dispatch`)를 반환하는데, 이 `dispatch` 함수는 실제로는 `dispatchSetState` 함수가 현재 파이버와 큐에 바인딩된 형태입니다.

2.  **`setState()` 호출 (`dispatchSetState`)**:
    *   컴포넌트 내에서 `setState()` (즉, `dispatchSetState`에 바인딩된 함수)가 호출되면, 이 함수가 실행됩니다.
    *   `dispatchSetState` 함수는 업데이트의 우선순위(`lane`)를 결정하고, 업데이트 객체를 생성합니다.
    *   일반적인 경우 (렌더 단계 업데이트가 아닌 경우), `dispatchSetState`는 **`enqueueConcurrentHookUpdate`** 함수를 호출하여 업데이트를 큐에 추가합니다.
    *   `enqueueConcurrentHookUpdate` 함수는 다시 **`enqueueUpdate`** 함수를 호출합니다.
    *   **`enqueueUpdate` 함수는 매우 중요합니다**: 이 함수는 업데이트를 내부 리스트에 저장하고, **현재(`fiber.lanes`) 파이버와 그 대체(`alternate.lanes`) 파이버 모두에 업데이트가 있음을 표시하기 위해 `lanes`를 설정합니다**. 소스는 이것이 모든 것을 올바르게 처리하기 위함이지만 부작용(side effect)이 있다고 설명합니다.
    *   `dispatchSetState`는 업데이트를 큐에 추가한 후 (예: `enqueueConcurrentHookUpdate` 호출 후) **`scheduleUpdateOnFiber`** 함수를 호출하여 리렌더링을 스케줄링합니다.
    *   `scheduleUpdateOnFiber` 함수는 루트(Root)에 업데이트가 있음을 표시하고, **`ensureRootIsScheduled`** 함수를 호출하여 실제로 리렌더링이 스케줄되도록 보장합니다. 실제 리렌더링 시점은 React 스케줄러에 따라 달라집니다.

3.  **리렌더링 과정 중 업데이트 처리**:
    *   리렌더링이 시작되는 초기 단계인 `prepareFreshStack()` 함수 내에서, **`finishQueueingConcurrentUpdates`** 함수가 호출됩니다.
    *   `finishQueueingConcurrentUpdates` 함수는 `enqueueUpdate`에 의해 저장되었던 업데이트들을 가져와 해당 훅의 업데이트 큐(`queue.pending`)에 연결하고, **`markUpdateLaneFromFiberToRoot`** 함수를 호출하여 해당 파이버 및 상위 노드들의 `lanes`를 업데이트합니다. `markUpdateLaneFromFiberToRoot` 역시 현재 및 대체 파이버 양쪽에 `lanes`를 설정합니다.
    *   리렌더링 과정 중 각 컴포넌트의 작업이 시작될 때 **`beginWork()`** 함수가 호출됩니다. 이 단계에서 현재 처리 중인(`workInProgress`) 파이버의 `lanes`가 `NoLanes`로 클리어됩니다.
    *   컴포넌트 함수가 실행될 때 `useState()`가 다시 호출됩니다. 이번에는 마운트가 아니므로 `updateState()` 함수가 호출됩니다.
    *   `updateState()`는 **`updateReducer`** 함수를 호출합니다.
    *   `updateReducer`는 `updateWorkInProgressHook()`을 통해 이전 렌더링 시 생성된 훅을 가져오고, 업데이트 큐(`queue`)에 있는 업데이트들을 처리하여 새로운 상태 값(`newState`)을 계산합니다.
    *   업데이트 큐를 처리한 후, 새로운 상태(`newState`)와 이전 상태(`hook.memoizedState`)를 비교하여 상태 변경이 없으면 `markWorkInProgressReceivedUpdate()`를 호출하지 않아 리렌더링 후반 단계에서 컴포넌트 렌더링을 건너뛸 수 있습니다 (이것은 `early bailout`과 다른 형태의 bailout입니다).
    *   `updateReducer`는 계산된 `newState`로 훅의 `memoizedState`를 업데이트하고, 다음 리렌더링을 위한 `baseState`와 `baseQueue`를 설정합니다. 모든 업데이트 처리가 끝나면 큐의 `lanes`도 `NoLanes`로 설정될 수 있습니다.

**동일한 값으로 `setState`를 호출했을 때 리렌더링될 수 있는 이유**는 주로 `dispatchSetState` -> `enqueueUpdate` 호출 시 **현재 파이버와 대체 파이버 양쪽에 dirty 플래그(`lanes`)를 설정하는 동작** 과, 이 플래그가 **`beginWork()` 단계에서만 현재 `workInProgress` 파이버에 대해 클리어된다는 점** 때문입니다. `early bailout` 조건 (`fiber.lanes === NoLanes && alternate.lanes === NoLanes`)은 이 두 파이버 모두 clean 상태일 때만 만족되는데, 이전 업데이트로 인해 아직 클리어되지 않은 dirty 플래그가 한쪽에 남아있다면 이 조건이 거짓이 되어 `early bailout`이 작동하지 않고 컴포넌트 함수 호출(`updateState` -> `updateReducer`)까지 진행될 수 있습니다. 자료는 dirty `lanes` 플래그가 완전히 클리어되기까지 최소 두 번의 리렌더링 주기가 필요할 수 있다고 단계별로 설명합니다.

요약하자면, `setState` 호출은 `dispatchSetState` 함수를 트리거하고, 이 함수는 업데이트를 큐에 넣고(`enqueueConcurrentHookUpdate` -> `enqueueUpdate`) 리렌더링을 스케줄링합니다(`scheduleUpdateOnFiber`). 업데이트가 큐에 추가될 때 현재와 대체 파이버 모두에 dirty 표시가 되며, 이 표시가 리렌더링(`beginWork`)을 거쳐야만 클리어되기 때문에, 동일한 값으로 `setState`를 반복해서 호출하더라도 이전 업데이트의 dirty 상태가 남아있다면 `early bailout`이 실패하여 컴포넌트 함수가 다시 실행될 수 있습니다.