import renderStack from './assets/render-stack.png'
import domStack from './assets/dom-stack.png'
import effectStack from './assets/effect-stack.png'
import fiberRoot1 from './assets/fiber-root1.png'
import typeOfSymbol from './assets/2/type-of-symbol.png'

# 2025 ë¦¬ì•¡íŠ¸ ê¸°ì—¬ì ë˜ê¸°

## ì‹œì‘ì— ì•ì„œ

ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ì½”ë“œì— ê¸°ì—¬ë¥¼ í•œë²ˆì¯¤ì€ í•´ë³´ê³ ì‹¶ë‹¤ëŠ” ë§ˆìŒì´ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ íšŒì‚¬ì—ì„œ ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ì½”ë“œ ìŠ¤í„°ë””ë„ ì—´ì—ˆëŠ”ë°ìš”, ê±°ê¸°ì„œ ê³µë¶€í•œê±¸ ì—¬ê¸°ì— ì¨ë‚´ë ¤ë‚˜ê°ˆ ê³„íšì…ë‹ˆë‹¤.

ë‹¤ë¥¸ ë¸”ë¡œê·¸ ê¸€ë“¤ê³¼ ë‹¬ë¦¬ ì´ê±´ ì €ë„ ì˜ ëª¨ë¥´ëŠ” ë‚´ìš©ì´ë¼ì„œ ì£¼ì €ë¦¬ì£¼ì €ë¦¬ ë°°ìš´ ê²ƒë“¤ì„ ì¨ë‚˜ê°ˆ ì˜ˆì •ì…ë‹ˆë‹¤. ë‚˜ì¤‘ì— ëŒì•„ë³´ë©´ ì¬ë°Œì„ ê²ƒ ê°™ë„¤ìš” ğŸ¤—

ëŒ€ë¶€ë¶„ì˜ ì½”ë“œë“¤ì€ ì›ë³¸ì—ì„œ ì¤‘ìš”í•˜ê²Œ ë³¸ ë¶€ë¶„ë§Œ ë‚¨ê²¼ìŠµë‹ˆë‹¤! 

https://jser.dev/series/react-source-code-walkthrough/ ì˜ ì»¤ë¦¬í˜ëŸ¼ ë§ì¶° ì¼ì£¼ì¼ì— ëŒ€ëµ í•œ ê°•ì”© ê³µë¶€í•©ë‹ˆë‹¤. ëŒ€ì‹  ì €ëŠ” ë¦¬ì•¡íŠ¸ 19.1.0ì„ ê¸°ì¤€ìœ¼ë¡œ ê³µë¶€í•©ë‹ˆë‹¤.

### ê¸°íƒ€ ì°¸ê³  ìë£Œ

- https://bigfrontend.dev/react-quiz

## 1. React ë‚´ë¶€ êµ¬ì¡° ê°œìš”  

> ê°€ì¥ ê°„ë‹¨í•œ Hello World ì•±ì„ ë””ë²„ê¹…í•˜ë©° React ë‚´ë¶€ êµ¬ì¡°ë¥¼ ëŒ€ëµì ìœ¼ë¡œ ì‚´í´ë´…ë‹ˆë‹¤.

[ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ì½”ë“œ ì§ì ‘ ìˆ˜ì •í•´ì„œ ì¨ë³´ê¸°](/post/react-local-build)ëŒ€ë¡œ ì´ˆê¸° ì„¤ì •ì„ í•œë‹¤.

í¬ë¡¬ inspectorì—ì„œ DOM ìš”ì†Œ ìš°í´ë¦­ì„ í•˜ë©´ DOMì´ ë°”ë€” ë•Œ breakpointë¥¼ ì„¤ì •í•  ìˆ˜ ìˆë‹¤. ëŒ€ì‹  ë‚˜ì²˜ëŸ¼ reactë¥¼ ì§ì ‘ ì„¤ì¹˜í•´ì„œ ì“´ë‹¤ë©´ https://stackoverflow.com/questions/77657008/ ì„ ì ìš©í•´ì•¼í•  ìˆ˜ë„ ìˆë‹¤.

ë¦¬ì•¡íŠ¸ ì½”ë“œ ê³³ê³³ì— breakpointë¥¼ ê±¸ì–´ì„œ ì½œìŠ¤íƒì„ ì‚´í´ë³´ì:

```js
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [count, setCount] = useState(1);
  debugger; // 1

  // 2 <div id="root"></div> ì— breakpoint

  useEffect(() => {
    debugger; // 3
    setCount((count) => count + 1);
  }, []);

  return <button>{count}</button>;
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

ìœ„ ì½”ë“œ breakpointë³„ ì½œ ìŠ¤íƒ ê²°ê³¼ì´ë‹¤. ìœ„ë¡œ ìŒ“ì´ëŠ” ìŠ¤íƒì´ë‹¤. í¬ë¡¬ì—ì„œ show ignore-listed framesë¥¼ ì²´í¬í•´ì•¼ ë³´ì´ë‹ˆ ì°¸ê³ ...

<div className="flex items-start not-prose">
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">1. App ë Œë”ë§ ì¤‘</p>
    <Image src={renderStack} alt="render stack" className="object-contain"/>
  </div>
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">2. DOM ë Œë”ë§ ì¤‘</p>
    <Image src={domStack} alt="dom stack"  className="object-contain" />
  </div>
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">3. ì´í™íŠ¸ ì‹¤í–‰ ì¤‘</p>
    <Image src={effectStack} alt="effect stack" className="object-contain" />
  </div>
</div>

ë²Œì¨ë¶€í„° ê° í•¨ìˆ˜ì˜ ì—­í• ì„ ë³´ê¸°ì—ëŠ” ì¢€ ì••ë„...ë˜ê³  ê° í•¨ìˆ˜ ì„¤ëª…ì€ ë¦¬ì•¡íŠ¸19ê°€ ê·¸ëŸ°ê°€ ë‚´ ê°œë°œí™˜ê²½ë•Œë¬¸ì¸ê°€ ê²Œì‹œë¬¼ê³¼ ê½¤ ë‹¬ë¼ì„œ phaseë³„ ì„¤ëª…ë§Œ ì´í•´í•˜ê³  ë„˜ì–´ê°€ì. 

1. **íŠ¸ë¦¬ê±°(Trigger)**: ì´ˆê¸° ë§ˆìš´íŠ¸ë“  state hookìœ¼ë¡œ ì¸í•œ ì¬ë Œë”ë§ì´ë“  ìƒê´€ì—†ì´, ì•±ì˜ ì–´ëŠ ë¶€ë¶„ì„ ë Œë”ë§í•´ì•¼ í•˜ëŠ”ì§€ì™€ ì–´ë–»ê²Œ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ”ì§€ë¥¼ React ëŸ°íƒ€ì„ì— ì•Œë ¤ì¤Œ.

2. **ìŠ¤ì¼€ì¤„(Schedule)**: ê¸°ë³¸ì ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì‘ì—…ì„ ì²˜ë¦¬í•˜ëŠ” ìš°ì„ ìˆœìœ„ í. ëŸ°íƒ€ì„ ì½”ë“œì—ì„œ ë Œë”ë§ì´ë‚˜ ì´í™íŠ¸ ì‹¤í–‰ê³¼ ê°™ì€ ì‘ì—…ì„ ìŠ¤ì¼€ì¤„ë§í•˜ê¸° ìœ„í•´ í˜¸ì¶œëœë‹¤. 

3. **ë Œë”(Render)**: ìƒˆë¡œìš´ íŒŒì´ë²„ íŠ¸ë¦¬ë¥¼ ê³„ì‚°í•˜ê³  í˜¸ìŠ¤íŠ¸ DOMì— ì ìš©í•´ì•¼ í•  ì—…ë°ì´íŠ¸ê°€ ë¬´ì—‡ì¸ì§€ íŒŒì•…í•œë‹¤. **íŒŒì´ë²„ íŠ¸ë¦¬**ëŠ” ì•±ì˜ í˜„ì¬ ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‚´ë¶€ íŠ¸ë¦¬ êµ¬ì¡°ì´ë‹¤. **ì´ì „ì—ëŠ” ê°€ìƒ DOMì´ë¼ê³  ë¶ˆë ¸ì§€ë§Œ, ì´ì œëŠ” DOMë§Œì„ ìœ„í•œ ê²ƒì´ ì•„ë‹ˆë©° React íŒ€ì—ì„œë„ ë” ì´ìƒ ê°€ìƒ DOMì´ë¼ê³  ë¶€ë¥´ì§€ ì•ŠëŠ”ë‹¤**.
Concurrent ëª¨ë“œ ë•Œë¬¸ì— ë Œë” ë‹¨ê³„ê°€ ì¤‘ë‹¨ë˜ê³  ì¬ê°œë  ìˆ˜ ìˆì–´ì„œ ìƒë‹¹íˆ ë³µì¡í•´ì¡Œë‹¤.

4. **ì»¤ë°‹(Commit)**: í˜¸ìŠ¤íŠ¸ DOMì— ë³€ê²½ì‚¬í•­ì„ ì ìš©í•œë‹¤. ì´ì™¸ì—ë„ ëª¨ë“  ì¢…ë¥˜ì˜ ì´í™íŠ¸ë“¤ë„ ì—¬ê¸°ì„œ ì²˜ë¦¬ëœë‹¤.

## 2. ì´ˆê¸° ë§ˆìš´íŠ¸ëŠ” ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ë¦¬ì•¡íŠ¸ê°€ ì´ˆê¸° ë Œë”ë§ì„ í•  ë•Œ DOM íŠ¸ë¦¬ë¥¼ ì–´ë–»ê²Œ êµ¬ì„±í•˜ëŠ”ì§€ ì•Œì•„ë´…ë‹ˆë‹¤.

ì•„ë˜ ê°„ë‹¨í•œ ì½”ë“œì˜ **ì´ˆê¸° ë Œë” ê³¼ì •**ì„ ì‚´í´ë³´ì. ë²„íŠ¼ì„ ëˆŒëŸ¬ setCountê°€ ë˜ì–´ ë¦¬ë Œë”ë§ì´ ë˜ëŠ” ê²½ìš°ëŠ” 3ê°•ì—ì„œ ì‚´í´ë³¼ ì˜ˆì •.

```js
// [!code highlight:3]
// ë¦¬ì•¡íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ê°€ì ¸ë‹¤ ì“°ëŠ” í•¨ìˆ˜ ì¢…ë¥˜ëŠ” ìƒê°ë³´ë‹¤ ì ë‹¤.
import ReactDOM from "react-dom/client";
import { useState } from "react";

function Link() {
  return <a href="https://yeolyi.com">yeolyi.com</a>;
}

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>
        <Link />
        <br />
        <button onClick={() => setCount((count) => count + 1)}>
          click me - {count}
        </button>
      </p>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

### ReactDOMëŠ” ìƒê°ë³´ë‹¤ ë‹¨ìˆœí•˜ë‹¤

'react-dom/client'ì˜ ì§„ì…ì ì„ ì‚´í´ë³´ì. ì•„ì£¼ ë‹¨ìˆœí•˜ë‹¤!

```js
export {createRoot, hydrateRoot, version} from './src/client/ReactDOMClient';
```

`hydrateRoot`ëŠ” SSR ê´€ë ¨ì¸ ê²ƒ ê°™ê³  `version`ì€ ê·¸ëƒ¥ stringì´ë‹¤. ìš°ë¦¬ì˜ ê´€ì‹¬ì‚¬ì¸ `createRoot`ë¥¼ ì‚´í´ë³´ì.

```js
import {
  createContainer,
  updateContainer,
} from 'react-reconciler/src/ReactFiberReconciler';

function ReactDOMRoot(internalRoot: FiberRoot) {
  this._internalRoot = internalRoot;
}

// í´ë˜ìŠ¤ê°€ ì•„ë‹ˆë¼ í”„ë¡œí† íƒ€ì…ì„ ì“´ê²Œ ì‹ ê¸°í•˜ë‹¤.
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children: ReactNodeList): void {
    const root = this._internalRoot;
    // [!code highlight:3] 
    // ì²«ë²ˆì§¸ ì¸ìë¡œ ìš°ë¦¬ê°€ ê±´ë„¨ <App/>,
    // ë‘ë²ˆì§¸ ì¸ìë¡œ createContainerì˜ ë°˜í™˜ê°’ì´ ë“¤ì–´ê°„ë‹¤.
    updateContainer(children, root, null, null);
  };

export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  const root = createContainer(container, ...);
  return new ReactDOMRoot(root);
}
```

ì´ë ‡ê²Œ ë³´ë©´ ReactDOMì€ ì‚¬ì‹¤ìƒ `createContainer`ì™€ `updateContainer`ë¥¼ í˜¸ì¶œí•´ì£¼ëŠ” ë˜í¼ ê°ì²´ ëŠë‚Œì´ë‹¤. ì–˜ë„¤ë“¤ì€ react-reconciler íŒ¨í‚¤ì§€ì—ì„œ ê°€ì ¸ì˜¤ëŠ”ë° ì´ê±´ ë­í•˜ëŠ” íŒ¨í‚¤ì§€ì¼ê¹Œ?

**react-reconciler**ëŠ” Reactì˜ ìƒíƒœ ë³€í™”ì™€ ì»´í¬ë„ŒíŠ¸ íŠ¸ë¦¬ ì—…ë°ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•µì‹¬ ì—”ì§„(Fiber ì•Œê³ ë¦¬ì¦˜) ì„ êµ¬í˜„í•œ íŒ¨í‚¤ì§€ë¡œ, ReactDOMì„ í¬í•¨í•œ ëª¨ë“  ê³µì‹ ë Œë”ëŸ¬ë“¤ì´ ë‚´ë¶€ì—ì„œ ì´ë¥¼ ì‚¬ìš©í•œë‹¤ê³  í•œë‹¤. ReactDOMì€ DOM ì¡°ì‘ ë°©ì‹ë§Œ ì •ì˜í•œ `HostConfig`ë¥¼ ì œê³µí•˜ê³ , react-reconcilerëŠ” ì´ ì„¤ì •ì„ ê¸°ë°˜ìœ¼ë¡œ ì–´ë–¤ ìš”ì†Œë¥¼ ì–¸ì œ ë§Œë“¤ê³  ì—…ë°ì´íŠ¸í• ì§€ ê³„ì‚°í•˜ì—¬ ì‹¤ì œ DOM ì‘ì—…ì„ ìœ„ì„í•œë‹¤. **ì¦‰, react-reconcilerëŠ” Reactì˜ ë Œë”ë§ ë¡œì§ì„ í”Œë«í¼ê³¼ ë¶„ë¦¬í•´ ê³µí†µí™”í•˜ê³ , ë‹¤ì–‘í•œ í™˜ê²½ì— ëŒ€ì‘ ê°€ëŠ¥í•œ ìœ ì—°í•œ ë Œë”ëŸ¬ êµ¬ì¡°ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•´ì¤€ë‹¤**.

ê·¼ë° ReactDOMìª½ ì½”ë“œë¥¼ ë³´ë©´ ì•Œê² ì§€ë§Œ ì € `HostConfig`ë¼ëŠ”ê±¸ ì„¤ì •í•˜ëŠ” ë¶€ë¶„ì„ ì°¾ì•„ë³¼ ìˆ˜ ì—†ë‹¤. ëƒ…ë‹¤ react-reconciler íŒ¨í‚¤ì§€ë¥¼ ê°€ì ¸ë‹¤ ì“°ëŠ”ë° DOM ê´€ë ¨ëœ ì½”ë“œëŠ” ì–´ë””ìˆëŠ”ê±¸ê¹Œ??

react-reconcilerì˜ ì•„ë˜ íŒŒì¼ì„ ë³´ë©´ ì•Œ ìˆ˜ ìˆë‹¤:

```js
// react-reconciler/src/ReactFiberConfig.js

// [!code highlight:7]
// We expect that our Rollup, Jest, and Flow configurations
// always shim this module with the corresponding host config
// (either provided by a renderer, or a generic shim for npm).
//
// We should never resolve to this file, but it exists to make
// sure that if we *do* accidentally break the configuration,
// the failure isn't silent.

throw new Error('This module must be shimmed by a specific renderer.');

```

ReactDOMë¥¼ ë¹Œë“œí•  ë•Œ ë°”ê¿”ì¹˜ê¸°?ê°€ ë˜ë‚˜ë³´ë‹¤. ìƒìƒë„ ëª»í•œ ë°©ë²•ì´ë¼ì„œ ì°¾ëŠ”ë° í•œì°¸ ê±¸ë ¸ë‹¤... ì™œ ì™¸ë¶€ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ì£¼ì…í•˜ì§€ ì•Šê³  ì´ëŸ° ë°©ì‹ì„ ì‚¬ìš©í–ˆëŠ”ì§€ëŠ” ì•„ì§ ëª¨ë¥´ê² ë‹¤. ì´ì •ë„ë§Œ ë³´ê³  ë„˜ì–´ê°€ì. 

### Trigger phase

ì¶œë°œì ì€ ReactDOMì´ì§€ë§Œ ì§„ì§œ ì¤‘ìš”í•œ ë Œë”ë§ ë¡œì§ì€ react-reconciler íŒ¨í‚¤ì§€ì— ìˆìŒì„ í™•ì¸í–ˆë‹¤. ì•„ë˜ ì½”ë“œê°€ ì‹¤í–‰ë˜ì–´ ì´ˆê¸° ë Œë”ë¥¼ íŠ¸ë¦¬ê±°í•˜ë©´(trigger phase) ê²°ê³¼ì ìœ¼ë¡œëŠ” react-reconcilerì˜ `createContainer`ì™€ `updateContainer` í•¨ìˆ˜ê°€ í˜¸ì¶œë¨ë„ í™•ì¸í–ˆë‹¤. ë‘ í•¨ìˆ˜ë¥¼ ì‚´í´ë³´ì. 

```js
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

ìš°ì„  `createContainer`. íŒŒì´ë²„ íŠ¸ë¦¬ì˜ ë‘ ë…¸ë“œë¥¼ ë§Œë“ ë‹¤.

```js
export function createContainer(
  containerInfo: Container,
  ...
): OpaqueRoot {
  return createFiberRoot(
    containerInfo,
    ...
  );
}

export function createFiberRoot(
  containerInfo: Container,
  ...
): FiberRoot {
  const root: FiberRoot = (new FiberRootNode(
    containerInfo,
    ...
  ): any);

  // [!code highlight:3]
  //      FiberRootNode
  //  .current â¬‡ï¸ â¬†ï¸ .stateNode
  //      HostRootFiber
  const uninitializedFiber = createHostRootFiber(tag, isStrictMode);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  return root;
}
```

createRootì˜ ë°˜í™˜ê°’ì„ í”„ë¦°íŠ¸í•´ë³´ë©´ `FiberRootNode`ì˜ `current`ê°€ `FiberNode`ì„ì„ í™•ì¸í•´ë³¼ ìˆ˜ ìˆë‹¤. 

<Image src={fiberRoot1} alt="fiber root"/>

ì´ì œ `updateContainer`ë¥¼ ì‚´í´ë³´ì. **FiberRootNodeì™€ ìš°ë¦¬ê°€ `render` í•¨ìˆ˜ì— ê±´ë„¤ì¤¬ë˜ `<App/>`ì„ ì—…ë°ì´íŠ¸ íì— ë„£ëŠ”ë‹¤**.

```js
// react-reconciler/src/ReactFiberReconciler.js
export function updateContainer(
  // [!code highlight:2]
  element: ReactNodeList, // ìš°ë¦¬ê°€ ê±´ë„¨ <App/>
  container: OpaqueRoot, // FiberRootNode
  ...
): Lane {
  // [!code highlight:2]
  // HostRootFiberì„ì„ ì•„ê¹Œ ì‚´í´ë´¤ë‹¤.
  const current = container.current;
  const lane = requestUpdateLane(current);
  updateContainerImpl(
    current,
    lane,
    element,
    container,
    parentComponent,
    callback,
  );
  return lane;
}
```

```js
function updateContainerImpl(
  // [!code highlight]
  rootFiber: Fiber, // HostRootFiber
  lane: Lane,
  // [!code highlight:2]
  element: ReactNodeList, // ìš°ë¦¬ê°€ ê±´ë„¨ <App/>
  container: OpaqueRoot, // FiberRootNode
  ...
): void {

  // [!code highlight:5]
  // ìš°ë¦¬ê°€ ê±´ë„¨ <App/>ì„ ì—…ë°ì´íŠ¸ íì— ë„£ëŠ”ë‹¤.
  const update = createUpdate(lane);
  update.payload = {element};

  const root = enqueueUpdate(rootFiber, update, lane);

  if (root !== null) {
    startUpdateTimerByLane(lane);
    scheduleUpdateOnFiber(root, rootFiber, lane);
    entangleTransitions(root, rootFiber, lane);
  }
}
```

### Schedule phase

ì—…ë°ì´íŠ¸ íì— ë„£ì€ ì‘ì—…ì€ `performWorkOnRoot`ì—ì„œ ì²˜ë¦¬ëœë‹¤ê³  í•œë‹¤. ì–´ë–»ê²Œ íê°€ ê´€ë¦¬ë˜ë©° `performWorkOnRoot`ê°€ ì‹¤í–‰ë˜ëŠ”ì§€ëŠ” ë‚˜ì¤‘ì— ì•Œì•„ë³´ê³  ì¼ë‹¨ ë°›ì•„ë“¤ì´ì. 

ë‹¤ë§Œ 1ê°•ì—ì„œ breakpoint ê±¸ê³  stack traceë´¤ì„ ë•Œ ì´ë¯¸ì§€ë¥¼ ì°¸ê³ í•˜ë©´ ì•„ë˜ ê²½ë¡œë¡œ í˜¸ì¶œë¨ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. 

- performWorkUntilDeadline
  - performWornOnRootViaSchedularTask
    - **performWorkOnRoot**

### Render phase

`performWorkOnRoot`ì„ ì‚´í´ë³´ì:

```js
export function performWorkOnRoot(
  root: FiberRoot,
  lanes: Lanes,
  forceSync: boolean,
): void {
  const shouldTimeSlice =
    (!forceSync &&
      // [!code highlight:2]
      // ë¡œê·¸ ì°ì–´ë³´ë‹ˆ ì´ˆê¸° ë Œë”ì—ì„œëŠ” blocking laneì´ í¬í•¨ë¼ì„œ 
      // shouldTimeSliceê°€ falseê°€ ë˜ê³ ...
      !includesBlockingLane(lanes) &&
      !includesExpiredLane(root, lanes)) ||
    (enableSiblingPrerendering && checkIfRootIsPrerendering(root, lanes));

  let exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    // [!code highlight:3]
    // ì´ê²Œ ì‹¤í–‰ëœë‹¤.
    : renderRootSync(root, lanes, true);

  // ë’¤ì—ë„ ë­ê°€ ì—„~ì²­ ë§ë‹¤.
}
```

ì½œ ìŠ¤íƒì—ì„œ `renderRootSync` ì´í›„ì—ëŠ” ì•„ë˜ í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ìˆœì„œëŒ€ë¡œ ì‚´í´ë³´ì. 

- `renderRootSync`
  - `workLoopSync`
    - `performUnitOfWork`
      - `beginWork`
        - `updateFunctionComponent`
          - `renderWithHooks`
            - `App` ì»´í¬ë„ŒíŠ¸

`renderRootSync`ì—ì„œëŠ” `prepareFreshStack`ì—ì„œ ìƒˆë¡œìš´ ìŠ¤íƒ?ì„ ì¤€ë¹„í•˜ê³  `workLoopSync`ë¥¼ í˜¸ì¶œí•œë‹¤. 

```js
function renderRootSync(
  root: FiberRoot,
  lanes: Lanes,
  shouldYieldForPrerendering: boolean,
): RootExitStatus {
  // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // [!code highlight]
    prepareFreshStack(root, lanes);
  }

  do {
    try {
      // [!code highlight]
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleThrow(root, thrownValue);
    }
  } while (true);
}
```

`prepareFreshStack`ì—ì„œëŠ” `workInProgress` ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•œë‹¤. ë¦¬ì•¡íŠ¸ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ìƒíƒœë¥¼ í‘œí˜„í•  ë•Œ Fiber íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©° ì—…ë°ì´íŠ¸ê°€ ë°œìƒí•˜ë©´ ìƒˆë¡œìš´ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ ê¸°ì¡´ íŠ¸ë¦¬ì™€ ë¹„êµí•œ ë’¤ ë³€ê²½ì‚¬í•­ì„ ë°˜ì˜í•œë‹¤. **ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ì½”ë“œì—ì„œ `current`ëŠ” ê¸°ì¡´ íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•˜ê³  `workInProgress`ë¡œ ìƒˆë¡œìš´ íŠ¸ë¦¬ë¥¼ ì˜ë¯¸í•œë‹¤.** 

ì´ˆê¸° ë Œë”í•˜ëŠ” ì§€ê¸ˆ currentëŠ” createContainerì—ì„œ ë§Œë“  HostRootFiberë¥¼ ê°€ë¦¬í‚¨ë‹¤. 

```js
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  // [!code highlight:2]
  // ì•„~ê¹Œ ì‚´í´ë´¤ë“¯ì´ FiberRootì˜ currentëŠ” HostRootFiber
  const rootWorkInProgress = createWorkInProgress(root.current, null);
}

export function createWorkInProgress(current: Fiber, pendingProps: any): Fibers {
  // ë¦¬ì•¡íŠ¸ ì†ŒìŠ¤ì½”ë“œì—ëŠ” ì´ëŸ° ì‹ìœ¼ë¡œ ê°‘ìê¸° íŠ€ì–´ë‚˜ì˜¤ëŠ” ì „ì—­ë³€ìˆ˜ê°€ ëª‡ ê°œ ìˆì–´ 
  // ì²˜ìŒì— ì½”ë“œ íë¦„ì„ íŒŒì•…í•  ë•Œ ì‹ ê²½ì¨ì•¼ê² ë‹¤ê³  ëŠê¼ˆë‹¤. 
  workInProgress = createFiber(
      // [!code highlight:2]
      // HostRootFiberì™€ ë™ì¼í•œ íƒœê·¸ë¥¼ ì‚¬ìš©í•´ workInProgressë¥¼ ë§Œë“ ë‹¤. 
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
}
```

`workLoopSync`ì—ì„œëŠ” `workInProgress`ê°€ nullì´ ì•„ë‹ ë•Œê¹Œì§€ `performUnitOfWork`ë¥¼ í˜¸ì¶œí•œë‹¤. ì´ëŠ” performUnitOfWork í˜¸ì¶œ í›„ ì–´ë”˜ê°€ì—ì„œëŠ” `workInProgress`ë¥¼ ì„¤ì •í•´ ë‹¤ìŒ ì‘ì—…ì„ ì§€ì •í•´ì¤˜ì•¼í•¨ì„ ì•”ì‹œí•œë‹¤. ë˜í•œ `workInProgress`ë¥¼ ìƒˆë¡œìš´ íŠ¸ë¦¬ ë…¸ë“œë¥¼ í–¥í•œ í¬ì¸í„°ë¡œ í™œìš©í•´ íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.

```js
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

ë³´í†µ íŠ¸ë¦¬ ìˆœíšŒëŠ” ì¬ê·€ë¡œ êµ¬í˜„í•˜ëŠ”ë° whileë¡œ êµ¬í˜„í•œê²Œ ì¸ìƒê¹Šë‹¤. ë¶€ëª¨ ë…¸ë“œë¥¼ í–¥í•œ í¬ì¸í„°ë¥¼ ì–´ë”˜ê°€ì—ì„œ ê´€ë¦¬í•˜ê¸°ì— ê°€ëŠ¥í•œ êµ¬í˜„ì´ ì•„ë‹ê¹Œ. ìì‹ ë…¸ë“œë¡œ ë‚´ë ¤ê°„ ë’¤ì— ì–¸ì  ê°€ëŠ” ë‹¤ì‹œ ì˜¬ë¼ì™€ì•¼í•˜ë‹ˆ... ì¬ê·€ êµ¬í˜„ì—ì„œëŠ” ì½œ ìŠ¤íƒì´ ê·¸ ì—­í• ì„ í•˜ì§€ë§Œ ì´ë ‡ê²Œ whileë¡œ êµ¬í˜„í–ˆë‹¤ë©´ ê·¸ ì—­í• ì„ ë‹¤ë¥¸ ë¬´ì–¸ê°€ê°€ í•´ì£¼ì–´ì•¼í•œë‹¤. 

ì‹¤ì œë¡œ Fiberì˜ êµ¬í˜„ì„ ë³´ë©´ **singly linked list tree structure**ë¡œ êµ¬ì„±ë˜ì–´ìˆë‹¤. **ë³´í†µ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ê°€ ìì‹ ë…¸ë“œì˜ ë°°ì—´ë¡œ ê´€ë¦¬ë˜ëŠ” ê²ƒê³¼ ë‹¤ë¥´ê²Œ í˜•ì œ ë…¸ë“œì˜ ì£¼ì†Œë§Œ ê´€ë¦¬í•œë‹¤.**

```js
// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
export type Fiber = {
  // The Fiber to return to after finishing processing this one.
  // This is effectively the parent, but there can be multiple parents (two)
  // so this is only the parent of the thing we're currently processing.
  // It is conceptually the same as the return address of a stack frame.
  return: Fiber | null,

  // Singly Linked List Tree Structure.
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,
};
```

`performUnitOfWork`ì—ì„œëŠ” í˜„ì¬ workInProgressê°€ ê°€ë¥´í‚¤ê³  ìˆëŠ” ë…¸ë“œì— ëŒ€í•´ `beginWork`ë¥¼ í˜¸ì¶œí•œë‹¤. nullì„ ë°˜í™˜í–ˆë‹¤ë©´ ë” `completeUnitOfWork`ë¥¼ í˜¸ì¶œí•œë‹¤.

(beginWork, completeWorkë©´ ì´ë¦„ ì§ì´ ë§ëŠ”ë° ì™œ completeUnitOfWorkë¼ê³  í–ˆì„ê¹Œ?)

```js
function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  const current = unitOfWork.alternate;

  // [!code highlight]
  const next = beginWork(current, unitOfWork, entangledRenderLanes);

  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    // [!code highlight]
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

`beginWork`ëŠ” ì‚¬ì‹¤ìƒ ì»¤ë‹¤ë€ switch-caseë¬¸ìœ¼ë¡œ workInProgressì˜ tagì— ë”°ë¼ ì„œë¡œ ë‹¤ë¥¸ update í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•Ÿë‚˜. 

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  // [!code highlight]
  switch (workInProgress.tag) {
    // ì´ë²ˆì— ì‚´í´ë³¼ tagë“¤ë§Œ ë‚¨ê²¨ë³´ì•˜ë‹¤.
    case FunctionComponent: {
      ...
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    case HostText:
      return updateHostText(current, workInProgress);
    ...
  }
}
```

`<App/>` ì»´í¬ë„ŒíŠ¸ë¥¼ ë Œë”í•  ë•Œ ë¡œê·¸ë¥¼ ì°ì–´ë³´ë©´ ì•„ë˜ ìˆœì„œë‹¤. 

```text
3 0 5 5 0 5 5 5 6 6
```

ê° íƒœê·¸ì˜ ëœ»ì€ `react/packages/react-reconciler/src/ReactWorkTags.js`ì— ì •ì˜ë˜ì–´ ìˆë‹¤.

```js
export const FunctionComponent = 0;
export const HostRoot = 3; 
export const HostComponent = 5;
export const HostText = 6;
```

í•´ì„í•˜ë©´ ì´ëŸ° ìˆœì„œì´ë‹¤. a í•˜ìœ„ í…ìŠ¤íŠ¸ëŠ” ë”°ë¡œ ìˆœíšŒí•˜ì§€ ì•Šì§€ë§Œ buttonì˜ í•˜ìœ„ í…ìŠ¤íŠ¸ëŠ” ìˆœíšŒí•¨ì„ ëˆˆì—¬ê²¨ë³´ì.

```txt
HostRoot
FunctionComponent (App)
HostComponent (div)
HostComponent (p)
FunctionComponent (Link)
HostComponent (a)
HostComponent (br)
HostComponent (button)
HostText (click me -)
HostText ({count})
```

ì°¸ê³ ë¡œ Appì€ ì´ë ‡ê²Œ ìƒê²¼ì—ˆë‹¤:

```js
function Link() {
  return <a href="https://yeolyi.com">yeolyi.com</a>;
}

export default function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>
        <Link />
        <br />
        <button onClick={() => setCount((count) => count + 1)}>
          click me - {count}
        </button>
      </p>
    </div>
  );
}
```

ì´ë¥¼í†µí•´ render phaseì—ì„œëŠ” `workInProgress` ë³€ìˆ˜ë¥¼ í¬ì¸í„°ì‚¼ì•„ DFS ìˆœì„œë¡œ Fiberë¥¼ ìˆœíšŒí•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.

ë‹¤ì‹œ ëŒì•„ì™€ì„œ `beginWork`ì˜ caseë¬¸ë“¤ ì¤‘ ë§¨ ì²˜ìŒ í˜¸ì¶œë˜ëŠ”ê±´ íŠ¸ë¦¬ ìµœìƒë‹¨ì— ìˆëŠ” HostRootFiberì¼í…Œë‹ˆ `updateHostRoot`ë¥¼ ì‚´í´ë³´ì.

```js
function updateHostRoot(
  // updateContainerì—ì„œ ì—…ë°ì´íŠ¸ íì— ë„£ì–´ë‘” HostRootFiber
  current: null | Fiber,
  // prepareFreshStackì—ì„œ ë§Œë“  HostRootFiber
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  // [!code highlight:3]
  // trigger phaseì—ì„œ ë„˜ê²¼ë˜ ë°ì´í„°ë¥¼ ì¶”ì¶œí•´ 
  // workInProgressì˜ memoizedStateì— í• ë‹¹í•œë‹¤.
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);

  const nextState: RootState = workInProgress.memoizedState;
  // [!code highlight:2]
  // root.renderì— ë„˜ê²¼ë˜ elementì„ ì–»ì–´ëƒˆë‹¤!
  const nextChildren = nextState.element;

  if (supportsHydration && prevState.isDehydrated) {
  } else {
    // Root is not dehydrated. Either this is a client-only root, or it
    // already hydrated.
    resetHydrationState();
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    // [!code highlight]
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }
  return workInProgress.child;
}
```

ë¦¬ì•¡íŠ¸ì—ì„œ `reconcile`ì€ `diff`ì™€ ë¹„ìŠ·í•œ ì˜ë¯¸ë¡œ ì‚¬ìš©ëœë‹¤. ë‘ Fiber ë…¸ë“œë¥¼ ë¹„êµí•´ ë³€ê²½ì‚¬í•­ì„ ì–´ë–»ê²Œ ë°˜ì˜í•˜ë©´ ë ì§€ íŒë‹¨í•˜ê³  `workInProgress.child`ë¥¼ ì„¤ì •í•´ íŠ¸ë¦¬ ìˆœíšŒê°€ ì´ì–´ì§€ë„ë¡ í•œë‹¤. ì•„ë˜ ì½”ë“œì—ì„œ ë³´ë“¯ì´ currentì˜ ìƒíƒœì— ë”°ë¼ ë‘ í•¨ìˆ˜ ì¤‘ í•˜ë‚˜ë¥¼ í˜¸ì¶œí•œë‹¤.

```js
export function reconcileChildren(
  // updateContainerì—ì„œ ì—…ë°ì´íŠ¸ íì— ë„£ì–´ë‘” HostRootFiber
  current: Fiber | null,
  // prepareFreshStackì—ì„œ ë§Œë“  HostRootFiber
  workInProgress: Fiber,
  // <App/>
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // currentê°€ nullì´ ì•„ë‹ˆë¯€ë¡œ ì—¬ê¸°ë¡œ ê°„ë‹¤.
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      // [!code highlight:2]
      // currentê°€ ì•„ë‹Œ current.childë¥¼ ë„˜ê²¨ì¤€ë‹¤.
      // workInProgress.childë¥¼ current.childì™€ ë¹„êµí•´ ë§Œë“ ë‹¤.
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

ë‘ í•¨ìˆ˜ëŠ” `createChildReconciler`ì— ì „ë‹¬ë˜ëŠ” ì¸ìë§Œ ë‹¤ë¥´ë‹¤. 

```js
export const reconcileChildFibers: ChildReconciler =
  createChildReconciler(true);
export const mountChildFibers: ChildReconciler = createChildReconciler(false);
```

`createChildReconciler`ëŠ” 1600ì¤„ì´ ë„˜ëŠ” í•¨ìˆ˜ì´ë‹¤... `reconcileChildFibers`ë©´ `shouldTrackSideEffects`ê°€ true, `shouldTrackSideEffects`ê°€ falseì´ë‹¤. ì›ë˜ ì—†ë˜ Fiber ë…¸ë“œë¥¼ ì¶”ê°€í•˜ëŠ” ê²½ìš°ì—ëŠ” side effect (ìì‹ì´ ë°”ë€Œì—ˆë‹¤ë˜ê°€)ê°€ ìˆì„ ìˆ˜ ì—†ê³  ê·¸ëƒ¥ ìƒˆë¡œ ë¶™ì´ë©´ ë˜ë¯€ë¡œ ë”°ë¡œ side effectë¥¼ ì¶”ì í•˜ì§€ ì•ŠìŒìœ¼ë¡œì„œ ìµœì í™”í•˜ëŠ” ê²ƒì´ë‹¤.

```js
function createChildReconciler(
  shouldTrackSideEffects: boolean,
): ChildReconciler {
  function deleteChild(){}
  function deleteRemainingChildren(){}
  ...
  function placeChild(){}
  function placeSingleChild(){}
  function updateTextNode(){}
  function updateElement(){}
  ...
  function createChild(){}
  ...
  function reconcileChildrenArray(){}
  ...
  function reconcileSingleTextNode(){}
  function reconcileSingleElement(){}
  ...

  // [!code highlight:4]
  function reconcileChildFibersImpl(){}
  function reconcileChildFibers(){}

  return reconcileChildFibers;
}
```

`reconcileChildFibers`ëŠ” `reconcileChildFibersImpl`ì„ í˜¸ì¶œí•˜ê³  ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•œê±°ë‹¤. ë°”ë¡œ `reconcileChildFibersImpl`ì„ ì‚´í´ë³´ì:

```js  
function reconcileChildFibersImpl(
  // [!code highlight:3]
  // workInProgressê°€ returnFiberë¡œ ì´ë¦„ì´ ë°”ë€Œì—ˆë‹¤.
  // í˜„ì¬ ì²˜ë¦¬ì¤‘ì¸ Fiberì˜ ë¶€ëª¨ ë…¸ë“œê°€ ë  ê²ƒì´ë‹ˆ ë§ê¸´í•˜ë‹¤.
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
  lanes: Lanes,
): Fiber | null {
  // Handle object types
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      // [!code highlight:15]
      // ì—¬ê¸°ì„œëŠ” React Elementë¥¼ ì²˜ë¦¬í•œë‹¤.
      // ì˜ˆë¥¼ ë“¤ì–´ <App/>ì˜ $$typeofëŠ” REACT_ELEMENT_TYPEì´ë‹¤.
      case REACT_ELEMENT_TYPE: {
        const prevDebugInfo = pushDebugInfo(newChild._debugInfo);
        const firstChild = placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );
        currentDebugInfo = prevDebugInfo;
        return firstChild;
      }
      case REACT_PORTAL_TYPE:
        ...
      case REACT_LAZY_TYPE: 
        ...
    }

    if (isArray(newChild)) {
     ...
    }

    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
      ...
    }

    throwOnInvalidObjectType(returnFiber, newChild);
  }

  if (
    (typeof newChild === 'string' && newChild !== '') ||
    typeof newChild === 'number' ||
    typeof newChild === 'bigint'
  ) {
    // [!code highlight:8]
    // ì—¬ê¸°ì„œëŠ” í…ìŠ¤íŠ¸ ë…¸ë“œë¥¼ ì²˜ë¦¬í•œë‹¤.
    return placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes,
      ),
    );
  }

  // Remaining cases are all treated as empty.
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

`$$typeof`ê°€ ë‚˜ì˜¨ê¹€ì— ì‚´í´ë³´ìë©´ `shared/ReactSymbols.js`ì— ì•„ë˜ì™€ ê°™ì´ ì´ê²ƒì €ê²ƒ ì‹¬ë³¼ë¡œ ì •ì˜ë˜ì–´ìˆë‹¤:

```js
// The Symbol used to tag the ReactElement-like types.
export const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');
export const REACT_ELEMENT_TYPE: symbol = renameElementSymbol
  ? Symbol.for('react.transitional.element')
  : REACT_LEGACY_ELEMENT_TYPE;
export const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');
export const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');
...
```

ì‚¬ì‹¤ ë©€ë¦¬ê°€ì§€ ì•Šê³  `console.log(<App/>)`ë§Œ ì°ì–´ë´ë„ ë°”ë¡œ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

<Image src={typeOfSymbol} alt=""/>

`$$typeof`ì— ëŒ€í•œ ë” ë§ì€ ë‚´ìš©ì€ https://overreacted.io/why-do-react-elements-have-typeof-property/ ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

ì•”íŠ¼ ë‹¤ì‹œ ëŒì•„ì™€ì„œ, `reconcileChildFibersImpl`ì—ì„œ Elementë¥¼ ì²˜ë¦¬í•  ë–„ í˜¸ì¶œí•˜ëŠ” `reconcileSingleElement`ê³¼ `placeSingleChild`ë¥¼ ì‚´í´ë³´ì. ìš°ì„  `reconcileSingleElement`:

```js
  function reconcileSingleElement(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    element: ReactElement,
    lanes: Lanes,
  ): Fiber {
    const key = element.key;
    let child = currentFirstChild;
    while (child !== null) {
      // ì´ˆê¸° ë Œë”ì‹œì—ëŠ” childê°€ nullì´ë¯€ë¡œ í•´ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤.
      ...
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      ...
    } else {
      // [!code highlight:4]
      const created = createFiberFromElement(element, returnFiber.mode, lanes);
      coerceRef(created, element);
      created.return = returnFiber;
      return created;
    }
  }
```

ê°„ë‹¨í•˜ë‹¤. `createFiberFromElement`ë¡œ ìƒˆë¡œìš´ Fiberë¥¼ ë§Œë“¤ì–´ returnFiberì˜ ìì‹ ë…¸ë“œë¡œ ë§Œë“¤ê³  ë°˜í™˜í•œë‹¤. Fiberë¥¼ ë§Œë“œëŠ” ê³¼ì •ì„ ì‚´í´ë³´ì.

```js
export function createFiberFromElement(
  element: ReactElement,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  const fiber = createFiberFromTypeAndProps(...);
  return fiber;
}

export function createFiberFromTypeAndProps(
  type: any, // React$ElementType
  key: null | string,
  pendingProps: any,
  owner: null | ReactComponentInfo | Fiber,
  mode: TypeOfMode,
  lanes: Lanes,
): Fiber {
  let fiberTag = FunctionComponent;
  ...
  // [!code highlight]
  const fiber = createFiber(fiberTag, pendingProps, key, mode);
  ...
  return fiber;
}
```

`react-reconciler/src/ReactFiber.js`ë¡œ ê±´ë„ˆê°€ë©´ `createFiber`ë¥¼ ë³¼ ìˆ˜ ìˆë‹¤. íŠ¹ë³„í• ê±´ ì—†ë‹¤.

```js
// [!code highlight:2]
// ë­”ì§€ëŠ” ëª¨ë¥´ê² ëŠ”ë° ì°ì–´ë³´ë‹ˆ falseì´ë‹¤.
const createFiber = enableObjectFiber
  ? createFiberImplObject
  : createFiberImplClass;

function createFiberImplClass(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  return new FiberNode(tag, pendingProps, key, mode);
}

// [!code highlight:4]
// thisê°€ ì²«ë²ˆì§¸ ì¸ìì¸ë° ì–´ë–»ê²Œ ìˆëŠ”ê±´ì§€ ëª¨ë¥´ê² ë‹¤.
// íŒŒì´ì¬ ê°™ì€ ê²½ìš°ëŠ” í´ë˜ìŠ¤ ë©”ì„œë“œì—ì„œ selfë¥¼ ì²«ë²ˆì§¸ ì¸ìë¡œ ë°›ëŠ”ë°
// ë¹„ìŠ·í•œ ê²½ìš°ì¸ê±¸ê¹Œ? Flow ì–¸ì–´ì˜ ê¸°ëŠ¥ì¸ê°€?
function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // this.xx = yy í˜•íƒœì˜ ê¸¸ê³  ì§€ë£¨í•œ ì½”ë“œ
}
```

ì´ë ‡ê²Œ ë§Œë“  Fiberë¥¼ `placeSingleChild`ì— ë„˜ê²¨ì¤€ë‹¤.

```js
function placeSingleChild(newFiber: Fiber): Fiber {
  // [!code highlight:4]
  // ì•„ê¹Œ reconcile vs mountí•  ë•Œ ë´¤ë˜ shouldTrackSideEffectsê°€ ë‚˜ì˜¨ë‹¤.
  // ì§€ê¸ˆì€ reconcileì¤‘ì´ë¯€ë¡œ trueì´ë¯€ë¡œ newFiberì— flagë¥¼ ì„¸ìš´ë‹¤.
  // newFiber 
  // = createFiberFromElementì—ì„œ ë°˜í™˜í•œê±° 
  // = <App/>ì— ëŒ€í•œ Fiber
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    newFiber.flags |= Placement | PlacementDEV;
  }
  return newFiber;
}
```

í›„! HostRootFiberì— ëŒ€í•œ `renderRootSync`ê°€ ëë‚¬ë‹¤! `renderRootSync`ê°€ ë­ì˜€ëŠ”ì§€ ê°€ë¬¼ê°€ë¬¼í•˜ë‹ˆ ë‹¤ì‹œ ì§€ê¸ˆê¹Œì§€ì˜ ì½œìŠ¤íƒì„ ì‚´í´ë³´ì.

1. `renderRootSync`
2. `workLoopSync`
3. `performUnitOfWork`
4. `beginWork`
5. `updateHostRoot`
6. `reconcileChildren`
7. `reconcileChildFibers` 
8. `reconcileChildFibersImpl`

reconcileChildFibersImplì—ì„œ `placeSingleChild`ì™€ `reconcileSingleElement`ë¥¼ í˜¸ì¶œí•˜ì—¬ ìƒˆë¡œìš´ Fiberë¥¼ ë§Œë“ ë‹¤. ì´ Fiberì˜ íƒœê·¸ëŠ” `createFiberFromTypeAndProps`ì—ì„œ ë´¤ë“¯ì´ **`FunctionComponent`**ì´ë‹¤. 

ì´í›„ `reconcileChildren`ì—ì„œ `workInProgress.child`ë¥¼ ì´ ìƒˆë¡œ ë§Œë“  Fiberë¡œ ì„¤ì •í•œë‹¤. `updateHostRoot`ëŠ” ì´ workInProgress.childë¥¼ ë°˜í™˜í•˜ê³  `beginWork`ëŠ” ì´ë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜í•œë‹¤.

`performUnitOfWork`ì—ì„œëŠ” `beginWork`ì˜ ë°˜í™˜ê°’ì„ ë‹¤ìŒ workInProgressë¡œ ì„¤ì •í•œë‹¤. 

ê²°ê³¼ì ìœ¼ë¡œ ë‹¤ìŒ performUnitOfWorkì—ì„œëŠ” ì´ ìƒˆë¡œ ë§Œë“  Fiberì— ëŒ€í•´ ì‘ì—…ì„ ì‹œì‘í•œë‹¤. 

í•˜ì§€ë§Œ ì´ë²ˆ beginWorkì—ì„œëŠ” `updateFunctionComponent`ê°€ í˜¸ì¶œëœë‹¤:

```js
function beginWork(
  // [!code highlight:4]
  // currentëŠ” ê¸°ì¡´ íŠ¸ë¦¬ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤ê³  í–ˆì—ˆë‹¤.
  // createContainerì—ì„œ HostRootFiberê¹Œì§€ë§Œ ë§Œë“¤ê³  ìì‹ ë…¸ë“œëŠ” ì—†ì—ˆìœ¼ë¯€ë¡œ
  // ì´ì œ currentëŠ” nullì´ë‹¤. 
  current: Fiber | null,

  // [!code highlight:3]
  // ì´ì „ì—ëŠ” HostRootFiberì˜€ì§€ë§Œ
  // ì´ì œëŠ” <App/>ì— ëŒ€ì‘ë˜ëŠ” Fiberê°€ ëœë‹¤.
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  switch (workInProgress.tag) {
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps =
        disableDefaultPropsExceptForClasses ||
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultPropsOnNonClassComponent(Component, unresolvedProps);
      // [!code highlight:7]
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }
    ...
  }
}
```

`updateFunctionComponent`ë¥¼ ì‚´í´ë³´ì:

```js
function updateFunctionComponent(
  // null
  current: null | Fiber,
  // <App/>ì— ëŒ€ì‘ë˜ëŠ” Fiber
  workInProgress: Fiber,
  // App í•¨ìˆ˜
  Component: any,
  nextProps: any,
  renderLanes: Lanes,
) {
  let context;
  let nextChildren;
  let hasId;

  prepareToReadContext(workInProgress, renderLanes);

  // [!code highlight:9]
  // ì—¬ê¸°ì„œëŠ” ìì„¸íˆ ì‚´í´ë³´ì§€ ì•Šê² ì§€ë§Œ
  // ì»´í¬ë„ŒíŠ¸ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œì¼œ Elementë¥¼ ë°˜í™˜ë°›ëŠ”ë‹¤.
  nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes,
  );

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress);
  }

  // [!code highlight:4]
  // currentê°€ nullì´ë¯€ë¡œ ì´ë²ˆì—ëŠ” mountChildFibersê°€ í˜¸ì¶œëœë‹¤.
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  // App í•˜ìœ„ì˜ divê°€ workInProgress.childë¡œ ì„¤ì •ë˜ì—ˆë‹¤.
  return workInProgress.child;
}
```

ë‹¤ìŒ beginWorkë“¤ì—ì„œëŠ” div, pë¥¼ ì²˜ë¦¬í•´ì•¼í•˜ë©° ëª¨ë‘ `updateHostComponent`ê°€ í˜¸ì¶œëœë‹¤. ë‹¤ë§Œ p ë‹¤ìŒì—ëŠ” nextChildrenì´ ë°°ì—´ì´ê¸°ì— `reconcileChildrenArry`ê°€ í˜¸ì¶œë˜ëŠ”ë° ì´ê±´ ë‹¤ìŒì— ì‚´í´ë³´ì. 

`updateHostComponent`ì—ì„œë„ ë˜‘ê°™ì´ `reconcileChildren(current, workInProgress, nextChildren, renderLanes);{:js}`ì„ í˜¸ì¶œí•œë‹¤. ë‹¤ë§Œ aì™€ buttonì—ì„œ ì „ìëŠ” nextChildrenì´ `null`ì´ì§€ë§Œ í›„ìëŠ” `['click me -', 0]`ì´ë‹¤. beginWorkë„ aì˜ ìì‹ í…ìŠ¤íŠ¸ì— ëŒ€í•´ì„œëŠ” ë¶ˆë¦¬ì§€ ì•Šì§€ë§Œ buttonì˜ ìì‹ í…ìŠ¤íŠ¸ë“¤ì— ëŒ€í•´ì„œëŠ” ë‘ ë²ˆ í˜¸ì¶œë˜ì–´ `updateHostText`ë„ ë‘ ë²ˆ í˜¸ì¶œëœë‹¤ëŠ” ì°¨ì´ê°€ ìˆìŒì„ ì•Œì•„ë‘ì. 

ì˜ì™¸ë¡œ `updateHostTest`ëŠ” ë”°ë¡œ FiberNodeë¥¼ ë§Œë“¤ê±°ë‚˜ reconcileí•˜ì§€ ì•Šê³  ê·¸ëƒ¥ ë¦¬í„´í•œë‹¤. í…ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•˜ëŠ” ì‘ì—…ì€ Commit phaseì—ì„œ í•œë‹¤.

```js
function updateHostText(current: null | Fiber, workInProgress: Fiber) {
  if (current === null) {
    tryToClaimNextHydratableTextInstance(workInProgress);
  }
  // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.
  return null;
}
```

ì˜ˆ~ì „ì— `performUnitOfWork`ì—ì„œ `beginWork`ê°€ nullì„ ë°˜í™˜í•˜ë©´ `completeWork`ë¥¼ í˜¸ì¶œí•¨ì„ ì–¸ê¸‰í–ˆë‹¤:

```js
next = beginWork(current, unitOfWork, entangledRenderLanes);

unitOfWork.memoizedProps = unitOfWork.pendingProps;
if (next === null) {
  // If this doesn't spawn new work, complete the current work.
  // [!code highlight]
  completeUnitOfWork(unitOfWork);
} else {
  workInProgress = next;
}
```

ì˜ˆì œì—ì„œ completeWorkëŠ” ì•„ë˜ ìˆœì„œë¡œ í˜¸ì¶œëœë‹¤:

```js
a
Link
br
"click me -"
"0"
button
p
div
App
HostRootFiber
```

`completeUnitOfWork`ì—ì„œ ë§ˆì¹¨ë‚´! DOMì„ ì‹¤ì œë¡œ ìƒì„±í•œë‹¤. ì •í™•íˆëŠ” `completeUnitOfWork`ì—ì„œ í˜¸ì¶œí•œ `completeWork`ì—ì„œ í•˜ëŠ”ë°... `completeUnitOfWork`ëŠ” ì•„ì§ ì˜ ëª¨ë¥´ê² ì–´ì„œ ë°”ë¡œ `completeWork`ë¥¼ ì‚´í´ë³´ì. 900ì¤„ì§œë¦¬ í•¨ìˆ˜ë‹¤...

```js
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    ...
    // [!code highlight:4]
    // ë­”ì§€ ëª¨ë¥´ê² ì§€ë§Œ í•¨ìˆ˜ ì»´í¬ë„ŒíŠ¸ì—ì„œëŠ” ì´ëŸ°ê±¸ í•œë‹¤.
    case FunctionComponent:
       bubbleProperties(workInProgress);
       return null;
    ...
    // [!code highlight:2]
    // HTML íƒœê·¸ë©´ ì—¬ê¸°ë¡œ ì˜¨ë‹¤.
    case HostComponent: {
      popHostContext(workInProgress);
      const type = workInProgress.type;

      // [!code highlight:2]
      // ë‹¤ ìƒˆë¡œ ë§Œë“œëŠ”ê±°ë‹ˆ currentëŠ” nullì´ë‹¤.
      if (current !== null && workInProgress.stateNode != null) {
       ...
      } else {
          ...
        if (wasHydrated) {
          ...
        } else {
          const rootContainerInstance = getRootHostContainer();
          // [!code highlight:8]
          // DOM ë…¸ë“œê°€ ë§Œë“¤ì–´ì¡Œë‹¤!
          const instance = createInstance(
            type,
            newProps,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
          
          markCloned(workInProgress);
          // [!code highlight:5]
          // completeWorkëŠ” í˜„ì¬ workInProgressì˜ 
          // ìì‹ë“¤ì´ ëª¨ë‘ ì²˜ë¦¬ëœ ë’¤ í˜¸ì¶œëœë‹¤.
          // ë”°ë¼ì„œ í•´ë‹¹ ìì‹ë“¤ì˜ completeWorkë„ ëª¨ë‘ ì´ë¯¸ í˜¸ì¶œëì„ê±°ê³ 
          // ê·¸ë¡œ ì¸í•´ ë§Œë“¤ì–´ì§„ ìì‹ë“¤ì˜ DOM nodeë“¤ì„ ì—°ê²°í•œë‹¤.
          appendAllChildren(instance, workInProgress, false, false);

          // [!code highlight:2]
          // ì´ì œ ì´ workInProgressì˜ DOM nodeê°€ ì„¤ì •ë˜ì—ˆë‹¤.
          workInProgress.stateNode = instance;

          // Certain renderers require commit-time effects for initial mount.
          // (eg DOM renderer supports auto-focus for certain elements).
          // Make sure such renderers get scheduled for later work.
          // [!code highlight:2]
          // ì•„ê¹Œ a íƒœê·¸ì˜ ìì‹ í…ìŠ¤íŠ¸ëŠ” ì—¬ê¸°ì„œ ì„¤ì •ëœë‹¤.
          if (
            finalizeInitialChildren(
              instance,
              type,
              newProps,
              currentHostContext,
            )
          ) {
            markUpdate(workInProgress);
          }
        }
      }
      ...
      return null;
    }
    // [!code highlight:2]
    // ì•„ê¹Œ buttonì˜ ìì‹ í…ìŠ¤íŠ¸ì— ëŒ€í•´ì„œëŠ” ì—¬ê¸°ë¡œ ì˜¨ë‹¤.
    case HostText: {
      const newText = newProps;
      if (current && workInProgress.stateNode != null) {
        ...
      } else {
        ...
        const rootContainerInstance = getRootHostContainer();
        const currentHostContext = getHostContext();
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          ...
        } else {
          markCloned(workInProgress);
          // [!code highlight:5]
          workInProgress.stateNode = createTextInstance(
            newText,
            rootContainerInstance,
            currentHostContext,
            workInProgress,
          );
        }
      }
      bubbleProperties(workInProgress);
      return null;
    }
    ...
  }

  throw new Error(
    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +
      'React. Please file an issue.',
  );
}
```

### Commit phase

ë“œë””ì–´ `<App/>`ì„ ë³´ê³  ë§Œë“  ìƒˆë¡œìš´ Fiber íŠ¸ë¦¬ê°€ `workInProgress`ì— ì™„ì„±ëë‹¤! ê° íŠ¸ë¦¬ ë…¸ë“œì— ì—°ê´€ëœ DOM ë…¸ë“œë„ ì—°ê²°ë˜ì–´ìˆë‹¤!

ì´ì œ Commit phaseì—ì„œ ì´ê±¸ ì‹¤ì œ DOMì— ì ìš©í•˜ëŠ” ì‘ì—…ì„ í•´ì•¼í•œë‹¤. 

ë°©ë²•ì€ ëª¨ë¥´ê² ì§€ë§Œ ì ë‹¹í•œ ë•Œì— `commitMutationEffectsOnFiber`ê°€ ì‹¤í–‰ëœë‹¤ê³  í•˜ì. ë°›ì•„ë“¤ì´ì... ì°¸ê³ ë¥¼ ìœ„í•´ ì˜ˆì „ì— ì‚´í´ë³¸ Call stackì„ ë³´ë©´ ì•„ë˜ ê²½ë¡œë¡œ í˜¸ì¶œëœë‹¤.

- performWorkUntilDeadline
  - performWorkOnRootViaSchedularTask
    - performWorkOnRoot
      - commitRootWhenReady
        - commitRoot
          - flushMutationEffects
            - commitMutationEffectsOnFiber

ëìŠ¤ì— ìˆ¨ì´ ê°€ë¹ ì˜¤ì§€ë§Œ ë¬´ì‹œí•˜ê³  `commitMutationEffectsOnFiber`ë¥¼ ì‚´í´ë³´ì. 

```js
function commitMutationEffectsOnFiber(
  // [!code highlight:4]
  // workInProgressì— ëŒ€ì‘ë˜ëŠ” ê²ƒ ê°™ë‹¤.
  // ë¡œê·¸ë¥¼ ì°ì–´ë³´ë©´ RootFiberë¡œ í•œ ë²ˆ (flag=1024),
  // Appì— í•´ë‹¹í•˜ëŠ” FiberNodeë¡œ í•œ ë²ˆ í˜¸ì¶œëœë‹¤(flag=67108865).
  finishedWork: Fiber,

  // [!code highlight:3]
  // FiberRootNode
  // finishedWorkëŠ” ë°”ë€ŒëŠ”ë° ì–˜ëŠ” ë£¨íŠ¸ë¡œ ê³ ì •ì¸ê²Œ ì¸ìƒê¹Šë‹¤.
  root: FiberRoot,
  lanes: Lanes,
) {
  ...
  switch (finishedWork.tag) {
    ...
    case FunctionComponent: {
      // [!code highlight:2]
      recursivelyTraverseMutationEffects(root, finishedWork, lanes);
      commitReconciliationEffects(finishedWork, lanes);
      ...
      break;
    }
    case HostRoot: {
      ...
      if (supportsResources) {
        ...
      } else {
        // [!code highlight:2]
        recursivelyTraverseMutationEffects(root, finishedWork, lanes);
        commitReconciliationEffects(finishedWork, lanes);
      }
      ...
      break;
    }
  }
  ...
}
```

ë­ê°€ ëë“  `recursivelyTraverseMutationEffects`ì™€ `commitReconciliationEffects`ê°€ í˜¸ì¶œëœë‹¤. í•œ ë²ˆ ë´ì£¼ì:

`recursivelyTraverseMutationEffects`ëŠ” íŠ¹ì • ë…¸ë“œì˜ ì§ê³„ ìì‹ ë…¸ë“œë“¤ ì¤‘ ì‚­ì œë˜ì–´ì•¼í•  ê²ƒë“¤ì„ ì‚­ì œí•˜ê³  ëª¨ë“  ì§ê³„ ìì‹ ë…¸ë“œë“¤ì— ëŒ€í•´ì„œ `commitMutationEffectsOnFiber`ë¥¼ í˜¸ì¶œí•œë‹¤. í˜¸ì¶œëœ `commitMutationEffectsOnFiber`ì—ì„œë„ ì¬ê·€ì ìœ¼ë¡œ ë™ì¼í•œ ì‘ì—…ì„ í• í…Œë‹ˆ íŠ¹ì • ë…¸ë“œì— ëŒ€í•´ `recursivelyTraverseMutationEffects`ê°€ í˜¸ì¶œë˜ê³  ë°˜í™˜ë˜ì—ˆë‹¤ë©´ í•´ë‹¹ ë…¸ë“œì˜ ëª¨~ë“  ìì‹ ë…¸ë“œë“¤ì— ëŒ€í•´ `commitDeletionEffects`ê°€ ë˜ì—ˆìŒì„ ì•Œ ìˆ˜ ìˆë‹¤.

```js
function recursivelyTraverseMutationEffects(
  root: FiberRoot,
  parentFiber: Fiber,
  lanes: Lanes,
) {
  // [!code highlight:8]
  // ì‚­ì œí•´ì•¼í•  ìì‹ ë…¸ë“œë“¤ì„ ì‚­ì œí•œë‹¤.
  const deletions = parentFiber.deletions;
  if (deletions !== null) {
    for (let i = 0; i < deletions.length; i++) {
      const childToDelete = deletions[i];
      commitDeletionEffects(root, parentFiber, childToDelete);
    }
  }

  if (
    parentFiber.subtreeFlags &
    (enablePersistedModeClonedFlag ? MutationMask | Cloned : MutationMask)
  ) {
    let child = parentFiber.child;
    // [!code highlight:5]
    // ìì‹ ë…¸ë“œë“¤ì„ ì²˜ë¦¬í•œë‹¤.
    while (child !== null) {
      commitMutationEffectsOnFiber(child, root, lanes);
      child = child.sibling;
    }
  }
}
```

`commitReconciliationEffects`ë¥¼ ì‚´í´ë³´ì:

```js
function commitReconciliationEffects(
  finishedWork: Fiber,
  committedLanes: Lanes,
) {
  const flags = finishedWork.flags;
  if (flags & Placement) {
    // [!code highlight:3]
    // ë“œë””ì–´ DOMì„ ë¸Œë¼ìš°ì €ì— ì¶”ê°€í•˜ë‚˜ë³´ë‹¤!
    // Appì— í•´ë‹¹í•˜ëŠ” Fiberë§Œ ì´ê³³ìœ¼ë¡œ ì˜¨ë‹¤.
    commitHostPlacement(finishedWork);
    finishedWork.flags &= ~Placement;
  }
  if (flags & Hydrating) {
    ...
  }
}
```

```js
export function commitHostPlacement(finishedWork: Fiber) {
  try {
    // [!code highlight]
    commitPlacement(finishedWork);
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
```

```js
// [!code highlight:2]
// finishedWorkëŠ” Appì— í•´ë‹¹í•˜ëŠ” FiberNodeì´ë‹¤.
function commitPlacement(finishedWork: Fiber): void {
  ...
  let hostParentFiber;
  let parentFiber = finishedWork.return;

  // [!code highlight:12]
  // Function Componentê°™ì€ê±´ ë¦¬ì•¡íŠ¸ì—ë§Œ ìˆëŠ” ê°œë…ì´ì§€
  // ì‹¤ì œë¡œ DOMì—ëŠ” ì—†ìœ¼ë¯€ë¡œ ê±°ê¸°ì— DOM ë…¸ë“œë¥¼ ì¶”ê°€í•  ìˆ˜ëŠ” ì—†ë‹¤. 
  // ë”°ë¼ì„œ ë…¸ë“œì˜ ë¶€ëª¨ë¥¼ ì°¾ì•„ ì˜¬ë¼ê°€ë©°
  // HostComponent, HostRootê°™ì€ ì‹¤ë¬¼? ë…¸ë“œë¥¼ ì—¬ê¸°ì„œ ì°¾ëŠ”ë‹¤. 
  while (parentFiber !== null) {
    ...
    if (isHostParent(parentFiber)) {
      hostParentFiber = parentFiber;
      break;
    }
    parentFiber = parentFiber.return;
  }

  switch (hostParentFiber.tag) {
    ...
    case HostRoot: {
      // [!code highlight:2]
      // <div id="root"></div> ì´ë‹¤!!
      const parent: Container = hostParentFiber.stateNode.containerInfo;
      const before = getHostSibling(finishedWork);

      // [!code highlight:6]
      insertOrAppendPlacementNodeIntoContainer(
        finishedWork,
        before,
        parent,
        parentFragmentInstances,
      );
      break;
    }
    ...
  }
}
```

```js
function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container,
  parentFragmentInstances: null | Array<FragmentInstanceType>,
): void {
  const {tag} = node;
  const isHost = tag === HostComponent || tag === HostText;

  if (isHost) {
    const stateNode = node.stateNode;
    // [!code highlight:7]
    // ì—¬ê¸°ì„œë¶€í„°ëŠ” ReactFiberConfigë¡œ react reconcilerì— ì „ë‹¬í•´ì¤€ 
    // DOM ê´€ë ¨ í•¨ìˆ˜ë“¤ì´ë‹¤.
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
    ...
    return;
  } else {
    ...
  }

}
```

## 3. ReactëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ë¦¬ë Œë”ë§í•˜ë‚˜ìš”?  

> Reactê°€ ì—…ë°ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  ê·¸ì— ë”°ë¼ ë¦¬ë Œë”ë§í•˜ëŠ” ë°©ì‹ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

ì´ë²ˆì—” ì•„ë˜ ì½”ë“œì—ì„œ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì–´ë–»ê²Œ ë¦¬ë Œë”ë§ë˜ëŠ”ì§€ ì•Œì•„ë³´ì. 

```js
import ReactDOM from "react-dom/client";
import { useState } from "react";

function Link() {
  return <a href="https://yeolyi.com">yeolyi.com</a>;
}

function Component() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount((count) => count + 1)}>
        click me - {count}
      </button>{" "}
      ({count % 2 === 0 ? <span>even</span> : <b>odd</b>})
    </div>
  );
}
export default function App() {
  return (
    <div>
      <Link />
      <br />
      <Component />
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

2ê°•ì—ì„œ ì‚´í´ë³¸ ì´ˆê¸° ë Œë”ì™€ì˜ ì°¨ì´ì ì„ ìœ„ì£¼ë¡œ ì‚´í´ë³´ì. 

### Trigger phase

Laneì€ Fiber ë…¸ë“œì— í•´ì•¼í•˜ëŠ” ì‘ì—…ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ì˜ë¯¸í•œë‹¤ê³  í•œë‹¤. setStateë¥¼ í˜¸ì¶œí•˜ë©´ ì—°ê´€ëœ ì»´í¬ë„ŒíŠ¸ë“¤ì˜ laneì´ ì„¤ì •ëœë‹¤. 

ì–´ë–¤ ê³¼ì •ìœ¼ë¡œ ì„¤ì •ë˜ëŠ”ì§€ëŠ” ì¼ë‹¨ ë„˜ì–´ê°€ê³  ì¼ë‹¨ ê²°ê³¼ë§Œ ë³´ì. 

setStateë¡œ íŠ¸ë¦¬ê±°ëœ ë¦¬ë Œë”ëŠ” ìš°ì„ ìˆœìœ„ê°€ ë†’ì•„ ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬ëœë‹¤ê³  í•œë‹¤. `workLoopSync`ì— ì•„ë˜ ì½”ë“œë¥¼ ì¶”ê°€í•´ setState ì´í›„ Fiber íŠ¸ë¦¬ì˜ ìƒíƒœê°€ ì–´ë–¤ì§€ í™•ì¸í•´ë³´ì:

```js
function workLoopSync() {
  // [!code highlight:8]
  const traverse = fiber => {
    if (!fiber) return;
    console.log(fiber);
    traverse(fiber.child);
    traverse(fiber.sibling);
  };

  traverse(workInProgress.alternate);

  // Perform work without checking if we need to yield between fiber.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

ì¶œë ¥í•´ë³´ë©´ HostRootFiber, App, divì˜ childLanesê°€ 2, Componentì˜ laneì´ 2ê°€ ë˜ì—ˆìŒì„ í™•ì¸í•´ë³¼ ìˆ˜ ìˆë‹¤. ì´ë¥¼ í†µí•´ childLanesëŠ” ìì‹ ì»´í¬ë„ŒíŠ¸ë“¤ ì¤‘ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•œ ê²ƒì´ ìˆìŒì„, laneì€ ìŠ¤ìŠ¤ë¡œì˜ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•¨ì„ ìœ ì¶”í•  ìˆ˜ ìˆë‹¤.

### Render phase

ë¦¬ì•¡íŠ¸ì˜ í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ì—ì„œ ì…ë ¥ì´ ê°™ìœ¼ë©´ ì¶œë ¥ì´ ê°™ì•„ì•¼í•œë‹¤ëŠ” ì›ì¹™ì„ ë“¤ì–´ë´¤ì„ ê²ƒì´ë‹¤. ë¦¬ë Œë”ë§ ë•ŒëŠ” ì´ ì›ì¹™ì´ ë” ì¤‘ìš”í•´ì§„ë‹¤. ì´ì „ propê³¼ ìƒˆë¡œìš´ propì„ ë¹„êµí•´ì•¼í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ì¼ë‹¨ Fiberì—ì„œ `memoizedProps`ëŠ” ì´ë¯¸ ì ìš©ëœ propì„, `pendingProps`ëŠ” ì ìš©í•´ì•¼í•  propì´ë¼ê³  ì´í•´í•˜ì. 

ì´ˆê¸° ë Œë” ë•ŒëŠ” ê¸°ì¡´ì— ë§Œë“¤ì–´ë†“ì€ê²Œ ì—†ìœ¼ë¯€ë¡œ ì¬í™œìš©ì€ ìƒê°ë„ ì•ˆí–ˆì§€ë§Œ ì´ì œ ê³ ë ¤í•´ì•¼í•œë‹¤. ì•ˆì“°ëŠ” Fiber ê°ì²´ê°€ ìˆë‹¤ë©´ ê°€ì ¸ë‹¤ ì“¸ ìˆ˜ ìˆë‹¤:

```js
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  // ë¦¬ì•¡íŠ¸ëŠ” currentì™€ workInProgressë¡œ ë‘ ê°œì˜ Fiber íŠ¸ë¦¬ë¥¼ ê´€ë¦¬í•œë‹¤. 
  // current.alternateëŠ” current ë…¸ë“œì— ëŒ€ì‘ë˜ëŠ” ë‹¤ë¥¸ íŠ¸ë¦¬ì˜ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤.
  // ë‹¤ë¥´ê²Œ ë§í•˜ë©´ ì´ì „ ë²„ì „ì˜ Fiber ë…¸ë“œë¡œ ë³¼ ìˆ˜ ìˆë‹¤.
  // ì•”íŠ¼ ì´ê²Œ ìˆìœ¼ë©´ ìƒˆë¡œ Fiber ë…¸ë“œë¥¼ ë§Œë“¤ í•„ìš” ì—†ì´ ì´ê±¸ ì¬í™œìš©í•  ìˆ˜ ìˆë‹¤.
  let workInProgress = current.alternate;
  if (workInProgress === null) {
    ...
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    // ...ê¸°íƒ€ workInProgress ì´ˆê¸°í™” ì½”ë“œ
  }
  ...
}
```

ì´ˆê¸° ë Œë”ë•ŒëŠ” ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë“¤ì— ëŒ€í•´ beginWorkê°€ í˜¸ì¶œë˜ì—ˆë‹¤. ì´ë²ˆì—ë„ ê·¸ëŸ°ì§€ `beginWork`ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ `current`ì™€ `workInProgress`ë¥¼ ì¶œë ¥í•˜ê³  ë²„íŠ¼ì„ ëˆŒëŸ¬ë³´ì:

```txt
RootFiber / RootFiber
App / App
div / div
// [!code highlight:2]
// Link ì»´í¬ë„ŒíŠ¸ í•˜ìœ„ aëŠ” ë°©ë¬¸í•˜ì§€ ì•ŠëŠ”ë‹¤.
Link / Link
br / br
Component / Component
div / div
button / button
text / text
text / text
text / text
// [!code highlight:2]
// ë°”ë€Œì—ˆë‹¤.
undefined / b
text / text
```

Link ì»´í¬ë„ŒíŠ¸ í•˜ìœ„ aëŠ” ë°©ë¬¸í•˜ì§€ ì•ŠëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ë¬´ì–¸ê°€ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ì´ ìˆì„ ê²ƒì´ë‹¤:

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // [!code highlight:2]
  // ë¦¬ë Œë”ë§ë•ŒëŠ” ê¸°ì¡´ Fiberê°€ ìˆìœ¼ë¯€ë¡œ ì—¬ê¸°ë¡œ ë¹ ì§„ë‹¤. 
  if (current !== null) {
    // [!code highlight:4]
    // í˜„ì¬ ë…¸ë“œì˜ propì„ ë‚˜íƒ€ë‚¸ë‹¤. 
    const oldProps = current.memoizedProps;
    // ìƒˆë¡œ ë Œë”ë§ë  ë…¸ë“œì˜ propì„ ë‚˜íƒ€ë‚¸ë‹¤. 
    const newProps = workInProgress.pendingProps;

    if (
      // [!code highlight:3]
      // shallowEqual ë¹„êµê°€ ì•„ë‹Œ ë‹¨ìˆœ ì°¸ì¡° ë¹„êµë¥¼ í•¨ì„ 
      // ì£¼ì˜ê¹Šê²Œ ë³´ì.
      oldProps !== newProps ||
      hasLegacyContextChanged()
    ) {
      ...
    } else {
      // [!code highlight]
      // oldProps === newPropsë©´ ì—¬ê¸°ë¡œ ì˜¨ë‹¤.
      // Neither props nor legacy context changes. Check if there's a pending
      // update or context change.
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // [!code highlight:7]
        // ì—…ë°ì´íŠ¸ê°€ ì—†ìœ¼ë©´ ì¡°ê¸° ì¢…ë£Œ(bail out)ë¥¼ ì‹œë„í•œë‹¤.
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      ...
    }
  } else {
    // ... ì§€ë‚œë²ˆì— ì‚´í´ë³¸ ì´ˆê¸° ë§ˆìš´íŠ¸ ìƒí™©
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    // ...ì´ì „ê³¼ ë™ì¼í•˜ê²Œ íƒœê·¸ì— ë”°ë¼
    // updateHostRoot, updateFunctionComponent ë“±ë“±ì„ í˜¸ì¶œ
    // [!code highlight]
    // ìœ„ì—ì„œ bail out ëë‹¤ë©´ ì—¬ê¸°ëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤. 
  }
}
```

`attemptEarlyBailoutIfNoScheduledUpdate`ëŠ” ìŠ¤íƒì— í‘¸ì‹œí•˜ëŠ” ëª©ì ì„ ì•Œ ìˆ˜ ì—†ëŠ”... ì½”ë“œë“¤ì„ ì‹¤í–‰í•˜ê³  `bailOutOnAlreadyFinishedWork`ë¥¼ í˜¸ì¶œí•œë‹¤. 

```js
function attemptEarlyBailoutIfNoScheduledUpdate(
  current: Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  // This fiber does not have any pending work. Bailout without entering
  // the begin phase. There's still some bookkeeping we that needs to be done
  // in this optimized path, mostly pushing stuff onto the stack.
  switch (workInProgress.tag) {
    ...
  }
  // [!code highlight]
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
```

`bailoutOnAlreadyFinishedWork`ì—ì„œëŠ” ìì‹ ë…¸ë“œì— í•  ì¼ì´ ìˆëŠ”ì§€ì— ë”°ë¼ ë°˜í™˜ê°’ì´ ë‹¬ë¼ì§„ë‹¤:

```js
function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  // Check if the children have any pending work.
  // [!code highlight]
  // ìì‹ ë…¸ë“œì— í•  ì¼ì´ ì—†ìœ¼ë©´ nullì„ ë°˜í™˜í•´ ìˆœíšŒë¥¼ ë©ˆì¶˜ë‹¤.
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    if (current !== null) {
      // Before bailing out, check if there are any context changes in
      // the children.
      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);
      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
        return null;
      }
    } else {
      return null;
    }
  }

  // [!code highlight:5]
  // ìì‹ ë…¸ë“œì— í•  ì¼ì´ ìˆìœ¼ë©´ ìì‹ ë…¸ë“œë¥¼ ë³µì œí•´ ë°˜í™˜í•œë‹¤.
  // This fiber doesn't have work, but its subtree does. Clone the child
  // fibers and continue.
  cloneChildFibers(current, workInProgress);
  return workInProgress.child;
}
```

ë°©ê¸ˆ `childLanes`ì˜ í™œìš©ì²˜ë¥¼ ì°¾ì•˜ë‹¤! ì´ë¥¼ í†µí•´ childLanesê°€ 0ì´ ì•„ë‹Œ HostRootFiber, App, divë¥¼ ì²˜ë¦¬í•  ë•ŒëŠ” ì•„ë˜ `cloneChildFibers`ê°€ í˜¸ì¶œëœ í›„ `workInProgress.child`ì— ëŒ€í•´ì„œ ìˆœíšŒë¥¼ ì§€ì†í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ childLanesê°€ 0ì¸ LinkëŠ” nullì´ ë°˜í™˜ë˜ì–´ ìì‹ê¹Œì§€ ê°€ì§€ ì•Šê³  ìˆœíšŒë¥¼ ë©ˆì¶¤ì„ ì•Œ ìˆ˜ ìˆë‹¤.

Linkì™€ brì„ ì§€ë‚˜ Componentì—ì„œëŠ” laneì´ 2ì´ë¯€ë¡œ `updateFunctionComponent`ê°€ í˜¸ì¶œëœë‹¤. 

```js
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes,
) {
  let context;
  if (!disableLegacyContext && !disableLegacyContextForFunctionComponents) {
    ...
  }

  prepareToReadContext(workInProgress, renderLanes);

  // [!code highlight:9]
  // ì—¬ê¸°ì„œ Component í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚´ì„ ìœ ì‹¬íˆ ë³´ì.
  const nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes,
  );

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  // [!code highlight]
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

`renderWithHooks`ì—ì„œëŠ” ìš°ë¦¬ê°€ ë§Œë“  í•¨ìˆ˜ ì»´í¬ë„ŒíŠ¸ë¥¼ ì‹¤í–‰ì‹œí‚¨ë‹¤:

```js
let children = __DEV__
  ? callComponentInDEV(Component, props, secondArg)
  : Component(props, secondArg);
```

Component í•¨ìˆ˜ê°€ ì‹¤í–‰ë  ë•Œë§ˆë‹¤ ì•„ë˜ì²˜ëŸ¼ prop ê°ì²´ì˜ ì°¸ì¡°ê°€ ë‹¬ë¼ì§„ë‹¤.

```js
const element1 = <Component />;
const element2 = <Component />;

console.log(element1.props === element2.props);
// false
```

ì´ë¡œ ì¸í•´ workInProgressê°€ Component í•˜ìœ„ divì— ëŒ€ì‘í•˜ëŠ” ë‹¤ìŒ `beginWork`ì—ì„œëŠ” `oldProps === newProps`ê°€ ì„±ë¦½í•˜ì§€ ì•Šì•„ ë¦¬ë Œë”ë§ëœë‹¤. **ì¼ë°˜í™”í•˜ìë©´ ë¦¬ë Œë”ë§ëœ ì»´í¬ë„ŒíŠ¸ì˜ í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ë“¤ì€ ì‹¤ì œë¡œ í”„ë¡­ì´ ë°”ê¼ˆë“  ì•ˆë°”ê¼ˆë“  ê¸°ë³¸ì ìœ¼ë¡œ ì „ë¶€ ë¦¬ë Œë”ë§ëœë‹¤.** 

ì´ë¥¼ ëª…í™•í•˜ê²Œ ë³´ì—¬ì£¼ëŠ” ì˜ˆì‹œë¡œ í™•ì¸í•´ë³´ì:

```js
function Child2() {
  return <p>Child2</p>;
}

function Child1() {
  const [_, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((count) => count + 1)}>click me</button>
      <Child2 />
    </div>
  );
}

export default function App() {
  return <Child1 />;
}
```

setCountë¡œ Child1ì˜ ë¦¬ë Œë”ë§ì„ íŠ¸ë¦¬ê±°í–ˆì§€ë§Œ ë Œë”ë§ ê²°ê³¼ëŠ” ì „í˜€ ë°”ë€Œì§€ ì•ŠëŠ”ë‹¤. í•˜ì§€ë§Œ Child1ì´ `renderWithHooks`ë¡œ ë¦¬ë Œë”ë§ë˜ë©´ì„œ Child2 ê°ì²´ë„ ë‹¤ì‹œ ë§Œë“¤ì–´ì§€ê²Œëœë‹¤. `beginWork`ì—ì„œ `oldProp === newProp`ì„ ë¡œê·¸ ì°ì–´ë³´ë©´ Child2ì—ì„œ currentì™€ workInProgressì˜ prop ê°’ì´ ë‘˜ ë‹¤ `{}`ì´ì§€ë§Œ ì°¸ì¡°ê°€ ë‹¬ë¼ ===í•´ë³´ë©´ falseë¡œ ë‚˜ì˜¨ë‹¤. 

ì•„ë¬´íŠ¼ ë‹¤ì‹œ ëŒì•„ì™€ì„œ Component í•˜ìœ„ divë¥¼ ë¦¬ë Œë”í•˜ê¸°ìœ„í•´ ì´ë²ˆì—ëŠ” `updateHostComponent`ê°€ í˜¸ì¶œëœë‹¤. `updateHostComponent`ëŠ” `reconcileChildren`ë¥¼ í˜¸ì¶œí•˜ê³ , nextChildrenì´ button, text, b, textì˜ ë°°ì—´ì´ê¸°ì— `reconcileChildren`ëŠ” `reconcileChildrenArray`ë¥¼ í˜¸ì¶œí•œë‹¤. ì—¬ê¸°ëŠ” ë‹¤ìŒì— ì‚´í´ë³´ê³  `placeChild`ë¡œ ì‚½ì…í•´ì•¼í•˜ëŠ” ë…¸ë“œì˜ flagsë¥¼ ì„¤ì •í•˜ê³  `deleteChild`ë¡œ ì‚­ì œí•´ì•¼í•˜ëŠ” ë…¸ë“œì˜ flagë¥¼ ì„¤ì •í•œë‹¤ëŠ” ê²ƒë§Œ ì•Œì•„ë‘ì. 

```js
function placeChild(
  newFiber: Fiber,
  lastPlacedIndex: number,
  newIndex: number,
): number {
  newFiber.index = newIndex;
  ...
  const current = newFiber.alternate;
  if (current !== null) {
    const oldIndex = current.index;
    if (oldIndex < lastPlacedIndex) {
      // [!code highlight:2]
      // This is a move.
      newFiber.flags |= Placement | PlacementDEV;
      return lastPlacedIndex;
    } else {
      // This item can stay in place.
      return oldIndex;
    }
  } else {
    // [!code highlight:2]
    // This is an insertion.
    newFiber.flags |= Placement | PlacementDEV;
    return lastPlacedIndex;
  }
}
```

```js
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
  if (!shouldTrackSideEffects) {
    // Noop.
    return;
  }
  const deletions = returnFiber.deletions;
  // [!code highlight:6]
  if (deletions === null) {
    returnFiber.deletions = [childToDelete];
    returnFiber.flags |= ChildDeletion;
  } else {
    deletions.push(childToDelete);
  }
}
```

button í•˜ìœ„ "click me"ëŠ” bail outë˜ì§€ë§Œ ê·¸ ë‹¤ìŒ TextNodeëŠ” 0ì—ì„œ 1ì´ ë˜ì—ˆì§€ì— bail outë˜ì§€ ì•Šê³  `updateHostText`ë¥¼ í˜¸ì¶œí•œë‹¤. ì—¬ê¸°ëŠ” ì´ˆê¸° ë Œë”ë§ë•Œì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì•„ë¬´ê²ƒë„ ì•ˆí•˜ê³  ë¦¬í„´í•œë‹¤. í…ìŠ¤íŠ¸ ê´€ë ¨ ì‘ì—…ê³¼ DOMì„ ë§Œë“œëŠ” ì‘ì—…ì€ `completeWork`ì—ì„œ ì²˜ë¦¬ëœë‹¤. 

### Commit phase

...

## 4. useEffect()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Reactì—ì„œ ê°€ì¥ í˜¼ë€ìŠ¤ëŸ¬ìš´ í›… ì¤‘ í•˜ë‚˜ì¸ useEffect()ì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## 5. useStateëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useState()ê°€ Reactì—ì„œ ë¦¬ë Œë”ë§ì„ ì–´ë–»ê²Œ ìœ ë°œí•˜ëŠ”ì§€ ì•Œì•„ë´…ë‹ˆë‹¤.

## 6. ErrorBoundaryëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ErrorBoundaryì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## 7. SuspenseëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> í˜„ëŒ€ React ê°œë°œì—ì„œ ì¤‘ìš”í•œ êµ¬ì„± ìš”ì†Œì¸ Suspenseì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## 8. useTransition()ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Suspenseì— ì´ì–´, useTransitionì€ React ì„œë²„ êµ¬ì„± ìš”ì†Œì™€ í•¨ê»˜ ì‚¬ìš©í•˜ê¸° ìœ ìš©í•œ ê³ ê¸‰ ì£¼ì œì…ë‹ˆë‹¤.

## 9. Reactì—ì„œ ContextëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Reactì˜ ê°•ë ¥í•œ ë„êµ¬ì¸ Contextì˜ ì‘ë™ ë°©ì‹ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## 10. useLayoutEffect()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useLayoutEffect()ëŠ” UI í˜ì¸íŒ… ì „ì— íš¨ê³¼ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. ê·¸ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì‚´í´ë´…ë‹ˆë‹¤.

## 11. useRef()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ê°„ë‹¨í•˜ë©´ì„œë„ ê°•ë ¥í•œ í›…ì¸ useRef()ì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## 12. useImperativeHandle()ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ìì£¼ ì‚¬ìš©ë˜ì§€ëŠ” ì•Šì§€ë§Œ, useImperativeHandle()ì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì•Œì•„ë´…ë‹ˆë‹¤.

## 13. Reactì˜ ì¬ì¡°ì •ì—ì„œ bailoutì€ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ReactëŠ” "ëª¨ë“  ê²ƒì„ ë¦¬ë Œë”ë§"í•˜ëŠ” ì •ì‹  ëª¨ë¸ì„ ê°€ì§€ê³  ìˆì§€ë§Œ, ë¶ˆí•„ìš”í•œ ë Œë”ë§ì„ í”¼í•˜ê¸° ìœ„í•œ ë‚´ë¶€ ìµœì í™”ì¸ bailoutë„ ì¡´ì¬í•©ë‹ˆë‹¤.

## 14. React.memo()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> memo()ëŠ” ë‚´ì¥ëœ bailoutì´ ê°ì§€í•  ìˆ˜ ì—†ëŠ” ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ì„ ì¤„ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.

## 15. ReactëŠ” Fiber íŠ¸ë¦¬ë¥¼ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ìˆœíšŒí•˜ë‚˜ìš”?  

> ReactëŠ” ë‚´ë¶€ì ìœ¼ë¡œ Fiber íŠ¸ë¦¬ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤. ê·¸ ìˆœíšŒ ë°©ì‹ì„ ì•Œì•„ë´…ë‹ˆë‹¤.

## 16. Reactì—ì„œ íš¨ê³¼ í›…ì˜ ìƒëª…ì£¼ê¸°  

> useEffect()ì˜ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ìì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

## 17. useDeferredValue()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useDeferredValue()ëŠ” ë™ì‹œ ëª¨ë“œì˜ ê°•ì ì„ ë³´ì—¬ì£¼ëŠ” í›…ì…ë‹ˆë‹¤. ê·¸ ì‘ë™ ë°©ì‹ì„ ì‚´í´ë´…ë‹ˆë‹¤.

## 18. ReactëŠ” ë¹ˆ ê°’ì„ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë‚˜ìš”?  

> Reactì—ì„œ ë¹ˆ ê°’ì´ ì–´ë–»ê²Œ ë¬´ì‹œë˜ëŠ”ì§€ ë‚´ë¶€ì ìœ¼ë¡œ ì‚´í´ë´…ë‹ˆë‹¤.

## 19. 'key'ëŠ” ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”? Reactì—ì„œì˜ ë¦¬ìŠ¤íŠ¸ ë””í•‘  

> Reactì—ì„œ 'key'ê°€ ì‹¤ì œë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì•Œì•„ë´…ë‹ˆë‹¤.

## 20. React SchedulerëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> SchedulerëŠ” Reactì˜ ê°€ì¥ ì¤‘ìš”í•œ ë¶€ë¶„ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ë‹¤ì–‘í•œ ìš°ì„ ìˆœìœ„ì˜ ì‘ì—…ì„ ì–´ë–»ê²Œ ìŠ¤ì¼€ì¤„ë§í•˜ëŠ”ì§€ ì´í•´í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.

## 21. React ì†ŒìŠ¤ ì½”ë“œì—ì„œ Lanesë€ ë¬´ì—‡ì¸ê°€ìš”?  

> LanesëŠ” ìš°ì„ ìˆœìœ„ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ê·¸ê²ƒì´ ë¬´ì—‡ì´ë©° ë™ì‹œ ëª¨ë“œë¥¼ ì–´ë–»ê²Œ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ”ì§€ ì‚´í´ë´…ë‹ˆë‹¤.

## 22. ë™ì‹œ ëª¨ë“œì—ì„œ SuspenseëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”? 1 - ì¬ì¡°ì • íë¦„  

> SuspenseëŠ” ErrorBoundaryì™€ ìœ ì‚¬í•˜ê²Œ ì‘ë™í•˜ì§€ë§Œ í›¨ì”¬ ë” ë³µì¡í•©ë‹ˆë‹¤. ê¸°ë³¸ ë Œë”ë§ ë©”ì»¤ë‹ˆì¦˜ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## 23. ë™ì‹œ ëª¨ë“œì—ì„œ SuspenseëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”? 2 - Offscreen êµ¬ì„± ìš”ì†Œ  

> Offscreen êµ¬ì„± ìš”ì†ŒëŠ” Suspenseì˜ ë‚´ë¶€ì—ì„œ ì‚¬ìš©ë˜ë©° ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.

## 24. Reactì—ì„œ act()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> act()ëŠ” React í…ŒìŠ¤íŠ¸ì—ì„œ ìœ ìš©í•˜ë©°, React ìŠ¤ì¼€ì¤„ëŸ¬ë¥¼ ì´í•´í•˜ëŠ” ë°ë„ ë„ì›€ì´ ë©ë‹ˆë‹¤.

## 25. Reactì—ì„œ SuspenseListëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Suspense ìœ„ì— êµ¬ì¶•ëœ SuspenseListëŠ” ë” ë‚˜ì€ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•˜ëŠ” êµ¬ì„± ìš”ì†Œì…ë‹ˆë‹¤.

## 26. Reactì—ì„œ Portalì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Portalì€ React ìš”ì†Œë¥¼ ë‹¤ë¥¸ DOM ì»¨í…Œì´ë„ˆì— ë Œë”ë§í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. ëª¨ë‹¬ì— ì í•©í•©ë‹ˆë‹¤.

## 27. Reactì—ì„œ ê¸°ë³¸ í•˜ì´ë“œë ˆì´ì…˜ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> í•˜ì´ë“œë ˆì´ì…˜ì€ ì„œë²„ ì¸¡ì—ì„œ ë Œë”ë§ëœ DOMì„ ì¸í„°ë™í‹°ë¸Œí•˜ê²Œ ë§Œë“œëŠ” ê³¼ì •ì…ë‹ˆë‹¤. ì´ ì—í”¼ì†Œë“œì—ì„œëŠ” ê¸°ë³¸ ì‚¬ë¡€ë¥¼ ë‹¤ë£¹ë‹ˆë‹¤.

## 28. Reactì—ì„œ useEffectEvent()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useEffectEvent()ëŠ” useEffect()ì™€ í•¨ê»˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ë” ì‰½ê²Œ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

## 29. Reactì—ì„œ Suspenseì™€ í•¨ê»˜ í•˜ì´ë“œë ˆì´ì…˜ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ì„œë²„ ì¸¡ ë Œë”ë§ì€ ë©‹ì§€ì§€ë§Œ, Suspenseê°€ ì–´ë–»ê²Œ ì²˜ë¦¬ë˜ëŠ”ì§€ ê¶ê¸ˆí•˜ì§€ ì•Šìœ¼ì…¨ë‚˜ìš”?

## 30. ì ì§„ì  í•˜ì´ë“œë ˆì´ì…˜ì´ë€ ë¬´ì—‡ì´ë©° Reactì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ì ì§„ì  í•˜ì´ë“œë ˆì´ì…˜ì€ Suspenseê°€ í•˜ì´ë“œë ˆì´ì…˜ì„ ì›í™œí•˜ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë§ˆë²•ì…ë‹ˆë‹¤.

## 31. React ì„œë²„ êµ¬ì„± ìš”ì†Œ(RSC)ëŠ” Reactì—ì„œ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> React ì„œë²„ êµ¬ì„± ìš”ì†ŒëŠ” Reactì˜ ìƒˆë¡œìš´ ê°€ëŠ¥ì„±ì„ ì—´ì–´ì¤ë‹ˆë‹¤. ì „ì²´ ìŠ¤íƒ ê²½í—˜ì„ êµ¬ì¶•í•˜ëŠ” ë° ì™„ë²½í•œ ë„êµ¬ì…ë‹ˆë‹¤.

## 32. Reactì—ì„œ useId()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useId()ëŠ” ê³ ìœ í•œ IDë¥¼ ìƒì„±í•˜ëŠ” ê°„ë‹¨í•˜ì§€ë§Œ í¥ë¯¸ë¡œìš´ í›…ì…ë‹ˆë‹¤. ê·¸ ì•Œê³ ë¦¬ì¦˜ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€ ì‚´í´ë´…ë‹ˆë‹¤.

## 33. Reactì—ì„œ useInsertionEffect()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useInsertionEffect()ëŠ” DOM ë³€í˜•ì´ ì™„ë£Œë˜ê¸° ì „ì— ì¼ë¶€ íš¨ê³¼ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. ì´ëŠ” íš¨ê³¼ í›… ì¤‘ ê°€ì¥ ì´ë¥¸ íƒ€ì´ë°ì…ë‹ˆë‹¤.

## 34. Reactì—ì„œ lazy()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> ë‚´ì¥ëœ `lazy()`ëŠ” ë Œë”ë§ ì‹œ ì»´í¬ë„ŒíŠ¸ë¥¼ ì§€ì—° ë¡œë“œí•˜ëŠ” ì‰¬ìš´ ë°©ë²•ì…ë‹ˆë‹¤. ì´ ì—í”¼ì†Œë“œì—ì„œ ê·¸ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì•Œì•„ë´…ë‹ˆë‹¤.

## 35. Reactì—ì„œ forwardRef()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> Reactì˜ forwardRef()ëŠ” propsì—ì„œ refë¥¼ ì¶”ì¶œí•  ìˆ˜ ìˆëŠ” ì»´í¬ë„ŒíŠ¸ë¥¼ ìƒì„±í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. refëŠ” íŠ¹ë³„í•˜ê²Œ ì²˜ë¦¬ë˜ë¯€ë¡œ ì§ì ‘ êµ¬í˜„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜¤ëŠ˜ ê·¸ ë‚´ë¶€ ì‘ë™ ë°©ì‹ì„ ì‚´í´ë´…ë‹ˆë‹¤.

## 36. Reactì—ì„œ useSyncExternalStore()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useSyncExternalStore()ëŠ” ì™¸ë¶€ ìŠ¤í† ì–´ì— ì‰½ê²Œ êµ¬ë…í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” React í›…ìœ¼ë¡œ, tearingì´ë‚˜ ê°ì§€ë˜ì§€ ì•Šì€ ë°ì´í„° ë³€ê²½ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤.

## 37. useEffect() ì½œë°±ì€ ì–¸ì œ ì‹¤í–‰ë˜ë‚˜ìš”? í˜ì¸íŠ¸ ì „ì¸ê°€ìš”, í›„ì¸ê°€ìš”?  

> ëŒ€ë¶€ë¶„ì˜ ê²½ìš° useEffect() ì½œë°±ì€ í˜ì¸íŠ¸ í›„ì— ì‹¤í–‰ë˜ì§€ë§Œ, ë•Œë•Œë¡œ í˜ì¸íŠ¸ ì „ì— ì‹¤í–‰ë˜ê¸°ë„ í•©ë‹ˆë‹¤.

## 38. Reactì—ì„œ use()ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> use()ëŠ” Promiseë‚˜ contextë¥¼ ë¦¬ì†ŒìŠ¤ë¡œ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

## 39. Reactì—ì„œ useOptimistic()ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ ì‘ë™í•˜ë‚˜ìš”?  

> useOptimistic()ì€ ë‚™ê´€ì  UIë¥¼ êµ¬ì¶•í•˜ì—¬ ì¸ì§€ëœ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.