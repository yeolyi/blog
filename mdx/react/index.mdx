import renderStack from './assets/render-stack.png'
import domStack from './assets/dom-stack.png'
import effectStack from './assets/effect-stack.png'

# 2025 리액트 기여자 되기

## 시작에 앞서

리액트 소스코드에 기여를 한번쯤은 해보고싶다는 마음이 있습니다. 그래서 회사에서 리액트 소스코드 스터디도 열었는데요, 거기서 공부한걸 여기에 써내려나갈 계획입니다.

다른 블로그 글들과 달리 이건 **저도 잘 모르는 내용**이라서 친절하게 쓰기는 힘들 것 같고 주저리주저리 메모하듯이 배운 것들을 써나갈 예정입니다. 나중에 돌아보면 재밌을 것 같네요 🤗

아래 강의에 맞춰 일주일에 대략 한 강씩 공부합니다. 대신 저는 리액트 19.1.0을 기준으로 공부합니다.

- https://jser.dev/series/react-source-code-walkthrough/

기타 참고 자료

- https://bigfrontend.dev/react-quiz

## 1. React 내부 구조 개요  

> 가장 간단한 Hello World 앱을 디버깅하며 React 내부 구조를 대략적으로 살펴봅니다.

[리액트 소스코드 직접 수정해서 써보기](/post/react-local-build)

크롬 inspector에서 DOM 요소 우클릭을 하면 DOM이 바뀔 때 breakpoint를 설정할 수 있다. 대신 나처럼 react를 직접 설치해서 쓴다면 https://stackoverflow.com/questions/77657008/ 을 적용해야할 수도 있다.

```js
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [count, setCount] = useState(1);
  debugger; // 1

  // 2 <div id="root"></div> 에 point

  useEffect(() => {
    debugger; // 3
    setCount((count) => count + 1);
  }, []);

  return <button>{count}</button>;
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

위 코드 breakpoint별 콜 스택 결과이다. 위로 쌓이는 스택이다. 크롬에서 show ignore-listed frames를 체크해야 보이니 참고...

<div className="flex items-start not-prose">
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">App 렌더링 중</p>
    <Image src={renderStack} alt="render stack" className="object-contain"/>
  </div>
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">DOM 렌더링 중</p>
    <Image src={domStack} alt="dom stack"  className="object-contain" />
  </div>
  <div className="w-1/3 flex flex-col" >
    <p className="text-sm text-stone-400">이펙트 실행 중</p>
    <Image src={effectStack} alt="effect stack" className="object-contain" />
  </div>
</div>

각 함수 설명은 리액트19가 그런가 내 개발환경때문인가 게시물과 꽤 달라서 phase별 설명만 이해하고 넘어가자. 

**트리거(Trigger)**

초기 마운트든 상태 훅으로 인한 재렌더링이든 상관없이, 앱의 어느 부분을 렌더링해야 하는지와 어떻게 수행해야 하는지를 React 런타임에 알려줌.

**스케줄(Schedule)**

기본적으로 우선순위에 따라 작업을 처리하는 우선순위 큐. 런타임 코드에서 렌더링이나 이펙트 실행과 같은 작업을 스케줄링하기 위해 호출됨. 스케줄러 내부의 work loop가 실제로 작업이 실행되는 방식입니다.

**렌더(Render)**

새로운 파이버 트리를 계산하고 호스트 DOM에 적용해야 할 업데이트가 무엇인지 파악.

파이버 트리는 앱의 현재 상태를 나타내는 내부 트리 구조입니다. 이전에는 가상 DOM이라고 불렸지만, 이제는 DOM만을 위한 것이 아니며 React 팀에서도 더 이상 가상 DOM이라고 부르지 않습니다.

Concurrent 모드 때문에 렌더 단계는 중단되고 재개될 수 있어서 상당히 복잡한 단계가 됩니다.

**커밋(Commit)**

호스트 DOM에 변경사항을 적용합니다. 이외에도 모든 종류의 이펙트들도 여기서 처리됩니다.

## 2. 초기 마운트는 어떻게 작동하나요?  


## 3. React는 내부적으로 어떻게 리렌더링하나요?  

> React가 업데이트를 처리하고 그에 따라 리렌더링하는 방식을 설명합니다.

## 4. useEffect()는 내부적으로 어떻게 작동하나요?  

> React에서 가장 혼란스러운 훅 중 하나인 useEffect()의 내부 작동 방식을 설명합니다.

## 5. useState는 내부적으로 어떻게 작동하나요?  

> useState()가 React에서 리렌더링을 어떻게 유발하는지 알아봅니다.

## 6. ErrorBoundary는 내부적으로 어떻게 작동하나요?  

> ErrorBoundary의 내부 작동 방식을 다룹니다.

## 7. Suspense는 내부적으로 어떻게 작동하나요?  

> 현대 React 개발에서 중요한 구성 요소인 Suspense의 내부 작동 방식을 다룹니다.

## 8. useTransition()은 내부적으로 어떻게 작동하나요?  

> Suspense에 이어, useTransition은 React 서버 구성 요소와 함께 사용하기 유용한 고급 주제입니다.

## 9. React에서 Context는 내부적으로 어떻게 작동하나요?  

> React의 강력한 도구인 Context의 작동 방식을 설명합니다.

## 10. useLayoutEffect()는 내부적으로 어떻게 작동하나요?  

> useLayoutEffect()는 UI 페인팅 전에 효과를 실행할 수 있게 해줍니다. 그 내부 작동 방식을 살펴봅니다.

## 11. useRef()는 내부적으로 어떻게 작동하나요?  

> 간단하면서도 강력한 훅인 useRef()의 내부 작동 방식을 설명합니다.

## 12. useImperativeHandle()은 내부적으로 어떻게 작동하나요?  

> 자주 사용되지는 않지만, useImperativeHandle()의 내부 작동 방식을 알아봅니다.

## 13. React의 재조정에서 bailout은 어떻게 작동하나요?  

> React는 "모든 것을 리렌더링"하는 정신 모델을 가지고 있지만, 불필요한 렌더링을 피하기 위한 내부 최적화인 bailout도 존재합니다.

## 14. React.memo()는 내부적으로 어떻게 작동하나요?  

> memo()는 내장된 bailout이 감지할 수 없는 불필요한 리렌더링을 줄여 성능을 향상시킵니다.

## 15. React는 Fiber 트리를 내부적으로 어떻게 순회하나요?  

> React는 내부적으로 Fiber 트리를 유지합니다. 그 순회 방식을 알아봅니다.

## 16. React에서 효과 훅의 생명주기  

> useEffect()의 내부 작동 방식을 자세히 설명합니다.

## 17. useDeferredValue()는 내부적으로 어떻게 작동하나요?  

> useDeferredValue()는 동시 모드의 강점을 보여주는 훅입니다. 그 작동 방식을 살펴봅니다.

## 18. React는 빈 값을 내부적으로 어떻게 처리하나요?  

> React에서 빈 값이 어떻게 무시되는지 내부적으로 살펴봅니다.

## 19. 'key'는 어떻게 작동하나요? React에서의 리스트 디핑  

> React에서 'key'가 실제로 어떻게 작동하는지 알아봅니다.

## 20. React Scheduler는 내부적으로 어떻게 작동하나요?  

> Scheduler는 React의 가장 중요한 부분 중 하나입니다. 다양한 우선순위의 작업을 어떻게 스케줄링하는지 이해하는 데 유용합니다.

## 21. React 소스 코드에서 Lanes란 무엇인가요?  

> Lanes는 우선순위를 의미합니다. 그것이 무엇이며 동시 모드를 어떻게 가능하게 하는지 살펴봅니다.

## 22. 동시 모드에서 Suspense는 내부적으로 어떻게 작동하나요? 1 - 재조정 흐름  

> Suspense는 ErrorBoundary와 유사하게 작동하지만 훨씬 더 복잡합니다. 기본 렌더링 메커니즘을 설명합니다.

## 23. 동시 모드에서 Suspense는 내부적으로 어떻게 작동하나요? 2 - Offscreen 구성 요소  

> Offscreen 구성 요소는 Suspense의 내부에서 사용되며 매우 유용합니다.

## 24. React에서 act()는 내부적으로 어떻게 작동하나요?  

> act()는 React 테스트에서 유용하며, React 스케줄러를 이해하는 데도 도움이 됩니다.

## 25. React에서 SuspenseList는 내부적으로 어떻게 작동하나요?  

> Suspense 위에 구축된 SuspenseList는 더 나은 사용자 경험을 제공하는 구성 요소입니다.

## 26. React에서 Portal은 내부적으로 어떻게 작동하나요?  

> Portal은 React 요소를 다른 DOM 컨테이너에 렌더링할 수 있게 해줍니다. 모달에 적합합니다.

## 27. React에서 기본 하이드레이션은 내부적으로 어떻게 작동하나요?  

> 하이드레이션은 서버 측에서 렌더링된 DOM을 인터랙티브하게 만드는 과정입니다. 이 에피소드에서는 기본 사례를 다룹니다.

## 28. React에서 useEffectEvent()는 내부적으로 어떻게 작동하나요?  

> useEffectEvent()는 useEffect()와 함께 이벤트 핸들러를 처리하는 것을 더 쉽게 만들어줍니다.

## 29. React에서 Suspense와 함께 하이드레이션은 내부적으로 어떻게 작동하나요?  

> 서버 측 렌더링은 멋지지만, Suspense가 어떻게 처리되는지 궁금하지 않으셨나요?

## 30. 점진적 하이드레이션이란 무엇이며 React에서 내부적으로 어떻게 작동하나요?  

> 점진적 하이드레이션은 Suspense가 하이드레이션을 원활하게 처리할 수 있게 해주는 마법입니다.

## 31. React 서버 구성 요소(RSC)는 React에서 내부적으로 어떻게 작동하나요?  

> React 서버 구성 요소는 React의 새로운 가능성을 열어줍니다. 전체 스택 경험을 구축하는 데 완벽한 도구입니다.

## 32. React에서 useId()는 내부적으로 어떻게 작동하나요?  

> useId()는 고유한 ID를 생성하는 간단하지만 흥미로운 훅입니다. 그 알고리즘이 어떻게 작동하는지 살펴봅니다.

## 33. React에서 useInsertionEffect()는 내부적으로 어떻게 작동하나요?  

> useInsertionEffect()는 DOM 변형이 완료되기 전에 일부 효과를 실행할 수 있게 해줍니다. 이는 효과 훅 중 가장 이른 타이밍입니다.

## 34. React에서 lazy()는 내부적으로 어떻게 작동하나요?  

> 내장된 `lazy()`는 렌더링 시 컴포넌트를 지연 로드하는 쉬운 방법입니다. 이 에피소드에서 그 내부 작동 방식을 알아봅니다.

## 35. React에서 forwardRef()는 내부적으로 어떻게 작동하나요?  

> React의 forwardRef()는 props에서 ref를 추출할 수 있는 컴포넌트를 생성할 수 있게 해줍니다. ref는 특별하게 처리되므로 직접 구현할 수 없습니다. 오늘 그 내부 작동 방식을 살펴봅니다.

## 36. React에서 useSyncExternalStore()는 내부적으로 어떻게 작동하나요?  

> useSyncExternalStore()는 외부 스토어에 쉽게 구독할 수 있게 해주는 React 훅으로, tearing이나 감지되지 않은 데이터 변경 문제를 해결합니다.

## 37. useEffect() 콜백은 언제 실행되나요? 페인트 전인가요, 후인가요?  

> 대부분의 경우 useEffect() 콜백은 페인트 후에 실행되지만, 때때로 페인트 전에 실행되기도 합니다.

## 38. React에서 use()는 내부적으로 어떻게 작동하나요?  

> use()는 Promise나 context를 리소스로 쉽게 사용할 수 있게 해줍니다.

## 39. React에서 useOptimistic()은 내부적으로 어떻게 작동하나요?  

> useOptimistic()은 낙관적 UI를 구축하여 인지된 성능을 향상시키는 데 도움이 됩니다.