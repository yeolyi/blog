리액트의 함수형 컴포넌트에서 입력이 같으면 출력이 같아야한다는 원칙을 들어봤을 것이다. 리렌더링 때는 이 원칙이 더 중요해진다. 
이전 prop과 새로운 prop을 비교해야하기 때문이다. 일단 Fiber에서 `memoizedProps`는 이미 적용된 prop을, `pendingProps`는 적용해야할 prop이라고 이해하자. 

초기 렌더때는 모든 컴포넌트들에 대해 beginWork가 호출되었다. 이번에도 그런지 `beginWork`가 호출될 때마다 `current`와 `workInProgress`를 출력하고 버튼을 눌러보자:

```txt
RootFiber / RootFiber
App / App
div / div
// [!code highlight:2]
// Link 컴포넌트 하위 a는 방문하지 않는다.
Link / Link
br / br
Component / Component
div / div
button / button
text / text
text / text
text / text
// [!code highlight:2]
// 바뀌었다.
undefined / b
text / text
```

Link 컴포넌트 하위 a는 방문하지 않는 것을 확인할 수 있다. 무언가 처리하는 로직이 있을 것이다:

```js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // [!code highlight:2]
  // 리렌더링때는 기존 Fiber가 있으므로 여기로 빠진다. 
  if (current !== null) {
    // [!code highlight:4]
    // 현재 노드의 prop을 나타낸다. 
    const oldProps = current.memoizedProps;
    // 새로 렌더링될 노드의 prop을 나타낸다. 
    const newProps = workInProgress.pendingProps;

    if (
      // [!code highlight:3]
      // shallowEqual 비교가 아닌 단순 참조 비교를 함을 
      // 주의깊게 보자.
      oldProps !== newProps ||
      hasLegacyContextChanged()
    ) {
      ...
    } else {
      // [!code highlight]
      // oldProps === newProps면 여기로 온다.
      // Neither props nor legacy context changes. Check if there's a pending
      // update or context change.
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes,
      );
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        // [!code highlight:7]
        // 업데이트가 없으면 조기 종료(bail out)를 시도한다.
        didReceiveUpdate = false;
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes,
        );
      }
      ...
    }
  } else {
    // ... 지난번에 살펴본 초기 마운트 상황
  }

  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    // ...이전과 동일하게 태그에 따라
    // updateHostRoot, updateFunctionComponent 등등을 호출
    // [!code highlight]
    // 위에서 bail out 됐다면 여기는 실행되지 않는다. 
  }
}
```

`attemptEarlyBailoutIfNoScheduledUpdate`는 스택에 푸시하는 목적을 알 수 없는... 코드들을 실행하고 `bailOutOnAlreadyFinishedWork`를 호출한다. 

```js
function attemptEarlyBailoutIfNoScheduledUpdate(
  current: Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
) {
  // This fiber does not have any pending work. Bailout without entering
  // the begin phase. There's still some bookkeeping we that needs to be done
  // in this optimized path, mostly pushing stuff onto the stack.
  switch (workInProgress.tag) {
    ...
  }
  // [!code highlight]
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
```

`bailoutOnAlreadyFinishedWork`에서는 자식 노드에 할 일이 있는지에 따라 반환값이 달라진다:

```js
function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  // Check if the children have any pending work.
  // [!code highlight]
  // 자식 노드에 할 일이 없으면 null을 반환해 순회를 멈춘다.
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    if (current !== null) {
      // Before bailing out, check if there are any context changes in
      // the children.
      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);
      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
        return null;
      }
    } else {
      return null;
    }
  }

  // [!code highlight:5]
  // 자식 노드에 할 일이 있으면 자식 노드를 복제 혹은 재활용해 반환한다.
  // This fiber doesn't have work, but its subtree does. Clone the child
  // fibers and continue.
  cloneChildFibers(current, workInProgress);
  return workInProgress.child;
}
```

방금 `childLanes`의 활용처를 찾았다! 
이를 통해 childLanes가 0이 아닌 HostRootFiber, App, div를 처리할 때는 아래 `cloneChildFibers`가 호출된 후 
`workInProgress.child`에 대해서 순회를 지속함을 알 수 있다. 
하지만 childLanes가 0인 Link는 null이 반환되어 자식까지 가지 않고 순회를 멈춤을 알 수 있다.

Link와 br을 지나 Component에서는 lane이 2이므로 `updateFunctionComponent`가 호출된다. 

```js
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes,
) {
  let context;
  if (!disableLegacyContext && !disableLegacyContextForFunctionComponents) {
    ...
  }

  prepareToReadContext(workInProgress, renderLanes);

  // [!code highlight:9]
  // 여기서 Component 함수를 실행시킴을 유심히 보자.
  const nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes,
  );

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork;
  // [!code highlight]
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

`renderWithHooks`에서는 우리가 만든 함수 컴포넌트를 실행시킨다:

```js
let children = __DEV__
  ? callComponentInDEV(Component, props, secondArg)
  : Component(props, secondArg);
```

참고로 Component 함수가 실행될 때마다 아래처럼 prop 객체의 참조가 달라진다.

```js
const element1 = <Component />;
const element2 = <Component />;

console.log(element1.props === element2.props);
// false
```

이로 인해 workInProgress가 Component 하위 div에 대응하는 다음 `beginWork`에서는 `oldProps === newProps`가 성립하지 않아 리렌더링된다. **일반화하자면 리렌더링된 컴포넌트의 하위 컴포넌트들은 실제로 프롭이 바꼈든 안바꼈든 기본적으로 전부 리렌더링된다.** 

이를 명확하게 보여주는 예시로 확인해보자:

```js
function Child2() {
  return <p>Child2</p>;
}

function Child1() {
  const [_, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((count) => count + 1)}>click me</button>
      <Child2 />
    </div>
  );
}

export default function App() {
  return <Child1 />;
}
```

setCount로 Child1의 리렌더링을 트리거했지만 렌더링 결과는 전혀 바뀌지 않는다. 하지만 Child1이 `renderWithHooks`로 리렌더링되면서 Child2 객체도 다시 만들어지게된다. `beginWork`에서 `oldProp === newProp`을 로그 찍어보면 Child2에서 current와 workInProgress의 prop 값이 둘 다 `{}`이지만 참조가 달라 ===해보면 false로 나온다. 

아무튼 다시 돌아와서 Component 하위 div를 리렌더하기위해 이번에는 `updateHostComponent`가 호출된다. `updateHostComponent`는 `reconcileChildren`를 호출하고, nextChildren이 button, text, b, text의 배열이기에 `reconcileChildren`는 `reconcileChildrenArray`를 호출한다. 여기는 다음에 살펴보고 `placeChild`로 삽입해야하는 노드의 flags를 설정하고 `deleteChild`로 삭제해야하는 노드의 flag를 설정한다는 것만 알아두자. 

```js
function placeChild(
  newFiber: Fiber,
  lastPlacedIndex: number,
  newIndex: number,
): number {
  newFiber.index = newIndex;
  ...
  const current = newFiber.alternate;
  if (current !== null) {
    const oldIndex = current.index;
    if (oldIndex < lastPlacedIndex) {
      // [!code highlight:2]
      // This is a move.
      newFiber.flags |= Placement | PlacementDEV;
      return lastPlacedIndex;
    } else {
      // This item can stay in place.
      return oldIndex;
    }
  } else {
    // [!code highlight:2]
    // This is an insertion.
    newFiber.flags |= Placement | PlacementDEV;
    return lastPlacedIndex;
  }
}
```

```js
function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {
  if (!shouldTrackSideEffects) {
    // Noop.
    return;
  }
  const deletions = returnFiber.deletions;
  // [!code highlight:6]
  if (deletions === null) {
    returnFiber.deletions = [childToDelete];
    returnFiber.flags |= ChildDeletion;
  } else {
    deletions.push(childToDelete);
  }
}
```

button 하위 "click me"는 bail out되지만 그 다음 TextNode는 0에서 1이 되었지에 bail out되지 않고 `updateHostText`를 호출한다. 여기는 초기 렌더링때와 마찬가지로 아무것도 안하고 리턴한다. 텍스트 관련 작업과 DOM을 만드는 작업은 `completeWork`에서 처리된다. 

### Commit phase

...

