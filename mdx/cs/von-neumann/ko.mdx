export const title = '폰 노이만 또 당신이야?';
export const description =
    "'프로그램을 데이터와 같은 공간에 저장한다'는 단순하지만 강력한 아이디어. 이 발상 하나가 어떻게 CPU, 메모리, 버스라는 현대 컴퓨터의 기본 골격을 만들었는지 알아봅시다.";

import turingMachine from './assets/turing-machine.png';
import vonNeumann from './assets/von-neumann.png';
import vonNeumannDiagram from './assets/von-neumann-diagram.png';
import { Memory } from './components/Memory';

<Image src={turingMachine} alt="" className="object-cover w-full h-[240px] object-top" caption="영화 '이미테이션 게임'"/>

지난 게시물에서 우리는 컴퓨터를 **프로그래밍 가능한 기계**로 정의하고, 하드웨어와 소프트웨어를 분리한다는 아이디어를 튜링 머신을 통해 살펴보았습니다. 튜링이 무엇을 계산할 수 있는지에 대한 이론적 토대를 마련했다면, 이제 우리는 **어떻게 그 기계를 현실 세계에 만들 것인가**라는 질문에 답해야 합니다.

<Image src={vonNeumann} alt="" className="object-cover w-full h-[240px] object-top" />

튜링의 아이디어는 훌륭했지만 테이프와 헤드로 이루어진 추상적인 모델을 어떻게 실제 전자회로로 구현할 수 있을까요? 이를 가능하게 한 인물이 바로 수학자 존 폰 노이만입니다. 20세기 과학에서 어김없이 등장하는 그가 컴퓨터 탄생의 역사에서도 빠지지 않는 것은 어쩌면 당연한 일일지도 모릅니다. 

이번 글에서는 현대 컴퓨터 구조의 근간을 이루는 **폰 노이만 구조**에 대해 알아보고, 우리가 이전에 만들었던 논리회로들이 어떻게 거대한 컴퓨터의 일부가 되는지 그 설계도를 함께 그려보겠습니다.

## 전선 수천 개를 갈아끼우라고요? 제가요?

폰 노이만 구조가 등장하기 이전의 초기 컴퓨터들은 매우 비효율적인 방식으로 작동했습니다. 

> ENIAC을 이후의 모든 컴퓨터들과 구분짓는 특이한 점 중 하나는, 명령어를 기계에 설정하는 방식이었다. 그것은 소형 천공 카드 기계의 플러그보드와 유사했지만, ENIAC에서는 수 피트 크기의 플러그보드가 약 40개나 있었고, 문제 하나의 명령어마다 다수의 와이어를 꽂아야 했다.
문제 하나를 실행 준비하기 위해서는 수천 개의 와이어를 연결해야 했으며, 이 작업에는 수일이 걸렸고, 그 설정을 검증하는 데에는 더 많은 날들이 필요했다. 
> 
> — Franz L. Alt, "Archaeology of Computers—Reminiscences, 1945–1947,"
Communications of the ACM, Vol. 15, No. 7, July 1972, p. 694.

**결국 에니악에게 프로그램이란 기계의 물리적인 구조 그 자체였습니다**. 마치 새로운 요리를 할 때마다 부엌의 구조를 통째로 바꾸는 것과 같았죠. 논리가 전선에 담겨 있었던 셈입니다.

## 폰 노이만 구조

폰 노이만은 이 문제를 프로그램의 개념 자체를 재정의함으로써 해결했습니다. **프로그램을 하드웨어의 물리적인 배선 상태로 보는 대신, 그저 데이터와 똑같은 정보로 취급한 것입니다.**

이 아이디어가 바로 **내장형 프로그램 방식(Stored-Program Computer)** 이며, 이는 폰 노이만 구조의 심장이 됩니다. 전선을 만질 필요 없이 메모리에 저장된 프로그램만 새로 불러오면 컴퓨터가 완전히 다른 작업을 수행하게 된 것입니다.

이로써 튜링의 보편 튜링 머신은 마침내 현실로 구현되게 됩니다. 하드웨어는 고정된 채 메모리에 어떤 프로그램을 불러오느냐에 따라 기능이 달라지는 범용 기계가 탄생한 것입니다.

<Image src={vonNeumannDiagram} alt="" className="object-cover w-full p-2 bg-white" />

폰 노이만 구조는 컴퓨터를 크게 세 가지 핵심 부분으로 나눕니다. 이 구조는 오늘날 우리가 사용하는 거의 모든 컴퓨터의 기본 설계도입니다.

### 메모리 (Memory)

컴퓨터가 일할 때 필요한 모든 데이터를 저장합니다. 데이터는 크게 두 가지로 나뉩니다:

- 프로그램 (명령어의 집합)
- 데이터 (명령어가 처리할 대상)

메모리의 가장 큰 특징은 각각의 저장 공간이 **숫자 주소**를 갖고 있다는 점입니다. 예를 들어 '100번 주소에 있는 데이터를 가져와라' 또는 '50을 2048번 주소에 저장해라'와 같이 주소를 지정하여 명령을 내리면, 메모리는 해당 위치의 데이터를 즉시 찾아내거나 저장합니다. 

<Memory />

### CPU

메모리에 저장된 명령어를 순서대로 가져와 해석하고, 그에 따라 컴퓨터의 다른 부분들이 움직이도록 제어합니다. CPU 내부는 크게 두뇌의 두 반구처럼, 역할을 분담하는 두 부분으로 나뉩니다.

#### 산술/논리 연산 장치(ALU)와 프로세서 레지스터

제어 장치의 지시를 받아 실제 연산을 수행하는 '일꾼'입니다. 덧셈, 뺄셈 같은 산술 연산뿐만 아니라, '참/거짓'을 판단하는 AND, OR, NOT 같은 논리 연산도 처리합니다. 우리가 시리즈 초반에 논리 게이트(AND, OR, NOT)를 조합하여 가산기를 만들었던 것을 기억하시나요? 바로 그 회로가 더욱 정교하게 발전한 형태가 이 ALU의 심장부를 이루고 있습니다.

#### 제어 장치 (Control Unit)

제어 장치는 메모리에서 '이번에 실행할 명령어는 덧셈'이라는 명령어를 읽어옵니다. 그리고 이 명령을 해석한 뒤, 실제 덧셈을 수행할 연산 장치에 "지금부터 덧셈을 시작해!"라고 지시하고, 메모리에게 "덧셈에 필요한 두 숫자를 내보내!"라고 요청하는 등 전체 작업 과정을 지휘하는 '지휘자' 역할을 합니다.

### 입출력 장치 (Input and output mechanisms)

입출력 장치는 컴퓨터 내부와 사용자를 연결하는 기능을 합니다.

위의 실습 컴포넌트에서는 메모리 내부를 볼 수 있었지만 실제로는 입출력장치가 없다면 메모리 내부에 저장된 데이터를 볼 수 없을 것입니다.

**입력 장치**는 외부의 정보를 컴퓨터가 이해할 수 있는 디지털 신호로 변환하여 전달합니다. 우리가 누르는 키보드의 각 키, 마우스의 움직임과 클릭 등이 대표적인 예입니다. 

**출력 장치**는 반대로 컴퓨터 내부의 처리 결과를 우리가 인지할 수 있는 형태로 변환하여 보여줍니다. 모니터 화면에 나타나는 글자와 이미지, 스피커에서 나오는 소리 등이 여기에 해당합니다. 하드 디스크나 SSD 같은 보조기억장치 역시 CPU의 관점에서는 데이터를 읽고 쓰는 입출력 장치의 일종으로 볼 수 있습니다.

## 실습: 피보나치 수열 계산 따라가기

이제 폰 노이만 구조가 실제로 어떻게 작동하는지 간단한 예제를 통해 살펴보겠습니다. 피보나치 수열의 처음 몇 항을 계산하는 과정을 CPU, 메모리, 그리고 입출력 장치가 어떻게 협력하여 처리하는지 단계별로 따라가보겠습니다.

**피보나치 수열이란?** 0, 1로 시작하여 다음 항이 항상 앞의 두 항의 합이 되는 수열입니다.
- 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

### 1단계: 프로그램 메모리에 저장

먼저 피보나치 수열을 계산하는 프로그램이 메모리에 저장되어 있어야 합니다. 실제 기계어는 복잡하므로, 이해하기 쉬운 의사 코드(pseudo code)로 표현하면 다음과 같습니다:

```txt
주소 100: a = 0 저장
주소 101: b = 1 저장  
주소 102: a 출력
주소 103: b 출력
주소 104: c = a + b 계산
주소 105: c 출력
주소 106: a = b로 갱신
주소 107: b = c로 갱신
주소 108: 104번 주소로 돌아가기 (반복)
```

### 2단계: CPU의 제어 장치가 명령어 읽기

CPU의 제어 장치는 프로그램 카운터(PC)라는 특수한 레지스터를 통해 "지금 실행해야 할 명령어가 메모리 어느 주소에 있는지" 기억합니다.

1. **PC = 100**: "100번 주소의 명령어를 가져와라"
2. 메모리가 "a = 0 저장" 명령어를 CPU로 전송
3. 제어 장치가 이 명령어를 해석: "변수 a에 0을 저장하라"

### 3단계: ALU와 레지스터에서 연산 수행

제어 장치의 지시를 받아 실제 작업이 시작됩니다:

1. **초기값 설정**: 
   - 레지스터 A에 0 저장 (a = 0)
   - 레지스터 B에 1 저장 (b = 1)

2. **첫 번째 계산 사이클**:
   - ALU가 A + B 연산 수행: 0 + 1 = 1
   - 결과를 레지스터 C에 저장

3. **값 갱신**:
   - A ← B (A에 1 저장)
   - B ← C (B에 1 저장)

### 4단계: 입출력 장치를 통한 결과 확인

계산 과정에서 나온 각 결과들이 출력 장치(모니터)로 전송됩니다:

```txt
첫 번째 출력: 0
두 번째 출력: 1  
세 번째 출력: 1
네 번째 출력: 2
다섯 번째 출력: 3
...
```

### 5단계: 반복과 제어

프로그램 카운터가 108번 주소에 도달하면 "104번 주소로 돌아가기" 명령을 만납니다. 이때 제어 장치는 PC를 다시 104로 설정하여 계산 과정을 반복합니다.

이 과정에서 다음이 반복됩니다:
- **Fetch**: 메모리에서 다음 명령어 가져오기
- **Decode**: 명령어 해석하기  
- **Execute**: 명령어 실행하기

### 핵심 포인트: 왜 폰 노이만 구조가 혁신적인가?

이 실습에서 주목할 점은 **같은 하드웨어가 프로그램만 바뀌면 완전히 다른 작업을 수행할 수 있다**는 것입니다. 

만약 메모리에 저장된 프로그램을 다음과 같이 바꾼다면:

```txt
주소 100: x 입력받기
주소 101: y 입력받기
주소 102: result = x * y 계산
주소 103: result 출력
```

똑같은 CPU, 메모리, 입출력 장치가 이번에는 곱셈 계산기로 변신합니다. 전선 하나 바꿀 필요 없이 말이죠!

### 메모리에서 일어나는 일

실습 과정에서 메모리는 다음과 같이 활용됩니다:

- **프로그램 영역**: 명령어들이 순서대로 저장 (주소 100~108)
- **데이터 영역**: 변수 a, b, c의 값들이 저장
- **임시 영역**: 계산 중간 결과들이 잠시 보관

CPU는 이 모든 영역을 주소만으로 구분하여 접근합니다. 이것이 바로 **폰 노이만 구조의 핵심인 "프로그램과 데이터를 같은 메모리 공간에 저장"**의 실제 모습입니다.

## 마무리: 설계도에서 실제 동작으로

이번 시간에는 튜링의 추상적인 기계가 폰 노이만의 구체적인 설계도를 만나 어떻게 현대 컴퓨터로 발전했는지 살펴보았습니다. 핵심은 **프로그램을 데이터처럼 메모리에 저장**하여 하드웨어의 변경 없이 소프트웨어만으로 다양한 작업을 수행할 수 있게 되었다는 점입니다.

이제 우리는 컴퓨터의 두뇌 역할을 하는 CPU, 작업 공간인 메모리, 그리고 이들을 연결하는 버스라는 멋진 설계도를 손에 넣었습니다.

그렇다면 이제 다음 질문으로 나아갈 차례입니다. CPU는 이 설계도 위에서 도대체 **어떻게** 메모리에 저장된 명령어들을 하나씩 읽고, 해석하고, 실행하는 걸까요? 그 경이로운 작업 루틴은 무엇일까요?

**다음 게시물에서는 드디어 CPU의 심장부로 들어가, 그 유명한 '명령어 사이클(Fetch-Decode-Execute)'이 어떻게 초당 수십억 번씩 반복되며 컴퓨터에 생명을 불어넣는지 알아보겠습니다.**