{/* ## 현대 컴퓨터의 심장, 폰 노이만 구조

튜링 머신이 컴퓨터의 가능성을 이론적으로 보여주었다면, 존 폰 노이만은 이 이론을 실제 컴퓨터로 구현하기 위한 구체적인 설계를 제시했습니다. 바로 **폰 노이만 구조**입니다. 이 구조는 1945년에 발표된 'EDVAC에 관한 보고서의 초안'에서 제안되었고, 이후 모든 현대 컴퓨터의 기본 설계가 됩니다.

폰 노이만 구조의 가장 혁신적인 아이디어는 바로 **'저장된 프로그램 방식'** 입니다. 이전의 컴퓨터들은 작업을 바꿀 때마다 기계의 회로를 물리적으로 재배선해야 했습니다. 마치 계산기를 만들려면 덧셈 회로를 만들고, 곱셈을 하려면 곱셈 회로로 통째로 갈아 끼워야 하는 것과 같았죠. 하지만 폰 노이만은 프로그램(명령어)과 데이터(자료)를 **모두 같은 종류의 기억장치(메모리)에 저장하고, CPU가 이 메모리에서 필요할 때마다 가져와 처리**하도록 제안했습니다.

폰 노이만 구조는 크게 다음 다섯 가지 핵심 구성 요소로 이루어져 있습니다.

*   **중앙 처리 장치 (CPU)**: 컴퓨터의 '뇌' 역할을 합니다.
    *   **연산 장치 (ALU)**: 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행합니다. 지난 글에서 배웠던 반가산기나 전가산기가 바로 이 ALU의 핵심 부품입니다.
    *   **제어 장치 (Control Unit)**: 컴퓨터의 모든 동작을 지시하고 통제합니다. 메모리에서 명령어를 읽어오고, 명령어를 해석하며, 해당 명령어에 필요한 연산을 ALU에 지시하고, 데이터를 메모리에 저장하도록 제어합니다.
    *   **레지스터 (Registers)**: CPU 내부에 있는 매우 빠른 임시 기억 장치입니다. 제어 장치가 다음에 처리할 명령어의 주소를 저장하거나, ALU가 현재 계산할 데이터, 혹은 계산된 중간 결과를 임시로 저장하는 등, CPU가 당장 필요한 정보들을 이곳에 보관합니다.

*   **기억 장치 (Memory)**: 프로그램 명령어와 데이터를 저장하는 공간입니다. 지난 게시물에서 다룬 RAM과 ROM의 개념이 바로 이곳에 해당합니다.

*   **입출력 장치 (I/O Devices)**: 컴퓨터 외부와 정보를 주고받는 역할을 합니다. 키보드, 마우스, 모니터, 프린터 등이 여기에 해당합니다.

### 왜 폰 노이만 구조가 중요할까요?

폰 노이만 구조는 다음과 같은 혁신적인 장점들로 현대 컴퓨터 시대를 열었습니다.

*   **유연성:** 프로그램과 데이터를 동일한 메모리에 저장하기 때문에, 새로운 작업을 수행하고 싶을 때는 단순히 메모리의 프로그램만 바꿔 넣으면 됩니다. 하드웨어를 물리적으로 변경할 필요 없이 소프트웨어만으로 컴퓨터의 기능을 무한히 확장할 수 있게 된 것이죠. 이는 컴퓨터가 '범용 기계'로 발전하는 데 결정적인 역할을 했습니다.
*   **단순화:** 프로그램과 데이터를 동일한 방식으로 다루기 때문에, 하드웨어 설계가 훨씬 단순해졌습니다. 이는 컴퓨터의 대량 생산과 보급을 가능하게 한 중요한 요인입니다.
*   **자율성:** CPU가 메모리에서 스스로 명령어를 가져와 실행하고, 그 결과에 따라 다음 동작을 결정하는 자율적인 컴퓨팅이 가능해졌습니다. 이는 사람이 일일이 개입하지 않아도 컴퓨터가 스스로 복잡한 작업을 수행할 수 있는 기반이 됩니다.

물론, 폰 노이만 구조에도 한계는 존재합니다. 프로그램과 데이터가 같은 통로(버스)를 통해 메모리와 CPU 사이를 오가야 하기 때문에 데이터 처리 속도가 병목 현상을 겪을 수 있습니다. 이를 **폰 노이만 병목**이라고 부릅니다. 이 문제를 해결하기 위해 프로그램과 데이터를 별도의 메모리에 저장하고 각각의 전용 통로를 사용하는 **하버드 구조**와 같은 대안도 존재합니다. 하지만 폰 노이만 구조는 여전히 대부분의 범용 컴퓨터에서 핵심적인 설계 원리로 사용되고 있습니다.

> 현대 컴퓨터는 폰 노이만 구조의 장점을 취하면서도 병목 현상을 완화하기 위해 CPU 내부에 캐시 메모리를 도입하여 하버드 구조의 장점을 일부 통합하는 형태로 발전했습니다. 즉, 명령어와 데이터를 캐시에 각각 분리하여 저장하고 고속으로 접근할 수 있도록 설계하여, 폰 노이만 병목 현상을 줄이려는 노력을 합니다. 이는 다음 게시물에서 자세히 다룰 메모리 계층 구조의 핵심적인 부분입니다.

### 폰 노이만 구조로 피보나치 수열 계산하기

이제 폰 노이만 구조가 실제로 어떻게 작동하는지 이해를 돕기 위해, 컴퓨터가 피보나치 수열을 계산하는 과정을 아주 단순하게 시뮬레이션해 봅시다. 피보나치 수열은 앞의 두 숫자를 더해 다음 숫자를 만들어내는 수열입니다. 예를 들어, 0, 1, 1, 2, 3, 5, 8, ... 과 같습니다. 이 계산은 이전 값을 '기억'하고 그 값을 '처리'해야 하므로, 폰 노이만 구조의 작동 방식을 이해하는 데 좋은 예시가 됩니다.

간단하게 0, 1로부터 세 번째 피보나치 수(1)를 계산하는 과정을 살펴볼까요?

1.  **명령어 가져오기 (Fetch Instruction):** 제어 장치가 메모리의 특정 주소(예: 첫 번째 명령어의 주소)로 이동하여 '첫 번째 피보나치 수(0)를 레지스터 A에 가져오라'는 명령어를 읽어옵니다.
2.  **명령어 해독 (Decode Instruction):** 제어 장치가 읽어온 명령어를 해석하여 '메모리에서 데이터를 가져와 레지스터 A에 저장하라'는 것을 파악합니다.
3.  **데이터 가져오기 (Fetch Data):** 제어 장치는 메모리의 해당 주소에서 실제 데이터 '0'을 가져와 ALU의 레지스터 A에 저장합니다.
4.  **명령어 가져오기 (Fetch Instruction):** 제어 장치가 다음 명령어('두 번째 피보나치 수(1)를 레지스터 B에 가져오라')를 읽어옵니다.
5.  **명령어 해독 (Decode Instruction):** 제어 장치가 이를 해석합니다.
6.  **데이터 가져오기 (Fetch Data):** 제어 장치는 메모리에서 데이터 '1'을 가져와 ALU의 레지스터 B에 저장합니다.
7.  **명령어 가져오기 (Fetch Instruction):** 제어 장치가 다음 명령어('레지스터 A와 B의 값을 더하라')를 읽어옵니다.
8.  **명령어 해독 (Decode Instruction):** 제어 장치가 이를 해석합니다.
9.  **실행 (Execute):** ALU가 레지스터 A(0)와 B(1)의 값을 더합니다. 결과는 '1'입니다.
10. **명령어 가져오기 (Fetch Instruction):** 제어 장치가 다음 명령어('결과를 메모리에 저장하고, 레지스터 값 업데이트')를 읽어옵니다.
11. **명령어 해독 (Decode Instruction):** 제어 장치가 이를 해석합니다.
12. **결과 저장 (Store Result):** ALU에서 계산된 결과 '1'을 메모리의 특정 주소에 저장합니다. 또한, 다음 피보나치 수 계산을 위해 레지스터 A와 B의 값을 업데이트합니다 (예: A에 이전 B 값, B에 새로운 결과 값).

이처럼 컴퓨터는 프로그램 명령어와 데이터를 메모리에서 순차적으로 가져와 CPU에서 처리하고, 그 결과를 다시 메모리에 저장하는 과정을 반복하며 복잡한 계산을 수행합니다. 이 과정에서 0과 1로 표현된 비트들은 논리 게이트를 통해 의미 있는 연산으로 변환되고, 플립플롭과 레지스터, 그리고 RAM과 같은 메모리들을 통해 기억되고 전달되는 것이죠.

### 마무리

컴퓨터가 단순히 계산만 하는 기계를 넘어, 우리 삶의 모든 영역에서 없어서는 안 될 '만능 도구'가 될 수 있었던 것은 앨런 튜링의 이론적 토대와 존 폰 노이만의 실용적인 구조 설계 덕분입니다. 특히 프로그램과 데이터를 같은 공간에 저장하고 CPU가 이를 자율적으로 처리하는 **폰 노이만 구조**는 현대 컴퓨팅의 핵심 원리이자 가장 위대한 발명 중 하나라고 할 수 있습니다.

우리는 이제 컴퓨터가 0과 1이라는 단순한 비트를 기억하고 연산하며, 나아가 프로그램에 따라 무한히 다양한 작업을 수행하는 '지능적인 기계'로 변모하는 과정을 이해하게 되었습니다. 다음 게시물에서는 CPU가 데이터를 더 효율적으로 처리하기 위해 어떻게 메모리를 계층적으로 활용하는지, 즉 **메모리 계층 구조**에 대해 더 깊이 알아보겠습니다.
 */}
