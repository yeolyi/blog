export const title = '폰 노이만 또 당신이야?';
export const description =
    "'프로그램을 데이터와 같은 공간에 저장한다'는 단순하지만 강력한 아이디어. 이 발상 하나가 어떻게 CPU, 메모리, 버스라는 현대 컴퓨터의 기본 골격을 만들었는지 알아봅시다.";

import turingMachine from './assets/turing-machine.png';
import vonNeumann from './assets/von-neumann.png';
import vonNeumannDiagram from './assets/von-neumann-diagram.png';
import { Memory } from './components/Memory';

<Image src={turingMachine} alt="" className="object-cover w-full h-[240px] object-top" caption="영화 '이미테이션 게임'"/>

지난 게시물에서 우리는 컴퓨터를 **프로그래밍 가능한 기계**로 정의하고, 하드웨어와 소프트웨어를 분리한다는 아이디어를 튜링 머신을 통해 살펴보았습니다. 튜링이 무엇을 계산할 수 있는지에 대한 이론적 토대를 마련했다면, 이제 우리는 **어떻게 그 기계를 현실 세계에 만들 것인가**라는 질문에 답해야 합니다.

<Image src={vonNeumann} alt="" className="object-cover w-full h-[240px] object-top" />

튜링의 아이디어는 훌륭했지만 테이프와 헤드로 이루어진 추상적인 모델을 어떻게 실제 전자회로로 구현할 수 있을까요? 이를 가능하게 한 인물이 바로 수학자 존 폰 노이만입니다. 20세기 과학에서 어김없이 등장하는 그가 컴퓨터 탄생의 역사에서도 빠지지 않는 것은 어쩌면 당연한 일일지도 모릅니다. 

이번 글에서는 현대 컴퓨터 구조의 근간을 이루는 **폰 노이만 구조**에 대해 알아보고, 우리가 이전에 만들었던 논리회로들이 어떻게 거대한 컴퓨터의 일부가 되는지 그 설계도를 함께 그려보겠습니다.

## 전선 수천 개를 갈아끼우라고요? 제가요?

폰 노이만 구조가 등장하기 이전의 초기 컴퓨터들은 매우 비효율적인 방식으로 작동했습니다. 

> ENIAC을 이후의 모든 컴퓨터들과 구분짓는 특이한 점 중 하나는, 명령어를 기계에 설정하는 방식이었다. 그것은 소형 천공 카드 기계의 플러그보드와 유사했지만, ENIAC에서는 수 피트 크기의 플러그보드가 약 40개나 있었고, 문제 하나의 명령어마다 다수의 와이어를 꽂아야 했다.
문제 하나를 실행 준비하기 위해서는 수천 개의 와이어를 연결해야 했으며, 이 작업에는 수일이 걸렸고, 그 설정을 검증하는 데에는 더 많은 날들이 필요했다. 
> 
> — Franz L. Alt, "Archaeology of Computers—Reminiscences, 1945–1947,"
Communications of the ACM, Vol. 15, No. 7, July 1972, p. 694.

**결국 에니악에게 프로그램이란 기계의 물리적인 구조 그 자체였습니다**. 마치 새로운 요리를 할 때마다 부엌의 구조를 통째로 바꾸는 것과 같았죠. 논리가 전선에 담겨 있었던 셈입니다.

## 폰 노이만 구조

폰 노이만은 이 문제를 프로그램의 개념 자체를 재정의함으로써 해결했습니다. **프로그램을 하드웨어의 물리적인 배선 상태로 보는 대신, 그저 데이터와 똑같은 정보로 취급한 것입니다.**

이 아이디어가 바로 **내장형 프로그램 방식(Stored-Program Computer)** 이며, 이는 폰 노이만 구조의 심장이 됩니다. 전선을 만질 필요 없이 메모리에 저장된 프로그램만 새로 불러오면 컴퓨터가 완전히 다른 작업을 수행하게 된 것입니다.

이로써 튜링의 보편 튜링 머신은 마침내 현실로 구현되게 됩니다. 하드웨어는 고정된 채 메모리에 어떤 프로그램을 불러오느냐에 따라 기능이 달라지는 범용 기계가 탄생한 것입니다.

<Image src={vonNeumannDiagram} alt="" className="object-cover w-full p-2 bg-white" />

폰 노이만 구조는 컴퓨터를 크게 세 가지 핵심 부분으로 나눕니다. 이 구조는 오늘날 우리가 사용하는 거의 모든 컴퓨터의 기본 설계도입니다.

### 메모리 (Memory)

컴퓨터가 일할 때 필요한 모든 데이터를 저장합니다. 데이터는 크게 두 가지로 나뉩니다:

- 프로그램 (명령어의 집합)
- 데이터 (명령어가 처리할 대상)

메모리의 가장 큰 특징은 각각의 저장 공간이 **숫자 주소**를 갖고 있다는 점입니다. 예를 들어 '100번 주소에 있는 데이터를 가져와라' 또는 '50을 2048번 주소에 저장해라'와 같이 주소를 지정하여 명령을 내리면, 메모리는 해당 위치의 데이터를 즉시 찾아내거나 저장합니다. 

<Memory />

### CPU

메모리에 저장된 명령어를 순서대로 가져와 해석하고, 그에 따라 컴퓨터의 다른 부분들이 움직이도록 제어합니다. CPU 내부는 크게 두뇌의 두 반구처럼, 역할을 분담하는 두 부분으로 나뉩니다.

#### 산술/논리 연산 장치(ALU)와 프로세서 레지스터

제어 장치의 지시를 받아 실제 연산을 수행하는 '일꾼'입니다. 덧셈, 뺄셈 같은 산술 연산뿐만 아니라, '참/거짓'을 판단하는 AND, OR, NOT 같은 논리 연산도 처리합니다. 우리가 시리즈 초반에 논리 게이트(AND, OR, NOT)를 조합하여 가산기를 만들었던 것을 기억하시나요? 바로 그 회로가 더욱 정교하게 발전한 형태가 이 ALU의 심장부를 이루고 있습니다.

#### 제어 장치 (Control Unit)

제어 장치는 메모리에서 '이번에 실행할 명령어는 덧셈'이라는 명령어를 읽어옵니다. 그리고 이 명령을 해석한 뒤, 실제 덧셈을 수행할 연산 장치에 "지금부터 덧셈을 시작해!"라고 지시하고, 메모리에게 "덧셈에 필요한 두 숫자를 내보내!"라고 요청하는 등 전체 작업 과정을 지휘하는 '지휘자' 역할을 합니다.

### 입출력 장치 (Input and output mechanisms)

입출력 장치는 컴퓨터 내부와 사용자를 연결하는 기능을 합니다.

위의 실습 컴포넌트에서는 메모리 내부를 볼 수 있었지만 실제로는 입출력장치가 없다면 메모리 내부에 저장된 데이터를 볼 수 없을 것입니다.

**입력 장치**는 외부의 정보를 컴퓨터가 이해할 수 있는 디지털 신호로 변환하여 전달합니다. 우리가 누르는 키보드의 각 키, 마우스의 움직임과 클릭 등이 대표적인 예입니다. 

**출력 장치**는 반대로 컴퓨터 내부의 처리 결과를 우리가 인지할 수 있는 형태로 변환하여 보여줍니다. 모니터 화면에 나타나는 글자와 이미지, 스피커에서 나오는 소리 등이 여기에 해당합니다. 하드 디스크나 SSD 같은 보조기억장치 역시 CPU의 관점에서는 데이터를 읽고 쓰는 입출력 장치의 일종으로 볼 수 있습니다.

## 실습: 피보나치 수열 계산 따라가기

...

### 마무리: 설계도에서 실제 동작으로

이번 시간에는 튜링의 추상적인 기계가 폰 노이만의 구체적인 설계도를 만나 어떻게 현대 컴퓨터로 발전했는지 살펴보았습니다. 핵심은 **프로그램을 데이터처럼 메모리에 저장**하여 하드웨어의 변경 없이 소프트웨어만으로 다양한 작업을 수행할 수 있게 되었다는 점입니다.

이제 우리는 컴퓨터의 두뇌 역할을 하는 CPU, 작업 공간인 메모리, 그리고 이들을 연결하는 버스라는 멋진 설계도를 손에 넣었습니다.

그렇다면 이제 다음 질문으로 나아갈 차례입니다. CPU는 이 설계도 위에서 도대체 **어떻게** 메모리에 저장된 명령어들을 하나씩 읽고, 해석하고, 실행하는 걸까요? 그 경이로운 작업 루틴은 무엇일까요?

**다음 게시물에서는 드디어 CPU의 심장부로 들어가, 그 유명한 '명령어 사이클(Fetch-Decode-Execute)'이 어떻게 초당 수십억 번씩 반복되며 컴퓨터에 생명을 불어넣는지 알아보겠습니다.**