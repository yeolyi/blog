export const title = '폰 노이만 또 당신이야?';
export const description =
    "'프로그램을 데이터와 같은 공간에 저장한다'는 단순하지만 강력한 아이디어. 이 발상 하나가 어떻게 CPU, 메모리, 버스라는 현대 컴퓨터의 기본 골격을 만들었는지 알아봅시다.";


{/* <Image src={vonNeumann} alt="수학자 존 폰 노이만" className="object-cover w-full h-[240px]" /> */}

지난 게시물에서 우리는 컴퓨터를 '프로그램 가능한 기계'로 정의하고, 앨런 튜링의 보편 튜링 머신을 통해 하드웨어와 소프트웨어를 분리하는 혁신적인 아이디어를 살펴보았습니다. 튜링이 '무엇을' 계산할 수 있는지에 대한 이론적 토대를 마련했다면, 이제 우리는 '어떻게' 그 기계를 현실 세계에 만들 것인가라는 질문에 답해야 합니다.

튜링의 아이디어는 훌륭했지만, 테이프와 헤드로 이루어진 추상적인 모델을 어떻게 실제 전자회로로 구현할 수 있을까요? 이 거대한 도약을 가능하게 한 인물이 바로 수학자 존 폰 노이만(John von Neumann)입니다. 이번 글에서는 현대 컴퓨터 구조의 근간을 이루는 **폰 노이만 구조(Von Neumann architecture)**에 대해 알아보고, 우리가 이전에 만들었던 논리회로들이 어떻게 거대한 컴퓨터의 일부가 되는지 그 설계도를 함께 그려보겠습니다.

### 프로그램을 다시 짜려면, 컴퓨터를 분해해야 하나요?

폰 노이만 구조가 등장하기 이전의 초기 컴퓨터들은 매우 비효율적인 방식으로 작동했습니다. 예를 들어, 최초의 전자식 컴퓨터 중 하나인 '에니악(ENIAC)'은 프로그램을 바꾸려면 기술자들이 직접 전선을 뽑고 다시 연결하는, 말 그대로 '물리적인 재작업'을 거쳐야 했습니다.

{/* <Image src={eniac} alt="에니악의 복잡한 전선들 앞에서 작업하는 기술자들" className="object-cover w-full h-[240px]" /> */}

이는 마치 새로운 요리를 할 때마다 부엌의 구조를 통째로 바꾸는 것과 같았습니다. 덧셈을 하는 기계를 곱셈을 하도록 바꾸려면, 회로 자체를 뜯어고쳐야 했죠. 보편 튜링 머신이 보여준 '프로그램만 바꾸면 되는' 유연성은 아직 현실이 되지 못했습니다. 어떻게 하면 하드웨어는 그대로 둔 채, 요리책의 레시피(프로그램)만 바꿔서 다양한 요리(작업)를 할 수 있을까요?

### 혁신적인 아이디어: 프로그램을 메모리에 저장하라

폰 노이만은 이 문제를 해결할 결정적인 아이디어를 제시합니다. 바로 **내장형 프로그램 방식(Stored-Program Computer)** 입니다. 이 개념의 핵심은 다음과 같습니다.

> **"수행해야 할 명령어들(프로그램)을 그것이 처리할 데이터와 동일한 메모리 공간에 저장한다."**

이 단순해 보이는 문장이 모든 것을 바꾸었습니다. 더 이상 프로그램을 위해 전선을 재배치할 필요가 없어진 것입니다. 프로그램은 이제 데이터와 똑같이 0과 1로 이루어진 비트 덩어리일 뿐이며, 메모리 카드에 사진을 저장하듯 프로그램도 메모리에 저장하고 불러올 수 있게 되었습니다.

이로써 튜링의 '보편 튜링 머신'은 마침내 현실적인 청사진을 얻게 됩니다. 하드웨어는 고정된 채, 메모리에 어떤 프로그램을 불러오느냐에 따라 계산기가 되기도 하고, 문서 편집기가 되기도 하는 진정한 범용 기계가 탄생한 것입니다.

### 현대 컴퓨터의 4가지 핵심 구성요소

폰 노이만 구조는 컴퓨터를 크게 네 가지 핵심 부분으로 나눕니다. 이 구조는 오늘날 우리가 사용하는 거의 모든 컴퓨터(PC, 스마트폰 등)의 기본 설계도입니다.

{/* <Image src={vonNeumannArchitecture} alt="폰 노이만 구조 다이어그램: CPU, 메모리, 입출력 장치가 시스템 버스로 연결되어 있다" className="w-full" /> */}

#### **중앙처리장치 (CPU): 컴퓨터의 총사령관**

컴퓨터의 '두뇌'이자 '총사령관'으로, 모든 계산과 명령 실행을 책임지는 핵심 부품입니다. CPU의 역할은 메모리에 저장된 명령어를 순서대로 가져와 해석하고, 그에 따라 컴퓨터의 다른 부분들이 움직이도록 제어하는 것입니다. CPU 내부는 크게 두뇌의 두 반구처럼, 역할을 분담하는 두 부분으로 나뉩니다.

첫째는 **제어 장치(Control Unit)**입니다. 제어 장치는 메모리에서 '이번에 실행할 명령어는 덧셈'이라는 명령어를 읽어옵니다. 그리고 이 명령을 해석한 뒤, 실제 덧셈을 수행할 연산 장치에 "지금부터 덧셈을 시작해!"라고 지시하고, 메모리에게 "덧셈에 필요한 두 숫자를 내보내!"라고 요청하는 등 전체 작업 과정을 지휘하는 '지휘자' 역할을 합니다.

둘째는 **산술/논리 연산 장치(ALU, Arithmetic/Logic Unit)**입니다. 제어 장치의 지시를 받아 실제 연산을 수행하는 '일꾼'입니다. 덧셈, 뺄셈 같은 산술 연산뿐만 아니라, '참/거짓'을 판단하는 AND, OR, NOT 같은 논리 연산도 처리합니다. 우리가 시리즈 초반에 논리 게이트(AND, OR, NOT)를 조합하여 가산기를 만들었던 것을 기억하시나요? 바로 그 회로가 더욱 정교하게 발전한 형태가 이 ALU의 심장부를 이루고 있습니다.

#### **메모리 장치: CPU의 작업 공간**

메모리는 CPU가 일할 때 필요한 모든 정보, 즉 프로그램(명령어의 집합)과 데이터(명령어가 처리할 대상)를 저장하는 광활한 '작업 공간'입니다. 우리가 흔히 RAM(Random Access Memory)이라고 부르는 부품이 바로 이것입니다. 메모리의 가장 큰 특징은 각각의 저장 공간이 '주소(Address)'라는 고유한 번호를 갖고 있다는 점입니다.

CPU는 이 주소를 이용해 메모리 내의 특정 위치에 정확하고 빠르게 접근할 수 있습니다. 예를 들어 제어 장치가 '100번 주소에 있는 명령어를 가져와라' 또는 '계산 결과 50을 2048번 주소에 저장해라'와 같이 주소를 지정하여 명령을 내리면, 메모리는 해당 위치의 데이터를 즉시 찾아내거나 저장합니다. 이처럼 프로그램과 데이터가 뒤섞여 저장될 수 있는 것은 폰 노이만 구조의 핵심적인 특징입니다.

#### **입출력 장치: 세상과의 소통 창구**

컴퓨터가 아무리 뛰어난 연산을 수행해도 그 결과를 우리가 알 수 없거나, 우리가 원하는 작업을 지시할 수 없다면 아무 소용이 없을 것입니다. 입출력 장치는 이처럼 컴퓨터 내부의 디지털 세상과 사용자, 그리고 다른 기기들 사이의 '소통 창구' 역할을 합니다.

**입력 장치**는 외부의 정보를 컴퓨터가 이해할 수 있는 디지털 신호로 변환하여 전달합니다. 우리가 누르는 키보드의 각 키, 마우스의 움직임과 클릭 등이 대표적인 예입니다. **출력 장치**는 반대로 컴퓨터 내부의 처리 결과를 우리가 인지할 수 있는 형태로 변환하여 보여줍니다. 모니터 화면에 나타나는 글자와 이미지, 스피커에서 흘러나오는 소리 등이 여기에 해당합니다. 하드 디스크나 SSD 같은 보조기억장치 역시 CPU의 관점에서는 데이터를 읽고 쓰는 입출력 장치의 일종으로 볼 수 있습니다.

#### **시스템 버스: 데이터를 실어 나르는 고속도로**

CPU, 메모리, 입출력 장치라는 세 개의 중요한 도시가 있다면, 이 도시들을 연결하여 원활한 소통과 물자 수송이 가능하게 하는 것이 바로 '시스템 버스'라는 고속도로망입니다. 버스는 단순히 하나의 선이 아니라, 데이터의 종류와 목적에 따라 여러 차선으로 나뉩니다.

- **주소 버스(Address Bus):** CPU가 메모리나 입출력 장치의 특정 위치에 접근하고 싶을 때, 해당 위치의 '주소' 정보를 실어 나르는 단방향 도로입니다.
- **데이터 버스(Data Bus):** 주소 버스를 통해 지정된 위치에서 실제 데이터나 명령어를 실어 나르는 양방향 도로입니다. CPU와 메모리, 또는 CPU와 입출력 장치 간에 정보가 오고 갑니다.
- **제어 버스(Control Bus):** CPU가 다른 장치들의 동작을 제어하기 위한 신호를 보내는 도로입니다. '지금 메모리에서 데이터를 읽을 타이밍이다' 또는 '장치에 데이터를 쓸 준비가 되었다'와 같은 제어 신호가 이 버스를 통해 전달됩니다.

이 세 종류의 버스가 쉴 새 없이 정보를 실어 나르기 때문에, 컴퓨터의 각 부품은 조화롭게 협력하며 작업을 수행할 수 있습니다.

### 한눈에 보기: 피보나치 수열 계산 따라가기

자, 그럼 이 구성요소들이 실제로 어떻게 함께 일하는지 구체적인 예시를 통해 살펴볼까요? 5번째 피보나치 수를 구하는 간단한 프로그램을 폰 노이만 구조의 컴퓨터가 어떻게 실행하는지 단계별로 따라가 보겠습니다. (실제 명령어는 훨씬 복잡하지만, 이해를 돕기 위해 단순화했습니다.)

먼저, 우리 프로그램과 데이터가 메모리에 아래와 같이 저장되었다고 상상해봅시다.

**메모리 상태:**

| 주소 | 저장된 내용 (명령어 또는 데이터) | 설명                                         |
| :--- | :------------------------------- | :------------------------------------------- |
| 10   | `LOAD 100`                       | 100번 주소의 값을 CPU로 불러온다 (a=0)       |
| 11   | `ADD 101`                        | 101번 주소의 값을 더한다 (a+b)               |
| 12   | `STORE 100`                      | 계산 결과를 100번 주소에 저장한다 (새로운 b) |
| ...  | ...                              | ...                                          |
| 100  | 0                                | 변수 a의 값                                  |
| 101  | 1                                | 변수 b의 값                                  |

**계산 과정 (첫 번째 덧셈):**

1.  **명령어 가져오기 (Fetch):**
    - **CPU 제어 장치**가 "다음 실행할 명령어는 10번 주소에 있다"고 판단합니다.
    - **주소 버스**에 `10`이라는 주소 정보를 싣습니다.
    - **메모리**는 10번 주소를 확인하고, 그곳에 저장된 `LOAD 100`이라는 명령어 데이터를 **데이터 버스**에 실어 CPU로 보냅니다.

2.  **명령어 해석하기 (Decode):**
    - CPU 제어 장치는 `LOAD 100`이 "100번 주소에 있는 데이터를 가져오라"는 뜻임을 해석합니다.

3.  **데이터 가져오기 (Fetch Data):**
    - 제어 장치가 다시 **주소 버스**에 `100`을 싣습니다.
    - 메모리는 100번 주소의 데이터 `0`을 **데이터 버스**에 실어 CPU로 보냅니다.
    - CPU는 이 데이터 `0`을 내부의 임시 저장 공간(레지스터)에 저장합니다.

4.  **다음 명령어 실행 (ADD):**
    - 제어 장치는 다음 명령어인 `ADD 101`을 같은 방식으로 가져와 해석합니다.
    - 주소 버스와 데이터 버스를 통해 101번 주소의 데이터 `1`을 가져옵니다.
    - 이제 CPU는 이전에 가져온 `0`과 방금 가져온 `1`을 **ALU(산술/논리 연산 장치)**로 보냅니다.

5.  **계산 및 저장 (Execute & Store):**
    - ALU가 `0 + 1`을 계산하여 `1`이라는 결과를 내놓습니다.
    - 세 번째 명령어 `STORE 100`이 실행됩니다. CPU는 계산 결과 `1`을 100번 주소에 덮어쓰도록 메모리에 명령합니다.
    - 이제 100번 주소의 값은 `0`에서 `1`로 바뀌었습니다.

이처럼 단순한 '덧셈' 한 번을 위해 CPU와 메모리, 버스는 쉴 새 없이 주소와 데이터를 주고받습니다. 컴퓨터는 이 과정을 눈 깜짝할 사이에 수억 번 반복하며 복잡한 프로그램을 실행하는 것입니다.

### 폰 노이만 구조의 한계: 피할 수 없는 병목 현상

이처럼 효율적인 폰 노이만 구조에도 한 가지 태생적인 단점이 존재합니다. 바로 **폰 노이만 병목 현상(Von Neumann bottleneck)**입니다.

위의 피보나치 예시처럼, CPU가 아무리 빨라도 메모리에서 명령어와 데이터를 가져오는 통로(시스템 버스)는 하나뿐입니다. CPU는 '명령어를 가져오는 작업'과 '데이터를 가져오는 작업'을 동시에 할 수 없습니다. 이 때문에 CPU가 종종 메모리가 데이터를 준비해줄 때까지 기다려야 하는 상황이 발생하죠. 이 병목 현상은 컴퓨터 전체의 성능을 저하시키는 주요 원인이 됩니다. (그리고 바로 이 문제를 해결하기 위해 '캐시 메모리'와 같은 아이디어들이 등장하게 됩니다!)

### 마무리: 설계도에서 실제 동작으로

이번 시간에는 튜링의 추상적인 기계가 폰 노이만의 구체적인 설계도를 만나 어떻게 현대 컴퓨터로 발전했는지 살펴보았습니다. 핵심은 **프로그램을 데이터처럼 메모리에 저장**하여 하드웨어의 변경 없이 소프트웨어만으로 다양한 작업을 수행할 수 있게 되었다는 점입니다.

이제 우리는 컴퓨터의 두뇌 역할을 하는 CPU, 작업 공간인 메모리, 그리고 이들을 연결하는 버스라는 멋진 설계도를 손에 넣었습니다.

그렇다면 이제 다음 질문으로 나아갈 차례입니다. CPU는 이 설계도 위에서 도대체 **어떻게** 메모리에 저장된 명령어들을 하나씩 읽고, 해석하고, 실행하는 걸까요? 그 경이로운 작업 루틴은 무엇일까요?

**다음 게시물에서는 드디어 CPU의 심장부로 들어가, 그 유명한 '명령어 사이클(Fetch-Decode-Execute)'이 어떻게 초당 수십억 번씩 반복되며 컴퓨터에 생명을 불어넣는지 알아보겠습니다.**