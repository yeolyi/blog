export const title = '컴퓨터 조립법은 폰 노이만에게 물어보기';
export const description =
   "'프로그램을 데이터와 같은 공간에 저장한다'는 단순하지만 강력한 아이디어. 이 발상 하나가 어떻게 CPU, 메모리, 버스라는 현대 컴퓨터의 기본 골격을 만들었는지 알아봅시다.";

import turingMachine from './assets/turing-machine.png';
import vonNeumann from './assets/von-neumann.png';
import vonNeumannDiagram from './assets/von-neumann-diagram.png';
import { Memory } from './components/Memory';
import { ALU } from './components/ALU';
import { InstructionDecoder } from './components/InstructionDecoder';
import { InstructionSetTable } from './components/InstructionSetTable';
import { MonitorSimulator } from './components/MonitorSimulator';

<Image src={turingMachine} alt="" className="object-cover w-full h-[240px] object-top" caption="영화 '이미테이션 게임'"/>

지난 게시물에서는 컴퓨터를 **프로그래밍 가능한 기계**로 정의하고, 하드웨어와 소프트웨어를 분리한다는 아이디어를 튜링 머신을 통해 살펴보았습니다. 튜링이 계산하는 기계에 대한 이론적 토대를 마련했지만 여전히 중요한 질문이 남아있었습니다. 어떻게 그 기계를 현실 세계에 구현할 수 있을까요?

<Image src={vonNeumann} alt="" className="object-cover w-full h-[240px] object-top" />

이때 등장한 인물이 바로 미국의 컴퓨터과학자이자 수학자이자 과학자이자 경제학자였던 존 폰 노이만입니다. 그가 1945년에 제시한 **폰 노이만 구조**는 오늘날 여러분의 스마트폰부터 슈퍼컴퓨터까지, 거의 모든 컴퓨터가 따르고 있는 기본 설계 원리입니다.

이번 글에서는 폰 노이만의 핵심 아이디어가 무엇인지 알아보고, 우리가 이전에 만들었던 논리 게이트들이 어떻게 CPU, 메모리, 버스라는 거대한 시스템의 일부가 되는지 큰 그림을 그려보겠습니다. 80년 전의 발상이 어떻게 현대 컴퓨터의 기초가 되었는지 확인해보세요.

## 전선 수천 개를 갈아끼우라고요...?

폰 노이만 구조가 등장하기 이전의 초기 컴퓨터들은 매우 비효율적인 방식으로 작동했습니다. 다음 자료를 살펴보시죠:

> ENIAC을 이후의 모든 컴퓨터들과 구분짓는 특이한 점 중 하나는, 명령어를 기계에 설정하는 방식이었다. 그것은 소형 천공 카드 기계의 플러그보드와 유사했지만, ENIAC에서는 수 피트 크기의 플러그보드가 약 40개나 있었고, 문제 하나의 명령어마다 다수의 와이어를 꽂아야 했다.
문제 하나를 실행 준비하기 위해서는 수천 개의 와이어를 연결해야 했으며, 이 작업에는 수일이 걸렸고, 그 설정을 검증하는 데에는 더 많은 날들이 필요했다. 
> 
> Franz L. Alt, "Archaeology of Computers—Reminiscences, 1945–1947,"
Communications of the ACM, Vol. 15, No. 7, July 1972, p. 694.

결국 ENIAC에게 **프로그램이란 기계의 물리적인 구조 그 자체였습니다**. 이는 마치 새로운 요리를 할 때마다 부엌의 구조를 통째로 바꾸는 것과 같았죠.

## 폰 노이만 구조

폰 노이만은 이 문제를 프로그램의 개념 자체를 재정의함으로써 해결했습니다. **프로그램을 하드웨어의 물리적인 배선 상태로 보는 대신 데이터로 취급한 것입니다.** 이는 새로운 요리를 할 때 부엌은 가만히 있고 새로운 요리법만 참고하는 것과 같습니다.

이 아이디어가 바로 폰 노이만 구조의 핵심인 **내장형 프로그램 방식(Stored-Program Computer)** 입니다. 전선을 만질 필요 없이 메모리에 저장된 프로그램만 새로 불러오면 컴퓨터가 완전히 다른 작업을 수행하게 된 것입니다. 

<Image src={vonNeumannDiagram} alt="" className="object-cover w-full p-2 bg-white" />

폰 노이만 구조의 구성요소를 살펴봅시다. 크게 메모리, CPU, 입출력 장치로 나뉩니다.

## 메모리 (Memory)

컴퓨터가 일할 때 필요한 모든 정보를 저장합니다. 이 정보는 **명령어(프로그램)** 와, 명령어가 처리할 실제 **데이터**로 나뉩니다.

메모리의 가장 큰 특징은 각각의 저장 공간이 **숫자 주소**를 갖고 있다는 점입니다. 예를 들어 '100번 주소에 있는 데이터를 가져와라' 또는 '2048번 주소에 50을 저장해라'와 같이 주소를 지정하여 명령을 내리면 메모리는 해당 위치의 데이터를 즉시 찾아내거나 저장합니다. 

C언어를 다뤄보셨다면 포인터를 통해 메모리 주소를 다루는 것이 익숙할 것입니다. 예를 들어 아래 코드에서는 `0x16ef06ca8`라는 메모리 주소에 `10`이라는 데이터가 저장되어있습니다.

```c
#include <stdio.h>

int main() {
  int a = 10;
  int *p = &a;
  printf("%p\n", p);   // 0x16ef06ca8
  printf("%d\n", *p);  // 10
  return 0;
}
```

아래 메모리 시뮬레이터에서 주소를 통해 데이터를 읽고 써보세요:

<Memory />

## CPU

CPU는 메모리에 저장된 프로그램을 순서대로 가져와 **해석**하고, 그에 따라 컴퓨터의 다른 부분들이 움직이도록 **제어**합니다. 중앙 처리 장치(Central Processing Unit)라는 이름에 걸맞죠?

CPU는 크게 제어 장치, 레지스터, ALU로 나뉩니다. 순서대로 살펴볼게요.

### 제어 장치

메모리에서 명령어를 가져와 해독하고, 컴퓨터의 다른 부분에 적절한 신호를 보내 작업을 지시합니다. 예를 들어, 메모리에서 '덧셈' 명령을 읽었다면, ALU에는 '덧셈을 수행하라'고 명령하고, 메모리는 덧셈에 필요한 두 숫자를 가져오라고 지시하는 식이죠.

이때 제어 장치가 이해하는 명령어는 0과 1로 이루어진 **기계어**입니다. 아래는 예제를 위해 제가 만든 아주아주 단순한 **8비트 기계어 규칙표**입니다. 

<InstructionSetTable />

아래 디코더에 위 규칙에 맞는 기계어를 입력해 제어 장치가 ALU/레지스터/메모리에게 어떤 작업을 명령하는지 확인해보세요.

<InstructionDecoder />

### 레지스터 

위 제어장치 시뮬레이터의 규칙표를 보면 '레지스터에 저장', '레지스터에 불러옴'같은 표현들을 보실 수 있습니다. 레지스터는 CPU 내부에 있는 초고속 임시 저장소로, **연산에 필요한 데이터를 잠깐 보관하는 역할**을 합니다. 

### ALU

제어 장치의 지시를 받아 실제 연산을 수행합니다. 덧셈, 뺄셈 같은 산술 연산뿐만 아니라, '참/거짓'을 판단하는 AND, OR, NOT 같은 논리 연산도 처리합니다. 우리가 시리즈 초반에 논리 게이트(AND, OR, NOT)를 조합하여 가산기를 만들었던 것을 기억하시나요? 바로 그 회로가 더욱 정교하게 발전한 형태가 이 ALU를 구성합니다.

아래 시뮬레이터로 ALU의 동작을 직접 확인해보세요. 두 숫자를 입력하고 여러가지 연산을 수행하면서 결과와 상태 플래그가 어떻게 변하는지 관찰해보세요.

<ALU />

## 입출력 장치

입출력 장치는 CPU가 세상과 소통하는 창구입니다. 키보드로 글자를 입력받고, 마우스로 좌표를 읽고, 모니터에 결과를 표시하는 모든 과정이 여기에 해당합니다.

**입출력 장치를 구현하는 한 가지 흥미로운 방법은 메모리를 활용하는 것입니다**. 특정 메모리 주소 영역을 입출력 장치와 미리 약속해두고, CPU는 그저 해당 주소에 값을 읽거나 쓰는 방식으로 장치를 제어합니다.

예를 들어, 메모리의 특정 영역을 모니터 화면의 픽셀과 일대일로 매칭해둘 수 있습니다. CPU가 해당 메모리 주소에 1(검은색)이라는 값을 쓰면, 모니터의 해당 픽셀이 검게 칠해지고 0(흰색)을 쓰면 하얗게 칠해지는 식이죠. 키보드 역시 특정 메모리 주소에 마지막으로 눌린 키의 코드를 계속해서 써주는 방식으로 작동할 수 있습니다. CPU는 그저 해당 메모리를 주기적으로 읽기만 하면 키 입력을 받아올 수 있습니다.

아래는 10x10 크기의 모니터와 여기에 연결된 비디오 메모리(VRAM)를 흉내낸 시뮬레이터입니다. 메모리 값을 직접 바꿔보며 화면이 어떻게 변하는지 관찰해보세요.

<MonitorSimulator />

## 마무리

이번 시간에는 튜링 머신이 폰 노이만 구조를 통해 어떻게 현실에 구현되었는지 살펴보았습니다. 프로그램을 하드웨어의 배선이 아닌 메모리에 저장되는 데이터로 취급함으로써, 하드웨어 변경 없이 소프트웨어만으로 다양한 작업을 수행할 수 있게 되었습니다.

폰 노이만 구조의 핵심 구성 요소들도 살펴보았습니다. 프로그램과 데이터를 주소 기반으로 저장하는 **메모리**, 명령어를 해석하는 제어 장치와 연산을 수행하는 ALU 그리고 임시 저장소인 레지스터로 구성된 **CPU**, 그리고 사용자와 컴퓨터를 연결하는 **입출력 장치**까지요.

그런데 여기서 중요한 질문이 하나 남았습니다. 메모리에 저장된 10110000같은 기계어 명령어가 실제로는 어떤 과정을 거쳐 CPU에서 처리되는 걸까요? 제어 장치가 명령어를 '해석한다'고 했지만, 구체적으로 어떤 단계를 거치며, ALU와 레지스터는 언제 개입하고, 그 결과는 언제 어디로 가는 걸까요?

다음 글에서는 CPU의 기본 작업 사이클인 **Fetch-Decode-Execute-Write Back**을 살펴보며 이 궁금증을 해결해보겠습니다. 하나의 명령어가 처리되는 전 과정을 단계별로 따라가보면서, 여러분이 지금 이 글을 읽고 있는 순간에도 컴퓨터 속에서 초당 수십억 번씩 반복되고 있는 이 사이클을 직접 확인해보겠습니다.
