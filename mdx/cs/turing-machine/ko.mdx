export const title = '계산만하면 계산기지 그게 컴퓨터니?';

import abacus from './assets/abacus.png';
import tools from './assets/tools.png';
import vonNeumann from './assets/von-neumann.png';
import entscheidungsproblem from './assets/entscheidungsproblem.png';
import TuringMachine from './components/TuringMachine';

<Image src={abacus} alt="" className="object-cover w-full h-[180px]"/>

지금까지 우리가 만들어온 것들을 돌아보면 컴퓨터라기보다는 계산기에 더 가까워 보입니다. 앞선 게시물들에서는 숫자를 0과 1로 표현해 덧셈과 뺄셈을 수행하는 회로를 구현해보았습니다. 만약 사진을 0과 1로 표현한다면, 그 사진을 편집할 수 있는 회로도 만들어볼 수 있을 것입니다.

하지만 이런 회로들만으로는 우리가 익숙하게 사용하는 ‘컴퓨터’라고 부르기엔 어딘가 부족함이 느껴집니다.

<Image src={tools} alt="" className="object-cover w-full h-[180px]"/>

**컴퓨터와 다른 도구들 사이에는 근본적인 차이가 있습니다.** 왜 우리가 만든 회로들이 컴퓨터처럼 느껴지지 않을까요? 이는 단순히 기능의 개수 문제가 아닙니다. 메모장, 게임, 음악 재생 등 아무리 많은 기능을 추가해도 여전히 "특정 작업들만 할 수 있는 장치"일 뿐이거든요. 

가위는 '자르는 것', 컵은 '담는 것'처럼 하나의 명확한 역할로 정의할 수 있지만, 컴퓨터는 이런 식으로 단순하게 정의할 수 없습니다. 컴퓨터에는 다른 도구들과는 다른, 더 본질적인 특성이 있는 것 같습니다.

<Image src={vonNeumann} alt="" className="object-cover w-full h-[180px]"/>

그렇다면 무엇을 만들어야 컴퓨터를 만들었다고 할 수 있을까요? 이 시리즈의 목표는 컴퓨터를 직접 만들어보는 것이었지만 사실 우리는 컴퓨터가 무엇인지도 명확히 정의하지 않았습니다. **이번 글에서는 컴퓨터가 무엇인지 정의하고 지금까지 배운 내용이 모여 어떻게 컴퓨터가 구성되는지 살펴보겠습니다.**

## 튜링 머신: 계산의 본질을 찾아서

컴퓨터와 다른 도구들 사이의 근본적인 차이가 무엇인지 알아보려면 한 수학자의 아이디어부터 살펴봐야 합니다. 영국의 앨런 튜링이 1936년에 발표한 '계산 가능한 수'라는 [논문](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)에서 제안한 **튜링 머신**이 바로 그 출발점이죠.

<Image src={entscheidungsproblem} alt="" className="object-cover object-top w-full h-[180px]"/>

튜링이 이 개념을 제안한 배경에는 당시 수학계의 중요한 문제가 있었습니다. 다비트 힐베르트가 제기한 무시무시한 이름의 '결정 문제(Entscheidungsproblem)'는 

> 주어진 수학 명제가 참인지 거짓인지를 기계적으로 판단할 수 있는가?

라는 질문이었습니다. 튜링은 이 문제를 해결하기 위해 우선 '계산'이라는 개념 자체를 정의했고, 그 결과가 바로 튜링 머신입니다.

### 튜링 머신의 구조

튜링 머신의 구조는 놀랍도록 단순합니다. 긴 **테이프**, 이 테이프 위에서 기호를 읽거나 쓸 수 있는 **헤드**, 그리고 현재 기계의 상태와 규칙을 저장하는 **제어 장치**. 이게 전부입니다. 헤드는 테이프 위의 기호를 읽고, 정해진 규칙에 따라 테이프에 새로운 기호를 쓰거나, 테이프를 왼쪽 또는 오른쪽으로 한 칸씩 이동시킵니다.

이렇게 단순한 동작들의 조합만으로 계산 가능한 모든 과정을 표현할 수 있다는 것이 튜링의 통찰이었습니다.
복잡한 수학 문제나 논리적 추론조차 이 모델로 기술 가능합니다.


튜링 머신의 동작을 확인할 수 있는 시뮬레이터를 준비했습니다. 아래 튜링 머신은 아래 규칙을 통해 테이프의 각 비트를 반전시킵니다. 

- 0을 만나면 1로 바꾸고 오른쪽으로 이동
- 1을 만나면 0으로 바꾸고 오른쪽으로 이동
- 빈 칸(_)을 만나면 작업을 중지

단순한 읽기-쓰기-이동 동작의 반복만으로 비트 문자열이 어떻게 반전되는지 확인해보세요.

<TuringMachine
  initialTape={Array.from('01010_')}
  initialHeadIdx={0}
  rulesCsv={`
q0,0,q0,1,R
q0,1,q0,0,R
q0,_,q_halt,_,_
`}
/>

튜링머신이 모든 계산 가능한 과정을 표현할 수 있다고 했는데, 너무 단순한 예제였나요? 아래는 덧셈을 하는 튜링 머신입니다. 111<sub>2</sub> + 10<sub>2</sub> = 1001<sub>2</sub> 이 계산되는 것을 확인해보세요. 자세한 동작 원리를 알고 싶다면 [출처](https://stackoverflow.com/a/63309182/30126918)를 참고하세요.

<TuringMachine
  initialTape={Array.from('_111_10_')}
  initialHeadIdx={1}
  rulesCsv={`
q0,0,q0,0,R
q0,1,q0,1,R
q0,_,q1,_,R

q1,0,q1,0,R
q1,1,q1,1,R
q1,_,q2,_,L

q2,0,q2,1,L
q2,1,q3,0,L
q2,_,q5,_,R

q3,0,q3,0,L
q3,1,q3,1,L
q3,_,q4,_,L

q4,0,q0,1,R
q4,1,q4,0,L
q4,_,q0,1,R

q5,0,q5,_,R
q5,1,q5,_,R
q5,_,q_halt,_,N
`}
/>

이처럼 튜링 머신은 매우 단순한 규칙들의 집합으로 복잡한 계산을 수행할 수 있습니다. 하지만 이대로면 여느 도구들과 다를 바가 없습니다. 튜링 머신이라는 신기하게 생긴 기계를 고안했지만 여전히 문자열을 반전시키거나 덧셈을 하는 특수한 도구일 뿐입니다.

## 보편 튜링 머신

여기서 튜링의 또다른 아이디어가 등장합니다. 하나의 특별한 튜링 머신으로 다른 모든 튜링 머신을 시뮬레이션할 수 있다는 것이죠. 이것이 바로 **보편 튜링 머신(Universal Turing Machine)** 입니다.

일반 튜링 머신은 위에서 살펴봤듯이 고정된 상태 집합과 규칙을 가지고 있어서 설계된 목적 외의 작업은 전혀 할 수 없습니다. 새로운 작업을 하려면 완전히 새로운 기계를 만들어야 했습니다.

하지만 보편 튜링 머신은 완전히 다른 접근법을 취합니다. 이 기계는 **다른 기계를 시뮬레이션**합니다. 테이프에 적힌 **프로그램**(다른 튜링 머신의 규칙들)을 읽어서, 마치 그 프로그램에 해당하는 특수한 튜링 머신인 것처럼 동작할 수 있습니다. 보편 튜링 머신은 다음과 같은 과정을 반복합니다:

1. 입력된 프로그램에서 현재 상태에 해당하는 규칙을 찾음
1. 그 규칙에 따라 테이프를 수정하고 상태를 변경
1. 1번으로 돌아가 반복

덧셈 프로그램을 넣으면 덧셈기가 되고, 곱셈 프로그램을 넣으면 곱셈기가 되는 것입니다. **하드웨어는 그대로 둔 채 소프트웨어만 바꾸면 되는 거죠.**

편집 버튼을 추가해 튜링 머신 시뮬레이터에서 규칙을 수정할 수 있게 만들었습니다. 비트를 반전시키는 튜링 머신 프로그램을 전부 0으로 만들거나 1로 만드는 프로그램으로 수정해보세요. 프로그램은 제어장치 테이블과 동일한 구조의 CSV 문자열을 사용합니다.

<TuringMachine
  initialTape={Array.from('11010_')}
  initialHeadIdx={0}
  rulesCsv={`
q0,0,q0,1,R
q0,1,q0,0,R
q0,_,q_halt,_,_
`}
  editable
/>

### 보편 튜링 머신의 의의

보편 튜링 머신이 제시한 가장 중요한 통찰은, **하드웨어는 고정된 채로 프로그램만 바꿔 다양한 작업을 수행할 수 있다는 아이디어**였습니다. 과거 계산 장치들은 덧셈을 위한 기계, 곱셈을 위한 기계처럼 각 작업마다 별도의 물리적 구조로 설계되어야 했습니다. 하지만 튜링은 하나의 범용 기계로도 모든 계산 작업을 수행할 수 있다는 점을 이론적으로 증명했습니다. 핵심은 작업 방식을 물리적인 구조가 아닌 기계에 공급되는 규칙 집합, 즉 프로그램으로 바꾼다는 것이었고, 이로써 하드웨어와 소프트웨어의 개념적 분리가 본격적으로 등장하게 됩니다.

이 발상은 당시의 사고방식을 크게 바꾼 전환점이었는데, **기계가 수행할 논리를 마치 데이터처럼 다룬다는 개념이 바로 오늘날 프로그래밍의 출발점이 되었기 때문입니다**. 이후 프로그램 저장 방식, 컴파일러, 운영체제 같은 소프트웨어 개념들이 발전할 수 있었던 것도 이러한 이론적 토대가 있었기에 가능했습니다. 

## 컴퓨터의 정의

마침내 컴퓨터를 정의내려봅시다. 위키피디아에서는 컴퓨터를 다음과 같이 정의합니다: 

> A computer is a machine that can be programmed to automatically carry out sequences of arithmetic or logical operations (computation).

> 컴퓨터는 산술 또는 논리 연산(계산)의 일련의 과정을 자동으로 수행하도록 프로그래밍할 수 있는 기계이다.

이 정의를 우리가 살펴본 내용으로 해석해보면, **컴퓨터의 핵심은 프로그램 가능한(can be programmed) 기계라는 점입니다**. 가위가 '자르는 것', 컵이 '담는 것'으로 정의되는 것과 달리, 컴퓨터는 '프로그램을 통해 다양한 계산을 수행할 수 있는 것'으로 정의됩니다. 

이것이 서론에서 느꼈던 '무언가 부족한 느낌'의 정체였습니다. 우리가 지금까지 만든 회로들은 특정 작업만 수행할 수 있었지, 프로그램을 통해 다양한 작업을 수행할 수는 없었거든요. 바로 이것이 일반적인 도구와 컴퓨터의 결정적 차이입니다.

## 마무리: 이론에서 현실로

**우리가 사용하는 컴퓨터는 본질적으로 보편 튜링 머신의 구현체입니다**. 그렇다면 튜링의 추상적 아이디어는 어떻게 구체적인 하드웨어로 구현될 수 있었을까요?

핵심은 튜링 머신의 각 구성 요소를 물리적 장치로 대응시키는 것입니다. **CPU**는 튜링 머신의 상태 전이와 명령 해석 기능을 담당하는 중심 장치가 되었고, **메모리**는 테이프처럼 프로그램과 데이터를 저장하는 공간 역할을 합니다. 우리가 작성한 **프로그램**은 튜링 머신의 규칙 집합, 즉 어떤 입력에 어떤 출력을 내야 하는지 정의하는 명령의 모음인 셈입니다.

그런데 이 과정에서 핵심적인 역할을 한 것이 바로 지금까지 배운 논리 게이트와 회로들입니다. 다음 글에서는 이러한 기초 구성 요소들이 어떻게 모여서 실제 컴퓨터의 복잡한 기능을 구현하는지 자세히 살펴보겠습니다.
