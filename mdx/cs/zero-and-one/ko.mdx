export const title = '컴퓨터가 세상을 0과 1로만 보는 이유'

import RGBSlider from './components/RGBSlider';


안녕하세요! "만들면서 배우는 컴퓨터 공학" 시리즈에 오신 것을 환영합니다.

컴퓨터는 어떻게 0과 1만으로 세상을 바꿀 수 있었을까요? 이 시리즈는 컴퓨터 공학을 배우며 제가 느꼈던 경이로움을 여러분과 나누고자 시작되었습니다. 아주 작고 단순한 것들이 모여 복잡한 컴퓨터 시스템을 이루는 과정을 함께 따라가면서, 논리 설계, 컴퓨터 구조, 운영체제 등 흩어져 있던 컴퓨터 과학(CS) 지식들을 하나의 큰 그림으로 연결해 보고자 합니다. 책이나 영상에서는 보기 힘든 인터랙티브 예제를 통해 직접 만들며 배우는 즐거움을 느껴보세요! CS 공부를 시작하려는 개발자, 컴퓨터의 속사정이 궁금하신 분, 심지어 게임 속에서 컴퓨터를 어떻게 만드는지 궁금했던 분들까지 모두 환영합니다.

자, 그럼 컴퓨터 세상을 이루는 가장 기본적인 벽돌, '비트' 이야기부터 시작해 볼까요?

### 정보는 어떻게 측정될까? 비트와 정보 이론의 만남

컴퓨터가 사용하는 0과 1, 이 가장 작은 정보 단위를 **비트(Bit)**라고 부른다고 했죠. 그런데 이 '비트'는 단순히 'Binary Digit(이진 숫자)'의 줄임말을 넘어, 정보 그 자체를 측정하는 단위이기도 합니다. 이 개념은 '정보 이론의 아버지'라 불리는 **클로드 섀넌(Claude Shannon)**에 의해 정립되었습니다.

섀넌은 정보를 **'불확실성의 감소'**로 정의했습니다. 어떤 메시지를 받았을 때, 우리가 그 메시지의 내용을 알기 전의 불확실성이 줄어드는 정도가 바로 그 메시지가 가진 정보량이라는 것입니다. 가장 기본적인 불확실성은 '예/아니오', '참/거짓', '동전의 앞/뒤'처럼 똑같은 확률을 가진 두 가지 선택지 중 하나를 알아맞히는 상황입니다. 이 정도의 불확실성을 해소하는 데 필요한 정보량을 바로 **1비트**라고 정의한 것이죠.

> **깊이 생각하기:** 섀넌의 관점에서 보면, '내일 해가 동쪽에서 뜬다'는 메시지는 정보량이 거의 0에 가깝습니다. 왜냐하면 너무나 당연해서 불확실성을 거의 줄여주지 못하기 때문이죠. 반면, '내일 로또 1등 당첨 번호는 XXX이다'라는 메시지는 (사실이라면) 엄청난 정보량을 가집니다. 결과를 전혀 예측할 수 없는 상태에서 불확실성을 완전히 해소해주기 때문입니다. 컴퓨터가 사용하는 비트는 바로 이 정보량의 기본 단위인 셈입니다.
> * [Information Theory - Bits and Binary Digits (Stanford)](https://cs.stanford.edu/people/eroberts/courses/soco/projects/1999-00/information-theory/information_1.html)
> * [How Claude Shannon Invented the Future (Quanta Magazine)](https://www.quantamagazine.org/how-claude-shannons-information-theory-invented-the-future-20201222/)

### 0과 1만으로 숫자 표현하기: 이진수 체계

컴퓨터는 0과 1만을 사용하여 모든 숫자를 표현하는 **이진수(Binary number system)** 체계를 사용합니다. 우리가 일상에서 사용하는 10진수는 0부터 9까지 10개의 숫자를 사용하고, 각 자리가 10의 거듭제곱($10^0, 10^1, 10^2, \dots$)을 나타내는 것과 비슷합니다. 이진수는 0과 1 두 개의 숫자만 사용하고, 각 자리가 2의 거듭제곱($2^0, 2^1, 2^2, \dots$)을 나타냅니다.

예시:
* 10진수 0 = $0_2$
* 10진수 1 = $1_2$
* 10진수 2 = $10_2$ ($1 \times 2^1 + 0 \times 2^0$)
* 10진수 3 = $11_2$ ($1 \times 2^1 + 1 \times 2^0$)
* 10진수 5 = $101_2$ ($1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0$)

이진수 덧셈도 간단한 규칙에 따라 수행됩니다. 예를 들어 $1 + 1$ 은 10진수로는 2지만, 이진수로는 $10_2$ (읽을 때는 '일영')이 됩니다. ($1_2 + 1_2 = 10_2$) 이는 컴퓨터가 내부적으로 수행하는 가장 기본적인 연산 중 하나입니다.

### 비트로 세상의 모든 정보 표현하기 (심화)

0과 1의 조합이 어떻게 다양한 정보를 표현하는지 좀 더 자세히 살펴보겠습니다.

* **글자 (Text):**
    * **ASCII (아스키 코드):** 초기에 영문 알파벳, 숫자, 특수문자 등을 표현하기 위해 7비트(128개 문자) 또는 8비트(256개 문자, 확장 아스키)를 사용했습니다. 각 문자에 고유한 숫자(비트 조합)를 할당하는 방식입니다. 예를 들어, 대문자 'A'는 65 (이진수 $01000001_2$)로 약속되어 있습니다.
    * **Unicode (유니코드):** 전 세계의 거의 모든 문자를 표현하기 위한 표준입니다. 각 문자에 고유한 코드 포인트를 부여하고, 이를 **UTF-8**과 같은 가변 길이 인코딩 방식을 사용해 1바이트에서 4바이트까지의 비트열로 표현합니다. 이를 통해 아스키 코드와의 호환성을 유지하면서도 다양한 언어를 효율적으로 표현할 수 있습니다.
* **색상 (Color):**
    * **RGB:** 빛의 삼원색(빨강, 초록, 파랑)의 강도를 조합하여 색을 표현합니다. 각 색상의 강도를 몇 비트로 표현하느냐에 따라 표현 가능한 색상의 수가 결정됩니다. 예를 들어, 각 색상 채널당 8비트(0~255, 총 24비트)를 사용하는 '트루 컬러(True Color)' 방식은 약 1670만 가지($2^{24}$) 색상을 표현할 수 있습니다. `#FF0000` (HTML 색상 코드)는 빨강(R) 255, 초록(G) 0, 파랑(B) 0을 의미합니다.
* **이미지 (Image):**
    * **비트맵(Bitmap) 이미지:** 이미지를 **픽셀(Pixel)**이라는 작은 사각형 점들의 격자로 나눕니다. 각 픽셀의 색상 정보를 비트로 저장합니다. 이미지의 **해상도(Resolution)**는 가로세로 픽셀 수 (예: 1920x1080)를 의미하며, **색 깊이(Color Depth)**는 각 픽셀의 색상을 표현하는 데 사용되는 비트 수 (예: 24비트 트루 컬러)를 의미합니다. 색 깊이가 높을수록 더 풍부한 색상 표현이 가능하지만, 파일 크기가 커집니다. (JPG, PNG, GIF 등이 비트맵 방식입니다.)
    * **(참고) 벡터(Vector) 이미지:** 점, 선, 곡선 등의 수학적 방정식을 이용해 이미지를 표현합니다. 확대해도 깨지지 않는 장점이 있지만, 사진과 같은 복잡한 이미지를 표현하기는 어렵습니다. (SVG, AI 등이 벡터 방식입니다.)
* **음악 (Audio):**
    * **PCM (Pulse Code Modulation):** 아날로그 소리 파형을 디지털로 변환하는 가장 기본적인 방식입니다. 일정한 시간 간격으로 소리 파형의 높이(진폭)를 측정(**샘플링, Sampling**)하고, 그 값을 이진수(비트)로 기록합니다.
        * **샘플링 레이트(Sampling Rate):** 1초당 샘플링하는 횟수 (단위: Hz). CD 음질은 보통 44.1kHz (44,100번/초)입니다. 샘플링 레이트가 높을수록 원음에 가까운 고주파수 소리까지 기록할 수 있습니다.
        * **비트 깊이(Bit Depth):** 각 샘플 값을 표현하는 데 사용되는 비트 수. CD 음질은 16비트입니다. 비트 깊이가 높을수록 더 미세한 소리의 강약 차이를 표현할 수 있습니다 (다이나믹 레인지 증가).

<RGBSlider />

### 컴퓨터는 왜 굳이 0과 1만 고집할까? (심화)

왜 0, 1, 2 세 가지 상태(Ternary)나 아날로그 방식 대신 이진(Binary) 방식을 사용할까요? 가장 큰 이유는 **신뢰성(Reliability)**과 **구현의 용이성(Ease of Implementation)**입니다.

* **노이즈 내성(Noise Immunity):** 전자 회로에는 항상 미세한 노이즈(잡음)가 존재합니다. 이진 시스템에서는 '낮은 전압(0)'과 '높은 전압(1)'이라는 두 상태 간의 구분이 명확하고 간격이 넓어, 약간의 노이즈가 있더라도 0인지 1인지 구분하기 쉽습니다. 만약 0, 1, 2 세 가지 상태를 사용하려면 더 좁은 전압 범위로 각 상태를 구분해야 하므로, 노이즈에 취약해져 오류가 발생할 확률이 훨씬 높아집니다. 아날로그 방식은 연속적인 값을 다루므로 노이즈에 더욱 취약합니다.
* **단순한 회로 설계:** 두 가지 상태만을 처리하는 스위치(트랜지스터)를 기반으로 논리 회로를 설계하는 것이 세 가지 이상의 상태를 처리하는 회로를 설계하는 것보다 훨씬 간단하고 비용 효율적입니다.

결국, 약간의 비효율성(더 많은 비트가 필요할 수 있음)을 감수하더라도, 오류 없이 안정적으로 정보를 처리하고 저장하는 것이 컴퓨터 시스템에서는 훨씬 중요하기 때문에 이진 방식을 채택한 것입니다.

### 트랜지스터: 0과 1을 만드는 나노 스케일 스위치 (심화)

컴퓨터가 0과 1을 물리적으로 다루는 핵심 부품은 **트랜지스터(Transistor)**입니다. 현대 CPU와 메모리에 사용되는 가장 일반적인 트랜지스터는 **MOSFET(Metal-Oxide-Semiconductor Field-Effect Transistor)**입니다.

MOSFET은 크게 **소스(Source)**, **드레인(Drain)**, **게이트(Gate)**라는 세 단자로 구성됩니다. 소스와 드레인 사이에는 전류가 흐를 수 있는 **채널(Channel)** 영역이 있고, 이 채널 위에는 절연된 게이트가 있습니다.
* 게이트에 특정 전압(문턱 전압 이상)을 가하면, 게이트 아래 채널 영역에 전기장이 형성되어 전하(전자 또는 정공)가 모이면서 소스와 드레인 사이에 전류가 흐를 수 있는 '다리'가 만들어집니다. 이 상태가 **ON (1)**입니다.
* 게이트에 전압을 가하지 않거나 문턱 전압보다 낮게 가하면, 채널에 전하가 모이지 않아 전류가 흐를 수 없습니다. 이 상태가 **OFF (0)**입니다.

즉, 게이트 전압을 조절하여 소스와 드레인 사이의 전류 흐름을 제어하는, 전기로 작동하는 아주 작은 스위치인 셈입니다.

> **무어의 법칙 (Moore's Law):** 인텔의 공동 창립자인 고든 무어(Gordon Moore)는 1965년에 "반도체 칩에 집적되는 트랜지스터의 수가 약 2년마다 2배씩 증가할 것"이라고 예측했습니다. 이 예측은 놀랍게도 수십 년간 거의 정확하게 들어맞으며 반도체 산업의 기술 발전 속도를 대변하는 상징이 되었습니다. 덕분에 컴퓨터는 점점 더 작아지고, 빨라지고, 저렴해질 수 있었습니다. 물론 최근에는 물리적 한계로 인해 그 속도가 둔화되고 있다는 논의도 있습니다.
> * [Understanding Moore's Law (Intel Newsroom)](https://newsroom.intel.com/tech101/understanding-moores-law)
> * [Moore's law (Wikipedia)](https://en.wikipedia.org/wiki/Moore%27s_law)
> * [What is Moore's Law? (Synopsys)](https://www.synopsys.com/glossary/what-is-moores-law.html)

이 작은 트랜지스터 스위치들이 수십억 개 모여 CPU, 메모리, 그래픽 카드 등을 구성하며, 초당 수십억 번씩 켜지고 꺼지면서 복잡한 계산과 데이터 처리를 수행하는 것입니다.

알겠습니다. "연산의 기초: 불 대수 (Boolean Algebra)" 챕터를 불 함수의 의의를 강조하여 다시 작성해 드릴게요. 세상의 모든 정보를 비트로 표현할 수 있기 때문에, 이 정보에 대한 모든 작업(연산, 처리, 변환 등)은 결국 비트에 대한 작업이며, 이는 불 함수로 완벽하게 기술될 수 있다는 맥락을 살려 설명하겠습니다.

### 연산의 기초: 불 대수와 불 함수 - 모든 계산의 청사진

지금까지 우리는 컴퓨터가 숫자, 글자, 이미지, 소리 등 세상의 모든 정보를 0과 1, 즉 비트(Bit)의 나열로 표현한다는 것을 확인했습니다. 그렇다면 이 비트들로 표현된 정보를 가지고 컴퓨터는 어떻게 '작업'을 수행할까요? 덧셈은 어떻게 하고, 문자는 어떻게 비교하며, 이미지는 어떻게 처리할까요?

여기에 바로 19세기 수학자 **조지 불(George Boole)**이 정립한 **불 대수(Boolean Algebra)**와 이를 바탕으로 한 **불 함수(Boolean Function)**의 위대한 의의가 있습니다.

불 대수는 참(True, 컴퓨터에서는 보통 1)과 거짓(False, 컴퓨터에서는 보통 0)이라는 단 두 가지 값만을 다루는 독특하고 강력한 수학 체계입니다. 기본적인 연산자로는 두 입력이 모두 1일 때만 1이 되는 **AND(논리곱)**, 두 입력 중 하나라도 1이면 1이 되는 **OR(논리합)**, 입력을 반대로 뒤집는 **NOT(논리 부정)**이 있습니다.

**불 함수의 핵심적인 의의는 이것입니다:** **컴퓨터 내부의 모든 정보가 비트(0 또는 1)로 표현되므로, 이 정보에 가해지는 모든 종류의 연산, 처리, 변환, 제어 등은 결국 비트를 입력받아 비트를 출력하는 관계로 정의될 수 있으며, 이러한 관계를 수학적으로 정확하게 기술하는 언어가 바로 '불 함수'라는 것입니다.**

다시 말해, 여러분이 코드로 작성하는 덧셈 연산($+$, 예를 들어 $5+3=8$), 조건문(`if...else`), 이미지 필터 적용, 데이터 압축 알고리즘 등 그 어떤 복잡한 작업이라도 가장 근본적인 수준에서는 수많은 비트 입력(0과 1의 패턴)을 받아 특정 규칙에 따라 새로운 비트 출력(0과 1의 패턴)을 만들어내는 과정으로 분해될 수 있습니다. 그리고 이 '특정 규칙'을 명확하고 모호함 없이 정의하는 것이 바로 불 함수입니다.

예를 들어, 두 개의 비트 A와 B를 더하는 연산을 생각해 봅시다. 이 연산은 두 개의 출력 비트, 즉 '합(Sum)' 비트와 다음 자리로 넘어가는 '올림수(Carry)' 비트를 생성합니다. 이 덧셈 규칙은 다음과 같은 불 함수들로 정확하게 표현될 수 있습니다 (자세한 내용은 다음 시간에 다룰 '가산기'에서 배우게 됩니다):
* $Sum = A \oplus B$ (A XOR B)
* $Carry = A \cdot B$ (A AND B)

이처럼 불 함수는 컴퓨터가 수행해야 할 작업을 비트 수준에서 정의하는 **설계도 또는 청사진**과 같습니다. 아무리 복잡한 프로그램이라도 결국은 기본적인 AND, OR, NOT 연산자들을 조합하여 만들어진 불 함수들의 집합으로 구현될 수 있습니다. 컴퓨터 과학자나 하드웨어 설계자는 이 불 함수를 이용하여 원하는 기능을 수행하는 논리 회로를 설계하고 분석합니다.

### 불 함수와 진리표: 연산 규칙의 명세서

그렇다면 특정 불 함수가 어떤 입력에 대해 정확히 어떤 출력을 내놓는지 어떻게 알 수 있을까요? 이때 사용하는 것이 바로 **진리표(Truth Table)**입니다. 진리표는 어떤 불 함수의 모든 가능한 입력 비트 조합과, 각각의 조합에 대해 함수가 출력하는 비트 값을 일목요연하게 보여주는 표입니다. 이는 마치 함수의 '상세 명세서'와 같아서, 함수의 동작을 완벽하게 정의합니다.

예시: $F(A, B) = A \cdot B$ (AND 연산)의 진리표

| A | B | $F(A, B) = A \cdot B$ |
| :---: | :---: | :---: |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

> **미리보기:** 다음 시간에는 이 기본적인 불 연산(AND, OR, NOT)을 실제로 구현하는 전자회로 부품인 '논리 게이트(Logic Gate)'에 대해 자세히 알아볼 것입니다. 그리고 이 게이트들을 레고 블록처럼 조립하여 어떻게 이진수 덧셈과 같은 실제적인 계산을 수행하는 '가산기(Adder)' 회로를 만드는지 직접 살펴보며, 불 함수가 어떻게 하드웨어로 구현되는지 구체적으로 이해하는 시간을 가질 예정입니다. 진리표를 직접 채워보는 인터랙티브 컴포넌트도 준비 중이니 기대해주세요!
> * [Truth table (Wikipedia)](https://en.wikipedia.org/wiki/Truth_table)
> * [Boolean Functions (GeeksforGeeks)](https://www.geeksforgeeks.org/boolean-functions/)
> * [Boolean Algebra Truth Tables (Electronics Tutorials)](https://www.electronics-tutorials.ws/boolean/bool_7.html)

### 불 함수와 진리표: 연산 규칙의 명세서

불 대수의 연산을 이용해 만든 함수, 즉 입력을 받아 0 또는 1을 출력하는 함수를 **불 함수(Boolean Function)**라고 합니다. 예를 들어, ~~ 와 같은 형태입니다.

어떤 불 함수가 각 입력 조합에 대해 어떤 출력을 내는지 명확하게 보여주는 표가 바로 **진리표(Truth Table)**입니다. 진리표는 함수의 모든 가능한 입력 경우의 수와 그에 따른 출력 결과를 목록으로 보여줍니다.

예시: $F(A, B) = A \cdot B$ (AND 연산)의 진리표

| A | B | $F(A, B) = A \cdot B$ |
| :---: | :---: | :---: |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

> **미리보기:** 다음 시간에는 이 기본적인 불 연산(AND, OR, NOT)을 수행하는 전자회로인 '논리 게이트(Logic Gate)'에 대해 자세히 알아볼 것입니다. 그리고 이 게이트들을 레고 블록처럼 조립하여 어떻게 이진수 덧셈과 같은 실제적인 계산을 수행하는지 직접 만들어보며 이해하는 시간을 가질 예정입니다. 진리표를 직접 채워보는 인터랙티브 컴포넌트도 준비 중이니 기대해주세요!
> * [Truth table (Wikipedia)](https://en.wikipedia.org/wiki/Truth_table)
> * [Boolean Functions (GeeksforGeeks)](https://www.geeksforgeeks.org/boolean-functions/)
> * [Boolean Algebra Truth Tables (Electronics Tutorials)](https://www.electronics-tutorials.ws/boolean/bool_7.html)

오늘은 정보의 단위인 비트의 의미부터 시작하여, 컴퓨터가 다양한 정보를 0과 1로 표현하는 방법, 이진법을 사용하는 이유, 그리고 이 모든 것을 가능하게 하는 트랜지스터와 불 대수까지 좀 더 깊이 있게 살펴보았습니다. 다음 시간에는 이 이론들이 어떻게 실제 '계산'으로 이어지는지, 논리 게이트의 세계를 함께 탐험해 보겠습니다. 읽어주셔서 감사합니다!