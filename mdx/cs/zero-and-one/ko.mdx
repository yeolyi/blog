export const title = '컴퓨터의 손가락이 두 개인 이유'
export const description = '0과 1 두 숫자가 어떻게 소리, 글자, 이미지, 그리고 우리가 상상하는 모든 것을 담아내는 첫걸음이 되는지 살펴봅시다.'
export const ogImage = 'cs/og1.png'

import PixelateImage from '@/components/cs/PixelateImage';
import SignalComparison from '@/components/cs/SignalComparison';
import Image from '@/components/ui/Image';
import TruthTable from '@/components/cs/TruthTable';

import cover from './assets/cover.png';
import zeroone from './assets/zeroone.png';
import painting from './assets/painting.png';
import lp from './assets/lp.png';
import shannon from './assets/shannon.png';

<Image src={painting} alt="painting" className="object-cover w-full h-[180px]"/>

아주 오래전부터 인류는 주변 세상을 경험하고 그 속에서 발견한 의미 있는 순간이나 지식을 어떤 형태로든 남기고자 했습니다. 동굴 벽에 역동적인 사냥 장면을 새겨 넣던 순간부터, 파피루스에 문자를 기록하여 지혜를 전달하던 순간들이 바로 그러한 노력의 일환이었죠. 이는 세상을 이해하고 타인과 소통하려는 인간의 가장 기본적인 모습 중 하나였습니다.

<Image src={lp} alt="LP" className="object-cover w-full h-[180px]"/>

특히 소리나 빛처럼 **연속적으로 변화하는 자연 현상**을 있는 그대로 담아내려는 시도는 오랫동안 이어져 왔습니다. 예를 들어, 레코드판은 가수의 목소리나 악기의 미세한 떨림, 즉 공기의 파동을 레코드 표면의 모양이라는 연속적인 형태로 새겨 넣습니다. 오래된 필름 카메라도 마찬가지로 렌즈를 통해 들어온 빛의 다양한 세기를 필름 위 화학 물질의 연속적인 변화로 남겨 하나의 장면을 만들어내죠. 이처럼 현실 세계의 정보를 그 연속적인 특성 그대로 표현하는 방식들을 **아날로그**라고 부릅니다.

<Image src={zeroone} alt="zeroone" className="object-cover w-full h-[180px]"/>

그런데 현대 문명의 핵심인 컴퓨터는 정보를 다루는 데 있어 이 아날로그 방식과는 전혀 다른 독특한 길을 선택했습니다. 바로 **디지털** 방식입니다. 끊임없이 변화하는 다채로운 현실 세계의 정보를 몇 가지의 명확히 구분되는 값으로만 표현한다는 아이디어죠. 

어떻게 이런 단순함으로 저토록 풍부한 아날로그 세상을 담아낼 수 있다는 걸까요? 왜 컴퓨터는 이런 방식을 택했을까요? 지금부터 우리는 컴퓨터가 디지털 방식을 선택한 이유를 살펴보고 컴퓨터의 가장 기본적인 단위인 0과 1의 세계로 함께 떠나보려 합니다. 이 두 숫자가 어떻게 소리, 글자, 이미지, 그리고 우리가 상상하는 모든 것을 담아내는 첫걸음이 되는지 살펴보시죠.

## 세상을 쪼개는 컴퓨터

**디지털**은 세상의 모든 정보를 아주 작은 조각으로 잘게 나누어 단순한 숫자로 표현하는 방식입니다. 이 쪼개어진 조각 하나하나가 컴퓨터가 이해할 수 있는 가장 기본적인 정보 단위가 됩니다.

사진을 예로 들어볼까요? 우리가 필름 카메라로 사진을 찍으면, 빛이 필름 표면에 연속적인 색조와 밝기의 변화로 이미지를 기록합니다. 완전한 아날로그 정보죠. 하지만 디지털카메라는 이미지를 아주 작은 네모난 점, 즉 픽셀로 먼저 나눕니다. 그리고 각 픽셀은 담당하는 작은 영역에서 감지된 빛의 세기와 색상 정보를 하나의 숫자 값으로 변환하고 저장합니다. 결국 피사체는 수많은 픽셀 값, 즉 방대한 디지털 데이터로 변환되는 것입니다.

<PixelateImage />

그렇다면 컴퓨터는 왜 이렇게 세상을 잘게 쪼개어 디지털로 이해하려 할까요? 첫 번째 이유는 바로 **정보의 명확함과 외부 간섭으로부터의 강인함** 때문입니다. 아날로그 신호는 연속적이라 미세한 변화에도 민감하고, 주변의 작은 소리나 전기적 잡음에도 쉽게 원래 모습이 흐려지거나 변형될 수 있습니다. 하지만 디지털은 정보를 '있다/없다', '높다/낮다'처럼 명확히 구분되는 상태로 표현합니다. 덕분에 약간의 간섭이 있더라도 컴퓨터는 원래의 값을 분명하게 알아볼 수 있어, 정보가 훨씬 안정적으로 유지되고 처리될 수 있는 강력한 기반을 마련합니다.

두 번째 이유는 이렇게 명확하게 표현된 정보는 **손실 없이 완벽하게 다룰 수 있다**는 점입니다. 종이 위의 글이나 그림을 복사기로 복사하고, 그렇게 나온 복사본을 다시 복사기에 넣어 또 복사하는 과정을 몇 번만 반복해도, 내용이 점점 흐릿해지고 번져서 결국 원본을 알아보기 어렵게 되는 것을 본 적 있으실 겁니다. 아날로그 정보가 이처럼 전달되거나 복사될 때 정보의 왜곡이나 손실이 쉽게 일어나는 것과 달리 디지털 정보는 수백만 번을 복사하거나 지구 반대편으로 전송해도 원본과 조금도 다르지 않은 내용을 완벽하게 유지합니다. 이는 데이터의 신뢰성이 중요한 컴퓨터 작업에 필수적인 특징입니다.

이렇게 컴퓨터가 아날로그가 아닌 디지털 방식을 사용하는 이유를 살펴보았습니다. 그런데 0, 1, 2를 사용하는 3진법이나 0, 1, 2, 3을 사용하는 4진법도 디지털 방식일텐데 컴퓨터는 왜 두 가지 상태만을 사용하는 이진법을 핵심 원리로 삼았을까요? 

## 컴퓨터의 손가락은 두 개

사람은 손가락이 10개여서 10진법을 쓰니 2진법을 쓰는 컴퓨터는 손가락이 2개라고 생각할 수 있겠습니다. 컴퓨터가 이진법을 사용하는데에는 매우 **현실적인 하드웨어 공학적인 이유**가 있습니다.

컴퓨터는 전기로 작동하며, 전기 신호는 생각보다 내재적인 변동성을 지닙니다. 만약 '꺼짐', '약간 켜짐', '보통', '강하게 켜짐' 같이 여러 단계로 신호 세기를 구분해 정보를 표현하려 한다면 아주 정밀한 제어가 필요합니다. 하지만 전기 신호는 전선을 지나면서 약해지기도 하고, 부품이 오래되면 제 성능을 못 내기도 하며, 작동 중 발생하는 열 때문에 신호가 흔들리기도 합니다. 이런 신호 품질 저하때문에 여러 단계로 나뉜 신호 중 하나가 다른 단계로 쉽게 오인될 수 있습니다. '강하게 켜짐' 신호가 약해져 '보통'으로 잘못 읽히면, 컴퓨터는 계산을 틀리고 결국 멈춰버릴 겁니다.

이런 불안정함 속에서 가장 확실하게 정보를 구분하는 방법은 '분명히 높거나(1)' 아니면 '분명히 낮거나(0)'처럼, 두 가지 상태만을 사용하는 것입니다. 신호가 다소 약해지거나 약간의 잡음이 섞여도, 1로 인식될 만큼 충분히 높거나 0으로 인식될 만큼 충분히 낮다면 컴퓨터는 정보를 정확히 판독할 수 있습니다. **이처럼 2진법은 신호의 작은 변화에도 훨씬 너그럽고, 덕분에 안정적인 컴퓨터를 만들 수 있습니다**. 

<SignalComparison />

결국, 컴퓨터가 2진법을 쓰는 건 **불완전한 현실 세계의 전기 신호로도 믿을 수 있는 기계를 만들려는** 엔지니어들의 가장 실용적인 선택이었던 셈입니다. 복잡하고 정밀한 기계를 안정적으로 구현하기 위한 최선의 방법인 것이죠.

## 비트

<Image src={cover} alt="computer wearing sunglasses"/>

앞서 컴퓨터가 0과 1이라는 두 가지 상태를 사용해 정보를 표현한다고 이야기했습니다. 바로 이 0 또는 1 하나하나, 즉 컴퓨터가 다루는 가장 작은 정보의 단위를 **'비트(bit)'** 라고 부릅니다. 우리가 컴퓨터로 하는 모든 정교한 작업은 결국 이 작은 비트들을 다루는 과정이라고 볼 수 있습니다.

## 0과 1을 현실로 가져오기

전기 신호로 표현된 수많은 비트들을 컴퓨터는 그저 저장만 하고 있다면 그건 단순한 기억 장치에 불과할 겁니다. 컴퓨터의 진짜 능력은 바로 이 비트들을 가져다 의미 있는 방식으로 처리하여 우리가 원하는 결과를 만들어내는 데 있습니다. 그렇다면 이 0과 1에 어떻게 의미를 부여하고 논리적인 판단의 기초로 삼을 수 있었을까요?

그 기반은 19세기 영국 수학자 조지 불(George Boole) 이 제시한 **불 대수(Boolean Algebra)** 에서 찾을 수 있습니다. 불은 인간의 논리적 사고 과정을 참과 거짓이라는 단 두 가지 값과 이 값들 사이의 관계를 다루는 몇 가지 기본 연산으로 수학처럼 명쾌하게 표현할 수 있는 체계를 만들었습니다. 

놀랍게도, 컴퓨터가 정보를 표현하기 위해 사용하는 0과 1이라는 두 가지 상태는 이 불 논리의 참과 거짓을 나타내는 데 완벽한 수단이었습니다. 사람들은 컴퓨터의 **0을 불 논리의 거짓으로, 1을 참으로** 약속함으로써 기계 내부의 단순한 전기 신호에 논리적인 의미를 부여하고 이를 바탕으로 추론과 연산을 수행할 수 있는 길을 성공적으로 열었습니다. 

하지만 0과 1로 표현된 참/거짓 값들을 실제로 가져다가 새로운 참/거짓 결과를 만들어내는 물리적인 방법, 즉 '연산 회로'를 어떻게 만들 수 있을까요? 추상적인 논리와 실제 전기 회로를 구체적으로 연결하여 연산을 가능하게 하는 방법을 제시한 사람이 바로 미국의 과학자이자 수학자인 클로드 섀넌입니다. Antropic사에서 만든 Claude AI의 이름이 바로 이 분의 이름을 따서 지은 것이라네요.

섀넌은 1937년, 그가 **스물한 살**이던 해에 MIT에서 발표한 그의 석사 학위 논문, [A Symbolic Analysis of Relay and Switching Circuits](/cs/shannon38.pdf) 에서 놀라운 통찰을 보여주었습니다. 

<Image src={shannon} alt="Claude Shannon" />

그는 0(거짓)과 1(참)로 표현되는 **불 대수의 원리들이 스위치(켜짐/꺼짐)로 작동하는 전기 회로를 설계하고 분석하는 데 그대로 적용될 수 있음**을 수학적으로 증명해 보였습니다. 덕분에 복잡하기만 했던 전기 회로 설계가 명확한 수학적 원리를 따르는 과학의 영역으로 들어올 수 있게 되었죠. 그의 석사 논문은 디지털 시대의 문을 연 핵심적인 연구로 인정받고 있습니다.

이제 이 논리를 이용해 규칙들을 만들고 정보를 처리해봅시다. 여기서부터 **불 함수(Boolean Function)** 의 이야기가 시작됩니다.

## 0과 1로 우산 챙기기

불 함수란, 하나 이상의 불 값들을 입력으로 받아, 정해진 논리 규칙에 따라 하나의 불 값을 결과로 내놓는 함수를 말합니다. 이 불 함수가 어떤 규칙으로 작동하는지, 즉 어떤 입력 값들의 조합에 대해 어떤 출력 값을 내놓는지를 모든 경우에 대해 명확하게 보여주는 표가 바로 **진리표(Truth Table)** 입니다. 

예를 들어, 우리가 일상에서 '언제 우산을 챙길까?'를 결정하는 아주 간단한 상황을 불 함수와 진리표로 표현해 볼까요? 두 가지 조건, 즉 두 개의 불 값을 입력으로 생각할 수 있습니다.

* **입력 A:** 오늘 비 예보가 있는가? (0: 아니오, 1: 예)
* **입력 B:** 오늘 외출할 계획이 있는가? (0: 아니오, 1: 예)

그리고 이 두 입력에 따라 결정되는 우리의 행동, 즉 출력은 다음과 같습니다.

- **출력**: '우산을 챙긴다' (0: 아니오, 1: 예)

우리는 보통 '비 예보도 있고, 외출도 할 계획이 있을 때만' 우산을 챙길 겁니다. 이러한 규칙을 가진 불 함수를 진리표로 나타내면 다음과 같습니다.

<TruthTable
  labels={[
    { label: '비 예보', type: 'input' },
    { label: '외출 계획', type: 'input' },
    { label: '우산 챙기기', type: 'output' },
  ]}
  data={[
    [false, false, false],
    [false, true, false],
    [true, false, false],
    [true, true, true],
  ]}
/>

이 진리표는 우리가 우산을 챙기는 논리적 결정 과정을 명확하게 보여줍니다. 오직 입력 A와 입력 B가 모두 '참(1)'일 때만 최종 출력 '우산 챙기기'가 '참(1)'이 되는 규칙인 것이죠. 이처럼 어떤 복잡한 조건이나 결정이라도 그 논리적 구조를 파악하면 불 함수와 진리표로 표현할 수 있습니다. **컴퓨터 내부에서는 이렇게 진리표로 정의될 수 있는 수많은 불 함수들이 다양한 판단과 연산을 수행하고 있습니다.**

## 마무리

이렇게 해서 컴퓨터가 세상을 인식하는 가장 근본적인 방식인 **아날로그와 디지털의 차이**에서부터 시작하여, 왜 컴퓨터가 0과 1이라는 **이진법**을 선택했는지 그 현실적인 이유를 살펴보았습니다. 더 나아가, 이 **비트**들이 어떻게 '참'과 '거짓'이라는 논리적 의미를 품게 되고, 이 논리가 어떻게 실제 **전기 회로와 연결**될 수 있었는지, 그리고 마침내 이 논리들을 다루는 기본 규칙인 **불 함수**와 그 행동을 명확히 보여주는 **진리표**까지 살펴보았습니다.

다음 게시물에서는 마지막에 등장했던 불 함수와 진리표가 어떻게 논리 게이트를 통해 현실 셰계에 구현되는지 그 과정을 함께 따라가 볼 예정입니다!
