# ìë°”ìŠ¤í¬ë¦½íŠ¸

## ì†Œê°œ

ìë°”ìŠ¤í¬ë¦½íŠ¸ ê³µë¶€ ê¸°ë¡ì…ë‹ˆë‹¤. êµì¬ë¡œ **Javascript-The-Definitive-Guide**(David
Flanagan)ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ê³µë¶€í•˜ë©´ì„œ ëª°ëë˜ ê²ƒë“¤ê³¼ í¥ë¯¸ë¡œìš´ ê²ƒë“¤ì„ ì¸ìš©í•˜ê³ 
ê¸°ë¡í•©ë‹ˆë‹¤.

ê³µë¶€ì— ì•ì„œ ëª‡ëª‡ ì»´í¬ë„ŒíŠ¸ë“¤ì„ ì¤€ë¹„í–ˆìŠµë‹ˆë‹¤. ìš°ì„  ì¶œë ¥ê°’ í™•ì¸ì„ ìœ„í•´ ì•„ë˜
ì»´í¬ë„ŒíŠ¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì½”ë“œë¥¼ ìˆ˜ì •í•´ë³´ì„¸ìš”.

```js
// console
console.log('Hello, world!');
```

í…ŒìŠ¤íŠ¸ë¥¼ ì œê³µí•˜ëŠ” ì»´í¬ë„ŒíŠ¸ë„ ì¤€ë¹„í–ˆìŠµë‹ˆë‹¤. ì•„ë˜ ì»´í¬ë„ŒíŠ¸ì—ì„œ add í•¨ìˆ˜ë¥¼
ì™„ì„±í•´ë³´ì„¸ìš”.

```js
// test
export const add = (a, b) => {
  // TODO
  return 0;
};

// jest
import { add } from './index.js';

describe('add', () => {
  test('Commutative Law of Addition', () => {
    expect(add(1, 2)).toBe(add(2, 1));
  });

  test('Random value', () => {
    const a = Math.random();
    const b = Math.random();
    expect(add(a, b)).toBe(a + b);
  });
});
```

## 1. Introduction to Javascript

> The core JavaScript does not include any input or output functionality. Input
> and output (as well as more sophisticated features, such as networking,
> storage, and graphics) are the responsibility of the â€œhost environmentâ€ within
> which JavaScript is embedded.

### 3. A Tour of JavaScript

```js
// console
console.log([1, 2] + [3, 4, 5]);
```

> Roughly, an **expression** is something that computes a value but doesnâ€™t do
> anything: it doesnâ€™t alter the program state in any way. **Statements**, on
> the other hand, donâ€™t have a value, but they do alter the state

## 2. Lexical Structure

> The lexical structure of a programming language is the set of elementary rules
> that specifies how you write programs in that language.

### 4. Identifiers and Reserved Words

letë„ ë³€ìˆ˜ëª…ìœ¼ë¡œ ê²½ìš°ì— ë”°ë¼ ì“¸ ìˆ˜ëŠ” ìˆìŠµë‹ˆë‹¤. ì• ë§¤í•œ ê²ƒë“¤ì€ ê·¸ëƒ¥ ì“°ì§€ ë§™ì‹œë‹¤ ã…

```js
// console
// ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë³µë¶™í•˜ë©´ ë˜ëŠ”ë° ì—¬ê¸°ì„œëŠ” ìƒŒë“œë°•ìŠ¤ ë•Œë¬¸ì¸ì§€ ì—ëŸ¬ ëœ¸ :(

// var let = 'hello, world!';
// console.log(let);
```

### 5. Unicode

```js
// console
const Ï€ = 3.14;
console.log(Ï€, '\u{1F600}'); // ìˆ«ì ì§ì ‘ ë°”ê¿”ë³´ì„¸ìš”!

// const ğŸ¥² = 'cry';
// swiftëŠ” ë˜ë˜ë°,,,
```

ëª¨ì–‘ì´ ê°™ì€ ë¬¸ìë”ë¼ë„ ë‹¤ë¥¸ ìœ ë‹ˆì½”ë“œ ê°’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìœ ë‹ˆì½”ë“œ í‘œì¤€ì—
normalization ë°©ë²•ì´ ì •ì˜ë˜ì–´ìˆëŠ”ë° JSê°€ ì´ê±¸ í•´ì£¼ì§€ëŠ” ì•Šìœ¼ë¯€ë¡œ ì‹ë³„ì ëª¨ì–‘ì€
ê°™ì€ë° ë‹¤ë¥¸ ê°’ì¸ ìƒí™©ì„ ë§Œë“¤ì§€ ì•Šìœ¼ë ¤ë©´ ì—ë””í„° ë“±ì—ì„œ ì˜ í•´ì£¼ëŠ”ì§€ í™•ì¸í•©ì‹œë‹¤.

### 6. Optional Semicolons

ì„¸ë¯¸ì½œë¡ ì´ ì—†ìœ¼ë©´ ì•ˆë˜ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤.

```js
// console

// prettier-ignore
let y = 1 + 2
(3 + 4).toString()
```

## 3. Types, Values, and Variables

> JavaScript differs from more static languages in that functions and classes
> are **not just part of the language syntax**: they are themselves values that
> can be manipulated by JavaScript programs

### 1. Overview and Definitions

> Strings can be thought of as arrays of characters, and you might expect them
> to be mutable. In JavaScript, however, **strings are immutable**: you can
> access the text at any index of a string, but JavaScript provides no way to
> alter the text of an existing string.

```js
// console
const str = 'davascript';
str[0] = 'j';
```

### 2. Numbers

64ë¹„íŠ¸ ë¶€ë™ì†Œìˆ˜ì ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•´ë„ ì—ëŸ¬ë¥¼ ë˜ì§€ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.

```js
// console
let val = Number.MAX_VALUE;
// (val + 1ì€ ì™œ Infinityê°€ ì•„ë‹ˆì§€?)
console.log(val, val + 1, val ** 2);
console.log(val === val + 1);
```

í•˜ì§€ë§Œ ë°°ì—´ ì¸ë±ì‹±ì´ë‚˜ ë¹„íŠ¸ ì—°ì‚°ë“±ì€ 32ë¹„íŠ¸ ì •ìˆ˜ ì—°ì‚°ì„ í•©ë‹ˆë‹¤.

```js
// console
console.log(1 << 30, 1 << 31, 1 << 32);
```

16ì§„ìˆ˜ë„ ì•„ë˜ì²˜ëŸ¼ ë°”ë¡œ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. CSS ìƒ‰ìƒê°’ ë„£ì„ ë•Œ ì¢…ì¢… ì”ë‹ˆë‹¤(ì €ëŠ”
ë¬¸ìì—´ì´ ìµìˆ™í•´ì„œ ë³¼ë•Œë§ˆë‹¤ í ì¹«í•˜ì§€ë§Œ).

```js
// console
console.log(0x333);
```

ì´ì™¸ì—ë„ íŠ¹ì´í•œ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.

```js
// console
console.log(1 / 0, 0 / 0, Infinity / 0, Infinity / Infinity);

let zero = 0;
let negZero = -0;
console.log(zero === negZero);
console.log(1 / zero === 1 / negZero);
```

NaNì€ ëª¨ë“  ê°’ê³¼ ë¹„êµ ê²°ê³¼ê°€ falseì…ë‹ˆë‹¤. Number.isNaN ì´ë‚˜ isNaNì„ ì”ì‹œë‹¤.
https://stackoverflow.com/questions/33164725/confusion-between-isnan-and-number-isnan-in-javascript

```js
// console
const val = NaN;
console.log(val === NaN, Number.isNaN(val));
```

ì•„ë˜ì™€ ê°™ì€ ê²½ìš°ë¥¼ ì´í•´í•˜ë ¤ë©´ ë¶€ë™ì†Œìˆ˜ì  í‘œì¤€ì¸ IEEE-754ë¥¼ ê³µë¶€í•´ë´…ì‹œë‹¤.

```js
// console
let x = 0.3 - 0.2;
let y = 0.2 - 0.1;
console.log(x === 0.1, y === 0.1);
```

> If these floating-point approximations are problematic for your programs,
> consider using scaled integers. For example, you might manipulate monetary
> values as integer cents rather than fractional dollars.

ì´ë”ë¦¬ì›€ì—ì„œ weië¼ëŠ” ìµœì†Œ ë‹¨ìœ„(=10^(-18)ether)ë¥¼ ì“°ëŠ”ë° ì´ê²Œ ìœ„ì—ì„œ ë§í•œ scaled
integerê³¼ ë¹„ìŠ·í•œ ê²ƒ ê°™ìŠµë‹ˆë‹¤.

BigIntì™€ Numberê°„ì˜ ì—°ì‚°ì€ ë‘ ìë£Œí˜•ì´ í¬í•¨ê´€ê³„ê°€ ì•„ë‹ˆë¯€ë¡œ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤. ë¹„êµ
ì—°ì‚°ì€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

> Note, however, that BigInt implementations are not suitable for cryptography
> because they do not attempt to prevent timing attacks.

Timing attackì— ëŒ€í•´ì„œëŠ” https://timing.attacks.cr.yp.to/programming.html ë¥¼
ì°¸ê³ í•˜ì„¸ìš”.

### 3. Text
